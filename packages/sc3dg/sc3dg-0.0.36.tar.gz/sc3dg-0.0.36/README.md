# STARK tutorial

STARK is a  software for processing various types of single-cell Hi-C sequencing data, which currently includes the  single-cell Hi-C technologies as follows:

- <a href='#1schi-c'>scHiC<a>
- [scHi-C+](#2schi-c)
- [Dip-C](#3dip-c)
- [HiRES](#4hires)
- [sn-m3C](#5sn-m3c)
- [scSPRITE](#6scsprite)
- [sciHi-C](#7scihi-c)
- [snHi-C](#8snhi-c)
- [snHi-C](#9snhi-c)
- [scNanoHi-C](#10scnanohi-c)
- [scMethyl](#11scmethyl)
- [scCARE-seq](#12sccare-seq)

At the same time, we also provide a generalized way to process the sc3DG for details please see the tutorial.

To get started：
- Install STARK
- Read the documentation and see the Jupyter Notebook walkthrough.
- test data can be download form [Zenodo](https://zenodo.org/records/10426561/files/tutorial.tar.gz)
- Many more single-cell Hi-C data are available on our website

# Installation


We suggest creating a new python environment to· install STARK before installation and STARK is based on python≥3.9

```python
conda create -n STARK python=3.9 
conda activate STARK
pip install numpy pysam cython
pip install STARK
```

STARK is based on software such as bwa, bowtie2, minimap2, fastp, hicexploer, samtools, bedtools, bedtools, bismark, nanoplexer, etc. Please make sure you have installed the corresponding software before using it. You can write the following code into a shell script and run it.

```python
# install.rst bwa
yes|conda install -c bioconda bwa
# install.rst bowtie2
yes|conda install -c bioconda bowtie2
# install.rst minimap2
yes|conda install -c bioconda minimap2
# install.rst fastp
yes|conda install -c bioconda fastp
# install.rst hicexplorer
yes|conda install -c bioconda hicexplorer
# install.rst samtools
yes|conda install -c bioconda samtools
# install.rst bedtools
yes|conda install -c bioconda bedtools
# install.rst bismark
yes|conda install -c bioconda bismark
# install.rst nanoplexer
yes|conda install -c bioconda nanoplexer
```
Also, you can download the .zip of STARK and add the STARK to the environment
```linux
get clone 
cd 
gunzip 
export 
```


# Usage

### Prepare index and enzyme bed

schikit has its own format for reading reference genomes and enzyme bed files. For convenience, we provide an automated program for building indexes and enzyme bed files:

```python
STARK index -g hg38 -a bwa -p ./save/path -e MboI,DpnII,BglII,HpyCH4V
```

Parameter description:

- -g: The genome version you want to assemble, currently supports hg38, hg19, mm10, mm9.
- -a: The software used for assembly, different software produces different index files
- -p: Path where the results are stored
- -e: The required enzyme bed file, can be single or multiple inputs (different genomes correspond to different enzyme files)

## **Typical Workflow**

### 1.scHi-C

Test data: /tutorial/scHi-C/data

```bash
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t scHic \
	-e MboI \
	-r 10000 \
	-i /path/to/index/hg38.fa \
	-a bwa \
	--thread 60
```

Parameter Description:

- -o Location to save the result, note that **all paths must be absolute paths.**
- -f Directory where the sequencing data is located
- -t Type of single-cell Hi-C
- -e Type of restriction enzyme used, must be consistent with the experiment
- -r Resolution used to convert pairs files into cool files
- -i Directory of the genome file used for alignment, the final hg38.fa is the type of genome, not part of the directory, consistent with the -g parameter of STARK index
- -a The software used for assembly, optional bwa, bowtie2, bismark, minimap2. Here it should be consistent with the index produced by STARK index

### 2.scHi-C+

Test data: /tutorial/scHic_index/data

It should be noted that the number of fastq files generated by this technique should be 4, where _1 and _4 are reads, and _2 and _3 are the corresponding barcode files.

```python
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t scHic \
	-e MboI \
	-r 10000 \
	-i /path/to/index/hg38.fa \
	--aligner bwa \
	--thread 60 \
	--exist-barcode
```

Note that:

The only difference with scHi-C is that you need to specify that it has barcodes wtih parameter —exist-barcode.

### 3.Dip-C

Test data: /tutorial/Dip-C/data

```python
STARK count -o /path/to/save \
	-f /path/to/fastq \
				-t Dip-C \
				-e MboI \
				-r 10000 \
				-i /path/to/index/hg38.fa \
				--aligner bwa \
				--thread 60
```

Similar with scHi-C, STARK will automatically process the following steps according to the parameter -t.

### 4.HiRES

Test data: /tutorial/HRIES/data

```python
STARK count -o /path/to/save \
	-f /path/to/fastq \
				-t HiRES \
				-e MboI \
				-r 10000 \
				-i /path/to/index/mm10.fa \
				-a bwa \
				--thread 60
```

Similar with scHi-C, STARK will automatically process the follow-up according to the parameter -t.

### 5.sn-m3C

Test data: /tutorial/sn-m3C/data

```python
STARK count -o /path/to/save \
			-f /path/to/fastq \
				-t sn-m3C \
				-e MboI \
				-r 10000 \
				-i /path/to/index/hg38.fa \
				--aligner bowtie2 \
				--thread 60
```

Since the sn-m3C sequencing simultaneously methylation and Hi-C, only bismark can be used for assembly. Correspondingly, there is no multiple choice for -i and -a. However, bismark is based on bowtie2, you can write the parameters as bowtie2.

### 6.scSPRITE

Test data: /tutorial/scSPRITE/data

```python
STARK count -o /path/to/save \
        -f /path/to/fastq \
				-t scSPRITE \
				-e HpyCH4V \
				-r 10000 \
				-i /path/to/index/mm10.fa \
				-a bwa \
				--thread 60 \
				--sprite-config /cluster/home/tmp/ckw/tutorial/scSPRITE/data/config_dpm6_y-stag_scSPRITE2.txt \
				--repeat-masker /cluster/home/tmp/ckw/tutorial/scSPRITE/data/mm10_rmsk.bed
```
Parameter Description:
- --sprite-config is a txt file for scSPRITE generating barcode.
- --repeat-masker is a bed file for genome masking of repetitive regions

### 7.sciHi-C

Test data: /tutorial/sciHi-C/data. It should be noted that not only two sequencing fastq files are needed in each sequencing file directory, but also txt files corresponding to inner_barcode.txt and outer_barcode.txt are needed. The format is as shown in the example.

```python
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t sciHi-C \
	-e DpnII \
	-r 10000 \
	-i /path/to/index/mm10.fa \
	--aligner bwa \
	--thread 60 \
	--exist-barcode
```

Similar with scHic_index, STARK will automatically carry out subsequent processing according to the parameter -t.

### 8.snHi-C

Test data: /tutorial/snHi-C/data

```python
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t snHic \
	-e DpnII \
	-r 10000 \
	-i /path/to/index/hg38.fa \
	--aligner bwa \
	--thread 60
```

Similar with scHi-C, STARK will automatically process the follow-up according to the parameter -t.

### 9.snHi-C+

Test data: /tutorial/snHi-C+/data

```python
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t snHic \
	-e MboI \
	-r 10000 \
	-i /path/to/index/hg38.fa \
	--aligner bwa \
	--thread 60 \
	--exist-barcode
```

Similar with scHi-C, STARK will automatically process the following steps according to the parameter -t.

### 10.scNanoHi-C

Test data: /tutorial/scNanoHi-C/data

It is worth noting that scNanoHi-C uses third-generation sequencing, and the sequnencing data directory not only should contain the fastq file, but alse the TN5.txt, PCR.txt and index.txt

```python
STARK count -o /path/to/save \
    -f /path/to/fastq \
				-t scNanoHi-C \
				-e MboI \
				-r 10000 \
				-i /path/to/index/mm10.fa \
        -a bwa \
				--thread 60 
```

scNanoHi-C uses third-generation sequencing technology, and uses minimap2 by default. So  the -a parameter will become ineffective.

### 11.scMethyl

Test data: /tutorial/scNanoHi-C/data

```bash
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t scMethyl \
	-e MboI \
	-r 10000 \
	-i /path/to/index/hg38.fa \
	--aligner bwa \
	--thread 60
```

### 12.scCARE-seq

Test data: /tutorial/scCARE-seq/data

```bash
STARK count -o /path/to/save \
	-f /path/to/fastq \
	-t scCARE \
	-e MboI \
	-r 10000 \
	-i /path/to/index/hg38.fa \
	--aligner bwa \
	--thread 60
```


## Result

Here is the introduction to the results:

```python
scSPRITE_test_tmp/
├── Result
│   ├── cool_folder
│       ├── [Even2Bo10][Odd2Bo69][DPM6bot1]_10000.cool
│       ├── [Even2Bo10][Odd2Bo69][DPM6bot1]10000.KR.cool
│       ├── [Even2Bo11][Odd2Bo19][DPM6bot31]_10000.cool
│       ├── [Even2Bo11][Odd2Bo19][DPM6bot31]10000.KR.cool
│       ├── [Even2Bo11][Odd2Bo1][DPM6bot75]_10000.cool
│       ├── [Even2Bo11][Odd2Bo1][DPM6bot75]10000.KR.cool
│   ├── mcool_folder
│   │   ├── [Even2Bo10][Odd2Bo69][DPM6bot1].mcool
│   │   ├── [Even2Bo11][Odd2Bo19][DPM6bot31].mcool
│   │   ├── [Even2Bo11][Odd2Bo1][DPM6bot75].mcool
│   └── SCpair
│       ├── [Even2Bo10][Odd2Bo69][DPM6bot1].pairs.gz
│       ├── [Even2Bo11][Odd2Bo19][DPM6bot31].pairs.gz
│       ├── [Even2Bo11][Odd2Bo1][DPM6bot75].pairs.gz
├── test.bam
├── test_logging.log
└── trimmed.fastp.json
```

***scSPRITE_test_tmp*** is the root directory of the output, where ‘test’ is the name of the sample.

***Result*** is directory the main result saved in it.

***cool_folder*** is the directory stores all cells’ cool files before and after **KR** correction.

***mcool _folder*** is the ****directory stores all cells’ mcool files.

***SCpair*** is the directory stores all cells’ pair files.

***test.bam*** is the bam file of the sequencing data.

***test_logging.log*** records all the parameters of processing the data by STARK, as well as the time spent on each step.

***trimmed.fastp.json*** records the result of fastp processing the data.
