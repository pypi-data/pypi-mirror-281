{% set left = "{{" -%}
use axum::extract::State;
use crate::config::SETTINGS;
use crate::{entities};
use crate::utils::state;

#[macro_export]
macro_rules! func_name {
    () => {{ left }}
        fn f() {}
        fn type_name_of<T>(_: T) -> &'static str {
            std::any::type_name::<T>()
        }
        let arr :Vec<&str>= type_name_of(f).split("::").collect();
        arr[arr.len() - 3]
    }};
}
pub struct MongoLogger {
    pub project: String,
    pub app: String,
}

impl MongoLogger {
    pub fn new(project: &str, app: &str) -> Self {
        Self {
            project: project.to_string(),
            app: app.to_string(),
        }
    }

    pub async fn log(&self, log: &str, user: i64, state: State<state::AppState>, func: &str, level: &str) {
        let mongo = state.mongo.lock().await;
        let db = mongo.database(SETTINGS.mongo.name.as_str());
        let collection = db.collection("log_record");
        let payload = entities::log::NewLogRecord {
            app: self.app.clone(),
            func: func.to_string(),
            log: log.to_string(),
            project: self.project.clone(),
            user,
            level: level.to_string(),
            created: bson::DateTime::now(),
        };
        collection.insert_one(payload, None).await.unwrap();
    }

    pub async fn info(&self, log: &str, user: i64, state: State<state::AppState>, func: &str) {
        self.log(log, user, state, func, "info").await
    }

    pub async fn warning(&self, log: &str, user: i64, state: State<state::AppState>, func: &str) {
        self.log(log, user, state, func, "warning").await
    }

    pub async fn error(&self, log: &str, user: i64, state: State<state::AppState>, func: &str) {
        self.log(log, user, state, func, "error").await
    }

    pub async fn debug(&self, log: &str, user: i64, state: State<state::AppState>, func: &str) {
        self.log(log, user, state, func, "debug").await
    }
}