"""Logic to create FTU graphs"""
import numpy as np
import networkx as nx
import copy
from scipy.spatial import Delaunay

from ftuutils.compositionutils import SymbolicPHS,Composer

#Generic FTU graph methods
class FTUGraph():
    """ Base class for creating FTU graphs. A networkx graph is used to build the FTU
    """
    def __init__(self) -> None:
        self.num_active_cells = 0  
        self.celltypes = dict()

    @staticmethod
    def setEdgeWeight(G,edid,networkid,weight):
        """Set the edge weight for a given network

        Args:
            G (networkx Graph): graph instance on which the assignment needs to be made
            edid tuple(int,int): id of the edge (src node id,target node id)
            networkid (int): id of the network to which the weight belongs
            weight (float): Weight assigned for that network on the edge
        """
        nw = {networkid:weight}
        G[edid[0]][edid[1]]['weight'].update(nw)
            
    def setCellType(self,ctypes):
        """
            Update cell types for nodes
        Args:
            #G (nx.Graph): graph that needs to be updated
            ctypes (Dict): node id -> cell type map
        """
        self.celltypes.update(ctypes)

    @staticmethod
    def computeLaplacian(G,nid) -> np.array:
        """
        Create the weighted laplacian matrix for the given graph G
        Graph G should have the edge weights apriori 
        Args:
            G (nx.Graph): Networkx graph generated by this class with identical rows and cols
            nid (int)   : The network for which the laplacian needs to be generated
        Returns:
            np.array: Weighted laplacian of the graph
        """
        gp = nx.Graph()

        for ed in G.edges.data():
            if nid in ed[2]:
                gp.add_edge(ed[0],ed[1],weight=ed[2][nid])
        #Remove the boundary nodes else dimension mismatch will happen        
        na = nx.get_node_attributes(G,'type')
        interiorNodes = []
        for k,v in na.items():
            if v=='in':
                interiorNodes.append(k)
        Lx = nx.laplacian_matrix(gp,interiorNodes).toarray()

        return Lx

    @staticmethod
    def getUComponentLinkages(node,u,usplit,noden,y,ysplit,networkdata,compositionErrors):
        """Determine the input linkages between node and noden

        Args:
            node (int): Source node
            u (array): U component vector
            usplit (array): array that assigns the network for each component vector
            noden (int): Target node
            y (array): Y component vector
            ysplit (array): array that assigns the network for each component vector
            networkdata (dict): data about the network i.e weights etc
            compositionErrors (dict): dictionary of issues identified while find the linkages

        Returns:
            dict,bool: Resulting match information, True if successful
        """
        
        #Check if network ids match
        #If there is more than one match, go with name match
        match = {}
        for s, srcu in enumerate(u):
            if srcu.startswith('0') and float(srcu)==0.0:
                continue
            srcn = usplit[s]
            dissipativeType = False
            if srcn not in networkdata:
                raise ("Network data for network "+srcn+" not found!!")
            
            if('isdissipative' in networkdata[srcn]):
                dissipativeType = networkdata[srcn]['isdissipative']
            
            ncount = 0
            for k,srcn in enumerate(ysplit):
                if(srcn==ysplit[k]):
                    ncount +=1

            if ncount>1:
                #match by name
                ncount = 0
                for k in range(len(ysplit)):
                    if(y[k]==srcu):
                        ncount=1
                        if(srcu in match):
                            match[srcu].append({'name':y[k],'sindx':s,'tidx':k,'dissipative':dissipativeType,'source':int(node),'target':int(noden)})
                        else:
                            match[srcu] = [{'name':y[k],'sindx':s,'tidx':k,'dissipative':dissipativeType,'source':int(node),'target':int(noden)}]

                #No match found - report error
                if (ncount==0):
                    if(node in compositionErrors):
                        compositionErrors[node]["missinglinks"].append(srcu)
                    else:
                        compositionErrors[node] = {"missinglinks":[srcu]}
            else:
                if(srcu in match):
                    match[srcu].append({'name':y[ysplit.index(srcn)],'sindx':s,'tidx':ysplit.index(srcn),'dissipative':dissipativeType,'source':int(node),'target':int(noden)})
                else:
                    match[srcu] = [{'name':y[ysplit.index(srcn)],'sindx':s,'tidx':ysplit.index(srcn),'dissipative':dissipativeType,'source':int(node),'target':int(noden)}]

        return match,compositionErrors
    
    @staticmethod
    def generateCompositionIntermediates(G,phsdefinitions,networkdata):
        """Private method to generate intermediate datastructures to help with 
           generating symbolic and pythonic codes of the FTU
        Args:
            G (networkx.Graph): Source graph
            phsdefinitions (dict): PHS definitions
            networkdata (dict): Network descriptions

        Returns:
            tuple: compositionErrors,nodeComponentBcapdash,Cmatrix
        """
        nds = list(G.nodes())
        #Handle multigraph with multiple non-numeric attributes
        adj = nx.adjacency_matrix(G,weight=None)
        nodeAttrib = nx.get_node_attributes(G,'phs')
        nodeTypeAttrib = nx.get_node_attributes(G,'type')
        existingEdges = dict()
        for e in G.edges.data():
            exi = f"{e[0]}->{e[1]}"
            if exi in existingEdges:
                continue
            existingEdges[exi] = e[2]
        networkTypes = {}
        networkNames = {}
        for k,v in networkdata.items():
            networkNames[k] = v["name"]
            networkTypes[v["name"]] = v["type"]
        
        nodeOrder = {} #Order in which nodes are visited and u vector is created
        nodeComponentBcapdash = {}
        Cmatrix = {}
        ucap = [] #Ucap vector
        ucapmap = {}
        ui = 0
        nodeitems = {}
        compositionErrors = {}

        numberOfInteriorNodes = 0
        #Create Ucap
        for n in nds:
            ni = f"{n}"
            nType = nodeTypeAttrib[n]
            if nType=='in':
                nphs  = nodeAttrib[n]
                nodeOrder[ni] = n
                phsx = phsdefinitions[nphs]
                unames = phsx['portHamiltonianMatrices']["u"]["elements"]
                    
                nodeitems[n] = [phsx,ui,unames]
                for un,nm in enumerate(unames):
                    nn = f"{ui}"
                    ui += 1
                    ucap.append(nn)
                    ucapmap[nn] = [n,un,nm]
                numberOfInteriorNodes +=1

        for ni,n in enumerate(nds):
            #Get the list of connected nodes from adjacency matrix - using sparse api as nx numpy and pyodide scipy versions may be different
            #Get the indices
            adjM = np.asarray(nds)[np.nonzero(adj[[ni]].toarray().flatten())]
            node = None
            phs = None
            ui = None
            unames = None
            noden = None
            phsn = None
            unamesn = None

            if n in nodeitems:
                node = n
                phs = nodeitems[n][0]
                ui = nodeitems[n][1]
                unames = nodeitems[n][2]
            
                mysplit = phs['portHamiltonianMatrices']['u_split']
                #For B Split we only need to know if the component is connected to or not
                #For C matrix we need to ensure the matching and that will take care of the component number permutation
                bsplit = [] # Record of components that are interior (False) or boundary (True) due to no network connection
                bsplitNode = []
                bbarcontrib = [] #Record if there is boundary contribution as well - node connected to both interior and boundary nodes
                bbarcontribNode = []
                bcapcontrib = []
                bdryNodes = []
                for ux in unames:
                    bsplit.append(False)
                    bbarcontrib.append(False)
                    bcapcontrib.append(False)
                    bsplitNode.append(None)
                    bbarcontribNode.append(None)
                
                mch = {}
                for v in range(adjM.shape[0]):
                    neigh = adjM[v] #Get the node indices not the degrees
                    if neigh==n:
                        continue
                    if neigh in nodeitems:
                        noden  = neigh 
                        phsn   = nodeitems[neigh][0]
                        uin    = nodeitems[neigh][1]
                        unamesn= nodeitems[neigh][2]
                        split = phsn['portHamiltonianMatrices']['u_split']
                        for s,ms in enumerate(mysplit['elements']):
                            if ms is None:
                                bsplit[s] = True
                            elif (split['elements'].index(ms)<0): #If network not found, split it
                                bsplit[s] = True
                            else:
                                if networkTypes[networkNames[ms]]=='generic':
                                    #For internal networks
                                    #If boundary node was encountered before a interior node
                                    #reset
                                    if bsplit[s]:
                                        bsplit[s] = False
                                        bbarcontrib[s] = True
                                    bcapcontrib[s] = True
                                else: #For boundary networks, split
                                    bsplit[s] = True
                                    bbarcontrib[s] = False
                                    bcapcontrib[s] = False
                            
                                
                        #Pass node for recording missing linkages, networkdata to determine if a network is dissipative or not
                        mm,compositionErrors = FTUGraph.getUComponentLinkages(node,unames,mysplit['elements'],noden,unamesn,split['elements'],networkdata,compositionErrors)

                        for c,res in mm.items():
                            if(c in mch):
                                mch[c].extend(res)
                            else:
                                mch[c] = res
                
                for v in range(adjM.shape[0]):
                    neigh = adjM[v] #Get the node indices not the degrees
                    if neigh==n:
                        continue
                    if neigh not in nodeitems: #boundary node
                        nodeData = numberOfInteriorNodes-neigh #JS uses +ve node numbers
                        bdryNodes.append(nodeData)
                        #Get the edge
                        medge = None
                        nedges = nx.edges(G,neigh)
                        for ed in nedges:
                            if ed[0]==n or ed[1] ==n:
                                medge = ed
                                break
                        #For each network defined on the edge
                        #resolve the inputs if they are defined
                        if medge!=None:
                            mid = f"{medge[0]}->{medge[1]}"
                            if mid in existingEdges:
                                nets = existingEdges[mid]
                            elif f"{medge[1]}->{medge[0]}" in existingEdges:
                                nets = existingEdges[f"{medge[1]}->{medge[0]}"]
                            else:
                                raise(f"{medge} does not exist!!")
                            #Parse only boundary edges - negative ids
                            for kx in nets:
                                #Use network type information
                                k = int(f"{kx}") #Handle json string keys
                                if networkTypes[networkNames[k]]=='boundary':
                                    netdata = networkdata[k]
                                    if 'input' in netdata:
                                        dissipativeType = netdata['isdissipative']
                                        #Which phsclass and what components are provided through this network
                                        phsclass = phsdefinitions[netdata['input']['phsclass']]
                                        unamesx = phsclass['portHamiltonianMatrices']["u"]["elements"]
                                        defcomps = netdata['input']['components']
                                        tix = 0
                                        for v in range(len(unamesx)):
                                            if defcomps[v]:
                                                #Match with name of interior node - ideally they should belong to the same phs class
                                                ix = unames.index(unamesx[v])
                                                if ix>-1:
                                                    if unamesx[v] in mch:
                                                        mch[unamesx[v]].append({'name':unamesx[v],'sindx':ix,'tidx':tix,'dissipative':dissipativeType,'source':n,'target':int(nodeData)})  
                                                    else:
                                                        mch[unamesx[v]] = [{'name':unamesx[v],'sindx':ix,'tidx':tix,'dissipative':dissipativeType,'source':n,'target':int(nodeData)}]
                                                    
                                                    tix +=1
                                                    
                                                    if bcapcontrib[ix]==False: #If there is not bcap contribution then split
                                                        bsplit[ix] = True
                                                        bsplitNode[ix] = int(nodeData)
                                                        bbarcontrib[ix] = False
                                                    else: #Add through bbarcontribution
                                                        bbarcontrib[ix] = True
                                                        bbarcontribNode[ix] = int(nodeData)


                        #If there is a flag to use boundary instead of interior 
                        #force split
                        if 'u_connect2boundary' in phs['portHamiltonianMatrices']:
                            ucon = phs['portHamiltonianMatrices']['u_connect2boundary']['elements']
                            for ux in range(len(unames)):
                                if ucon[ux]:
                                    if bcapcontrib[ux] == False:  #If there is not bcap contribution then split
                                        bsplit[ux] = True
                                        bsplitNode[ux] = int(nodeData)
                                        bbarcontrib[ux] = False
                                    else: #Add through bbarcontribution
                                        bbarcontrib[ux] = True
                                        bbarcontribNode[ux] = int(nodeData)
                bns = list(map(int,set(bdryNodes)))
                #bsplit - for True components input is coming from outside
                #bbarcontrib - for True components, there is also an input coming from outside.. there is internal nodes that are contributing as well
                nodeComponentBcapdash[n] = {'bsplit':bsplit,'bsplitNode':bsplitNode,'bbarcontrib':bbarcontrib,'bbarcontribNodes':bbarcontribNode,'boundary': bns}
                Cmatrix[n] = mch       
        return  compositionErrors,nodeComponentBcapdash,Cmatrix

    def resolve(self,G,phsdefinitions,phsdata,generateCompositionJSON=True):
        """Construct the FTU given the network, port hamiltonians and other phsdata

        Args:
            G (networkx.Graph): Graph description of FTU, nodes, edges, networks and phs assignments
            phsdefinitions (dict): Definitions of phs classes used by the FTU
            phsdata (dict): Data related to network connections applied on phs
            generateCompositionJSON (bool, optional): Generate the composite JSON. Defaults to True.

        Returns:
            bool,dict: True if a FTU was successfully constructed, FTU project as python dict        """
        nodeAttrib = nx.get_node_attributes(G,'phs')
        nodeType = nx.get_node_attributes(G,'type')
        unresolved = False
        networks = dict()
        existingNets = dict()
        boundaryNet = -1
        errorMessage = ''        

        if len(phsdefinitions)==0:
            raise Exception("PHS class(es) data not provided")
           
        if "connections" not in phsdata:
            raise Exception("Connection between PHS class(es) not provided")
                    
        phsconnections = phsdata["connections"] if "connections" in phsdata else {}
        phsBdryconnections = phsdata["bdryconnections"] if "bdryconnections" in phsdata else {}
        externalInputs = phsdata["externalinputs"] if "externalinputs" in phsdata else {}
        networkNames = phsdata["networkNames"] if "networkNames" in phsdata else {}
        networkTypes = {}
        
        networkDissipation = phsdata["networkDissipation"]  if "networkDissipation" in phsdata else {}

        #Load phs definitions
        for ph,phs in phsdefinitions.items():
            if 'u_split' not in phs['portHamiltonianMatrices']:
                ups = phs['portHamiltonianMatrices']['u']['elements']
                usp = []
                for x in range(len(ups)):
                    usp.append(None)
                if ph in phsconnections:
                    phc = phsconnections[ph]
                    for k,v in phc.items():
                        x = ups.index(k) if k in ups else -1
                        if x>-1:
                            usp[x] = v
                if ph in phsBdryconnections:
                    phc = phsBdryconnections[ph]
                    for k,v in phc.items():
                        x = ups.index(k) if k in ups else -1
                        if x>-1:
                            usp[x] = v
                missing = []
                for i,x in enumerate(usp):
                    if x is None and ups[i].startswith('0') and float(ups[i])!=0.0:
                        missing.append(ups[i])
                if len(missing)>0:
                    errorMessage = f'PHS {ph} is missing connections for {",".join(missing)}'
                    unresolved = True
                    
                if unresolved:
                    break
                phs['portHamiltonianMatrices']['u_split'] = copy.deepcopy(phs['portHamiltonianMatrices']['u'])
                phs['portHamiltonianMatrices']['u_split']['elements'] = usp
                phsdefinitions[ph] = phs
        curNodes = list(G.nodes())
        
        if not unresolved:
            for nd in curNodes:
                if nodeType[nd] == 'out':
                    raise Exception(f"Unexpected workflow, boundary node up for resolution")
                #Get phstype and component connection information
                if nodeAttrib[nd] not in phsdefinitions:
                    unresolved = True
                    errorMessage = f'{nodeAttrib[nd]} does not have phs assigned or not defined'
                    break
                if nodeAttrib[nd] not in phsconnections:
                    if nodeAttrib[nd] not in phsBdryconnections:
                        errorMessage = f'{nodeAttrib[nd]} has no connections defined'
                        unresolved = True
                        break
                #get the list of input components
                phs1 = phsdefinitions[nodeAttrib[nd]]
                ucomp1 = phs1['portHamiltonianMatrices']['u']['elements']
                complete = True
                if nodeAttrib[nd] in phsconnections:
                    icons = phsconnections[nodeAttrib[nd]]        #internal connections
                ibcons = []
                if nodeAttrib[nd] in phsBdryconnections:
                    ibcons = phsBdryconnections[nodeAttrib[nd]]   #boundary connections

                for u in ucomp1:
                    if u.startswith('0') and float(u)==0.0:
                        continue
                    if u not in icons:
                        if u not in ibcons:
                            errorMessage = f'{nodeAttrib[nd]}  not found on connections or boundary connections'
                            complete = False
                            break
                        connvalue = ibcons[u] # value
                        #boundary network
                        bid = int(connvalue)
                        networkTypes[networkNames[connvalue]] = 'boundary'
                        if bid > 0:
                            bid = -bid
                        if boundaryNet>= bid:
                            boundaryNet = bid -1
                        networkname = f"network@{nodeAttrib[nd]}@{u}@{networkNames[connvalue]}"                        
                        #Use unique node for a boundary net
                        if networkname not in networks:                        
                            networks[networkname] = bid
                            pos = self.getPositionFromIndex(len(G.nodes())+1)
                            G.add_node(bid,type='out',value=connvalue,pos=pos)

                        connectNode = networks[networkname]
                        if f'{nd}_{connectNode}_{networkname}' not in existingNets:
                            G.add_edges_from([(nd,connectNode,{networks[networkname]:1.0})])                
                            existingNets[f'{nd}_{connectNode}_{networkname}'] = True
                    else:
                        #Check if component exists
                        conn = icons[u] # comp
                        networkname = f"network@{nodeAttrib[nd]}@{u}@{networkNames[conn]}"
                        if networkname not in networks:
                            networks[networkname] = conn
                            networkTypes[networkNames[conn]] = 'generic' #icons - internal connections

                if not complete:
                    unresolved = True
                    break

        if unresolved:
            raise Exception(errorMessage)

        if len(externalInputs)==0 and len(phsBdryconnections)==0:
            raise Exception("System does not have any external inputs and boundary conditions!!")

        for nd,vs in externalInputs.items():
            for v in vs:
                conn = v[1]               
                networkname = f"network@{nodeAttrib[nd]}@{v[0]}@{networkNames[conn]}"
                #Double check for clashes
                if networkNames[conn] in networkTypes and networkTypes[networkNames[conn]] != 'boundary':
                    errorMessage += f"{networkNames[conn]} has conflicting network type assignment - at node {nd}, connection {conn}"
                    unresolved = True
                    break
                
                networkTypes[networkNames[conn]] = 'boundary'
                #Use unique node for a boundary net
                if networkname not in networks:                        
                    networks[networkname] = conn
                    pos = self.getPositionFromIndex(len(G.nodes())+1)
                    G.add_node(conn,type='out',value=conn,pos=pos)

                connectNode = networks[networkname]
                if f'{nd}_{connectNode}_{networkname}' not in existingNets:
                    G.add_edges_from([(nd,connectNode,{networks[networkname]:1.0})])                
                    existingNets[f'{nd}_{connectNode}_{networkname}'] = True
            if unresolved:
                break
        if unresolved:
            raise Exception(errorMessage)
                    
        if len(externalInputs)==0:
            raise Exception("System does not have any external inputs!!")
        
        result = dict()
        if generateCompositionJSON and not unresolved:
            networkdata = dict()
            networkNames = phsdata["networkNames"]
            for k,v in networks.items():
                nname = f"Network {v}"
                if v<0:
                    nname = f"Bdry Net {-v}"
                if v in networkNames:
                    nname = networkNames[v]
                    
                #k - network@{phs1}@{component1}@{netid}
                info = k.split('@')
                ucomp = phsdefinitions[info[1]]['portHamiltonianMatrices']['u']['elements']
                nus = []
                for u in ucomp:
                    nus.append(u==info[2])
                if v in networkDissipation:
                    networkdata[v] = {'name': nname, 'type':networkTypes[nname], 'isdissipative':networkDissipation[v],'input':{'phsclass':info[1],'components':nus}}
                else:
                    networkdata[v] = {'name': nname, 'type':networkTypes[nname], 'isdissipative':False,'input':{'phsclass':info[1],'components':nus}}

            rstyle = {
                'shape': 'rectangle',
                'fillColor': "rgb(195, 217, 255)",
                'strokeColor': 'transparent',
                'fontSize': 8,
                'fontStyle': 1,
                'fontColor': 'black',
                'resizable': 0
            }
            bstyle = {
                'shape': 'ellipse',
                'fillColor': "rgb(217, 195, 255)",
                'strokeColor': 'transparent',
                'fontSize': 8,
                'fontStyle': 1,
                'fontColor': 'black',
                'resizable': 0
            }
            nodegeometry = {
                "_x": 100,
                "_y": 50,
                "_width": 15,
                "_height": 15,
                "TRANSLATE_CONTROL_POINTS": True,
                "alternateBounds": None,
                "sourcePoint": None,
                "targetPoint": None,
                "points": None,
                "offset": None,
                "relative": False            
            }
            edgegeometry = {
                        "_x": 0,
                        "_y": 0,
                        "_width": 0,
                        "_height": 0,
                        "TRANSLATE_CONTROL_POINTS": True,
                        "alternateBounds": None,
                        "sourcePoint": None,
                        "targetPoint": None,
                        "points": None,
                        "offset": {
                        "_x": 5,
                        "_y": 0
                        },
                        "relative": True,
            }
            
            phscolors = dict()
            for ph in phsdefinitions:
                phscolors[ph] = f"rgb({','.join(map(str,list(np.random.choice(range(256), size=3))))})"
            phscolors[''] = "rgb(217, 195, 255)"
            
            currentNodeOffset = 0

            nodeAttrib = nx.get_node_attributes(G,'phs')
            nodeTypeAttrib = nx.get_node_attributes(G,'type')
            nodePosAttrib = nx.get_node_attributes(G,'pos')            
            gnodes = []
            gedges = []
            nodeId = dict()
            for i,n in enumerate(G.nodes()):
                nodeobj = dict()
                nodeId[n] = i + 1
                nodeobj["id"] = i + 1
                myphs = ''
                if n in nodeAttrib:
                    myphs = nodeAttrib[n]
                mytype= nodeTypeAttrib[n]
                mypos = nodePosAttrib[n]
                mystyle = copy.deepcopy(rstyle)
                if mytype=="out":
                    mystyle = copy.deepcopy(bstyle)
                mystyle["fillColor"] = phscolors[myphs]
                geometry = copy.deepcopy(nodegeometry)
                geometry["_x"] = 50+mypos[0]*50
                geometry["_y"] = 50+mypos[1]*50
                nodeobj['style'] = mystyle
                nodeobj['geometry'] = geometry
                id = n
                if id<0:
                    id = len(curNodes) - n
                    nodeId[n] = id
                    nodeobj["id"] = id
                if currentNodeOffset < id:
                    currentNodeOffset +=1
                if myphs != '':
                    nodeobj['value'] = {"label":id,"type":mytype,"phs":myphs}
                else:
                    nodeobj['value'] = {"label":id,"type":mytype}
                gnodes.append(nodeobj)
            
            existingEdges = dict()
            for e in G.edges.data():
                exi = f"{e[0]}->{e[1]}"
                if exi in existingEdges:
                    continue
                existingEdges[exi] = e[2]
                edgeobj = dict()
                edgeobj["id"]   = exi

                edgeobj["style"] = {"fontColor": "red",
                                    "fontSize": 6,
                                    "sourcePort": None,
                                    "targetPort": None
                                    }
                edgeobj["geometry"] = copy.deepcopy(edgegeometry)
                edgeobj["source"] = nodeId[e[0]]
                edgeobj["target"] = nodeId[e[1]]
                if nodeTypeAttrib[e[0]]=="in" and nodeTypeAttrib[e[1]]=="in":
                    edgeobj["value"] = {"label":len(existingEdges), "weight":e[2],'type':'in'}
                else: #Else a boundary edge
                    edgeobj["value"] = {"label": (len(existingEdges)), "weight":e[2],'type':'out'}
                    edgeobj["style"]['strokeColor'] = 'red'
                gedges.append(edgeobj)
                
            result["graph"] = {"nodes":gnodes,"edges":gedges}
            phsdata  = dict()
            for ph,phs in phsdefinitions.items():
                #The phs entry could have the source bg, in this case only the phs is available, so create two phs trees
                phsdata[ph] = {"phs":{"phs":phs},'color':phscolors[ph]}
            result["phsdata"] = phsdata
            result["networkdata"] = {}
            #Network data is stringified to match javascript generation
            for k,v in networkdata.items():
                result["networkdata"][k] = v #json.dumps(v)
            result['currentNodeOffset'] = currentNodeOffset
            result['edgeCounter'] = len(G.edges())+1
            result['boundaryNetworkID'] = boundaryNet
            result['usedOffsets'] = [self.row_size*50+50,self.col_size*50+50]
            result['showEdgeLabels'] = True
            result['Provenance'] = {"projectname":'Python API generated','projectAuthor':'API'}
        
            #Composite PHS input
            compositionErrors,nodeComponentBcapdash,Cmatrix = FTUGraph.generateCompositionIntermediates(G,phsdefinitions,networkdata)
            newresult = {}
            newresult['graph'] = result
            newresult['composition'] ={'Bcap':nodeComponentBcapdash,'C':Cmatrix}
            result = newresult
            if len(errorMessage) > 0:
                result['error':errorMessage]
                
        return (not unresolved),result

    def composeCompositePHS(self,G,phsdefinitions=None,phsdata=None,substituteParameters=True):
        """Method to generate composite PHS from 

        Args:
            G (networkx Graph or dict): FTU graph (networkx.Graph) or Dict description
            phsdefinitions (dict): Description of phs classes used in the FTU required if G is not dict
            phsdata (dict): Data about networks, external inputs etc used in the FTU required if G is not dict
            substituteParameters (bool): Substitute phs parameters and simplify before composition, phs parameters are eliminated. Default True
        """
        composition = None
        ftuGraph = None
        if type(G) is dict:
            composition = G
        else:
            ftuGraph = G
            res,composition = self.resolve(G,phsdefinitions,phsdata,True)
            
            if not res:
                raise Exception(f"FTU could not be resolved! Error with FTU description.\nMessage\n{composition['error']} ")

        composer = Composer()
        composer.loadComposition(composition)
        composer.compose(substituteParameters)        
        if ftuGraph is not None:
            composer.setConnectivityGraph(ftuGraph)                
        return composer

    def composeCompositePHSFromGraphicalObject(self,comp_):
        """Generates the composite PHS from a python dictionary input of graph, phsdata and connection information

        Args:
            comp (dict): PHS composition description
        """
        #Reconstruct network, phsdata, phsconnections
        comp = comp_ #Handle javascript json (with just graph) and python generated json (which has graph->graph)
        if "graph" not in comp["graph"]:
            comp = dict()
            comp["graph"] = comp_
        G = nx.MultiGraph()
        boundaryNodes = dict()
        nodePHSData = dict()
        gnodes = comp["graph"]["graph"]["nodes"]
        for n in gnodes:
            G.add_node(int(n["value"]['label']),**n["value"])
            nodePHSData[int(n["value"]['label'])] = n["value"]
            if n["value"]["type"]=="out":
                boundaryNodes[int(n["value"]['label'])] = {"node":n}
                
        for e in comp["graph"]["graph"]["edges"]:
            G.add_edge(e['source'],e['target'],**e["value"]["weight"])
            if e['source'] in boundaryNodes:
                boundaryNodes[e['source']]["edge"] = e["value"]
                boundaryNodes[e['source']]["other"] = e['target'] #There could be more than one linked node
            if e['target'] in boundaryNodes:
                boundaryNodes[e['target']]["edge"] = e["value"]            
                boundaryNodes[e['target']]["other"] = e['source'] #There could be more than one linked node
      
        phsdefinitions = {} #Remove phs chaining
        for k,v in comp["graph"]["phsdata"].items():
            defn = v
            while 'phs' in defn:
                defn = defn['phs']
            phsdefinitions[k] = defn
            
        networkdata = comp["graph"]["networkdata"]
        #set the keys to be integers
        ndata = dict()
        for k,v in networkdata.items():
            ndata[int(k)] = v
                
        comp["graph"]["networkdata"] = ndata            
        compositionErrors,nodeComponentBcapdash,Cmatrix = FTUGraph.generateCompositionIntermediates(G,phsdefinitions,ndata)
        composition = comp

        composition["graph"]["phsdata"] = comp["graph"]["phsdata"]
        composition["composition"] = dict()
        composition["composition"]['Bcap'] = nodeComponentBcapdash
        composer = self.composeCompositePHS(composition)
        composer.setConnectivityGraph(G)
        composition["composition"]['compositePHS'] = SymbolicPHS.savePHSDefinition(composer.compositePHS)
        return composer,composition
    
    def getGraph(self):
        raise Exception("not implemented!")
        
class FTUDelaunayGraph(FTUGraph):
    """
        Create a FTU graph based on Delaunay triangulation
    """    
    def __init__(self,points,defaultPHS,conductivityTensor,edgeLengththeshold=1.5,defaultnet=1) -> None:
        super().__init__()
        self.points = points
        self.row_size = self.points.shape[0]
        self.col_size = 1
        self.defaultPHS = defaultPHS
        self.edgeLengthThreshold = edgeLengththeshold
        self.conductivityTensor =conductivityTensor
        self.defaultNetworkID = defaultnet
        x_, y_, z_ = zip(*points)
        self.bounds = [(np.min(x_), np.min(y_), np.min(z_)), (np.max(x_), np.max(y_), np.max(z_))]
        tri = Delaunay(points)
        #Create the graph
        G = nx.Graph()
        #Composition expects node id to start from 1
        G.add_nodes_from(range(1,points.shape[0]+1)) #Create nodes in sorted order, add_path will created nodes in the order of first appearance
        for tr in tri.simplices:
            nx.add_path(G, tr+1)

        #Provide position, PHS/CellType and interior/exterior node attributes
        pdict = dict()
        celltype = dict()
        nodetype = dict()

        for i,p in enumerate(points):
            pdict[i+1] = p
            celltype[i+1] = self.defaultPHS
            nodetype[i+1] = "in"
        nx.set_node_attributes(G, pdict,"pos")
        nx.set_node_attributes(G, celltype,"phs")
        nx.set_node_attributes(G, nodetype,"type")

        eweight = dict()

        #Check edge lengths
        edge_len = np.array([np.linalg.norm(pdict[u]-pdict[v]) for u, v in G.edges()])
        ecutoff = np.mean(edge_len)*self.edgeLengthThreshold
        if np.issubdtype(conductivityTensor.dtype,np.number):
            for i,e in enumerate(G.edges()):
                if edge_len[i]>ecutoff:
                    G.remove_edge(e[0],e[1])    
                else:
                    evec = (pdict[e[1]] - pdict[e[0]])
                    wt = np.abs(conductivityTensor.dot(evec)) #Weight should be positive - projection can be negative due to direction
                    eweight[e] = wt/edge_len[i] #normalize by edge length
        else:#String or sympy
            for i,e in enumerate(G.edges()):
                if edge_len[i]>ecutoff:
                    G.remove_edge(e[0],e[1])    
                else:
                    evec = (pdict[e[1]] - pdict[e[0]])/edge_len[i]
                    wt = []
                    for j,x in enumerate(conductivityTensor):
                        if evec[j] != 0.0:
                            wt.append(f"{evec[j]/edge_len[i]}*"+x)
                    #Weight should be positive - projection can be negative due to direction
                    eweight[e] = "abs("+"+".join(wt)+")" #normalize by edge length
            
                            
        nx.set_edge_attributes(G,eweight,self.getDefaultNetworkID())
        
        self.graph = G

    def getDefaultNetworkID(self):
        """Get the default network ID, the one assigned to the FTU network by default

        Returns:
            int: Network ID
        """
        return self.defaultNetworkID

    def getGraph(self):
        """Get the working graph

        Returns:
            networkx.Graph: FTU graph
        """
        return self.graph
    
    def getPoints(self):
        """Get the coordinate points used to create the FTU graph

        Returns:
            numpy.array: Array of points
        """
        return self.points

    def getPositionFromIndex(self,idx):
        """Get a position for given index
           If idx corresponds to a point, then its coordinate is returned
           else a random coordinate value within the coordinate bounds is returned
        Args:
            idx (int): Index of point whose coordinate value is required

        Returns:
            numpy.array: Coordinate value
        """
        if idx <= self.points.shape[0] and idx > 0:
            return self.points[idx-1]
        else:
            #return a random point with in the points bound
            return np.array([np.random.uniform(self.bounds[0][0],self.bounds[1][0]),
                             np.random.uniform(self.bounds[0][1],self.bounds[1][1]),
                             np.random.uniform(self.bounds[0][2],self.bounds[1][2])])

        