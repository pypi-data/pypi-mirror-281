# coding: utf-8

"""
    Glean Client API

    # Introduction These are the public APIs to enable implementing a custom client interface to the Glean system.  # Usage guidelines This API is evolving fast. Glean will provide advance notice of any planned backwards incompatible changes along with a 6-month sunset period for anything that requires developers to adopt the new versions.  # SDK Client bindings for the API can be generated for most popular languages (Python, Java, NodeJS, etc). To do so:  Download the OpenAPI specification for the API, by clicking on one of the following options: 1. [Download JSON specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.json?branch=main&download=true) 2. [Download YAML specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.yaml?branch=main&download=true)  Use [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli) to generate bindings for your language of choice, for example: ```bash shell $ npx @openapitools/openapi-generator-cli@latest generate -i client_api.yaml -g go ```  To see available languages: ```bash shell $ npx @openapitools/openapi-generator-cli@latest list ```  Determine the host you need to connect to. This will be the URL of the backend for your Glean deployment, for example, customer-be.glean.com 

    The version of the OpenAPI document: 0.9.0
    Contact: support@glean.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from glean_client_api.models.anonymous_event import AnonymousEvent
from glean_client_api.models.badge import Badge
from glean_client_api.models.datasource_profile import DatasourceProfile
from glean_client_api.models.permissions import Permissions
from glean_client_api.models.person_distance import PersonDistance
from glean_client_api.models.person_team import PersonTeam
from glean_client_api.models.social_network import SocialNetwork
from glean_client_api.models.structured_location import StructuredLocation
from typing import Optional, Set
from typing_extensions import Self

class PersonMetadata(BaseModel):
    """
    PersonMetadata
    """ # noqa: E501
    type: Optional[StrictStr] = None
    first_name: Optional[StrictStr] = Field(default=None, description="The first name of the person", alias="firstName")
    last_name: Optional[StrictStr] = Field(default=None, description="The last name of the person", alias="lastName")
    title: Optional[StrictStr] = Field(default=None, description="Job title.")
    business_unit: Optional[StrictStr] = Field(default=None, description="Typically the highest level organizational unit; generally applies to bigger companies with multiple distinct businesses.", alias="businessUnit")
    department: Optional[StrictStr] = Field(default=None, description="An organizational unit where everyone has a similar task, e.g. `Engineering`.")
    teams: Optional[List[PersonTeam]] = Field(default=None, description="Info about the employee's team(s).")
    department_count: Optional[StrictInt] = Field(default=None, description="The number of people in this person's department.", alias="departmentCount")
    email: Optional[StrictStr] = Field(default=None, description="The user's primary email address")
    alias_emails: Optional[List[StrictStr]] = Field(default=None, description="Additional email addresses of this user beyond the primary, if any.", alias="aliasEmails")
    location: Optional[StrictStr] = Field(default=None, description="User facing string representing the person's location.")
    structured_location: Optional[StructuredLocation] = Field(default=None, alias="structuredLocation")
    external_profile_link: Optional[StrictStr] = Field(default=None, description="Link to a customer's internal profile page. This is set to '#' when no link is desired.", alias="externalProfileLink")
    manager: Optional[Person] = None
    management_chain: Optional[List[Person]] = Field(default=None, description="The chain of reporting in the company as far up as it goes. The last entry is this person's direct manager.", alias="managementChain")
    phone: Optional[StrictStr] = Field(default=None, description="Phone number as a number string.")
    photo_url: Optional[StrictStr] = Field(default=None, description="The URL of the person's avatar. Public, glean-authenticated and Base64 encoded data URLs are all valid (but not third-party-authenticated URLs).", alias="photoUrl")
    unedited_photo_url: Optional[StrictStr] = Field(default=None, description="The original photo URL of the person's avatar before any edits they made are applied", alias="uneditedPhotoUrl")
    banner_url: Optional[StrictStr] = Field(default=None, description="The URL of the person's banner photo.", alias="bannerUrl")
    reports: Optional[List[Person]] = None
    start_date: Optional[date] = Field(default=None, description="The date when the employee started.", alias="startDate")
    end_date: Optional[date] = Field(default=None, description="If a former employee, the last date of employment.", alias="endDate")
    bio: Optional[StrictStr] = Field(default=None, description="Short biography or mission statement of the employee.")
    pronoun: Optional[StrictStr] = Field(default=None, description="She/her, He/his or other pronoun.")
    org_size_count: Optional[StrictInt] = Field(default=None, description="The total recursive size of the people reporting to this person, or 1", alias="orgSizeCount")
    direct_reports_count: Optional[StrictInt] = Field(default=None, description="The total number of people who directly report to this person, or 0", alias="directReportsCount")
    preferred_name: Optional[StrictStr] = Field(default=None, description="The preferred name of the person, or a nickname.", alias="preferredName")
    social_network: Optional[List[SocialNetwork]] = Field(default=None, description="List of social network profiles.", alias="socialNetwork")
    datasource_profile: Optional[List[DatasourceProfile]] = Field(default=None, description="List of profiles this user has in different datasources / tools that they use.", alias="datasourceProfile")
    query_suggestions: Optional[QuerySuggestionList] = Field(default=None, alias="querySuggestions")
    people_distance: Optional[List[PersonDistance]] = Field(default=None, description="List of people and distances to those people from this person. Optionally with metadata.", alias="peopleDistance")
    invite_info: Optional[InviteInfo] = Field(default=None, alias="inviteInfo")
    is_signed_up: Optional[StrictBool] = Field(default=None, description="Whether the user has signed into Glean at least once.", alias="isSignedUp")
    last_extension_use: Optional[datetime] = Field(default=None, description="The last time the user has used the Glean extension in ISO 8601 format.", alias="lastExtensionUse")
    permissions: Optional[Permissions] = None
    custom_fields: Optional[List[CustomFieldData]] = Field(default=None, description="User customizable fields for additional people information.", alias="customFields")
    logging_id: Optional[StrictStr] = Field(default=None, description="The logging id of the person used in scrubbed logs, tracking GA metrics.", alias="loggingId")
    start_date_percentile: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Percentage of the company that started strictly after this person. Between [0,100).", alias="startDatePercentile")
    busy_events: Optional[List[AnonymousEvent]] = Field(default=None, description="Intervals of busy time for this person, along with the type of event they're busy with.", alias="busyEvents")
    profile_bool_settings: Optional[Dict[str, StrictBool]] = Field(default=None, description="flag settings to indicate user profile settings for certain items", alias="profileBoolSettings")
    badges: Optional[List[Badge]] = Field(default=None, description="The badges that a user has earned over their lifetime.")
    is_org_root: Optional[StrictBool] = Field(default=None, description="Whether this person is a \"root\" node in their organization's hierarchy.", alias="isOrgRoot")
    __properties: ClassVar[List[str]] = ["type", "firstName", "lastName", "title", "businessUnit", "department", "teams", "departmentCount", "email", "aliasEmails", "location", "structuredLocation", "externalProfileLink", "manager", "managementChain", "phone", "photoUrl", "uneditedPhotoUrl", "bannerUrl", "reports", "startDate", "endDate", "bio", "pronoun", "orgSizeCount", "directReportsCount", "preferredName", "socialNetwork", "datasourceProfile", "querySuggestions", "peopleDistance", "inviteInfo", "isSignedUp", "lastExtensionUse", "permissions", "customFields", "loggingId", "startDatePercentile", "busyEvents", "profileBoolSettings", "badges", "isOrgRoot"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FULL_TIME', 'CONTRACTOR', 'NON_EMPLOYEE', 'FORMER_EMPLOYEE']):
            raise ValueError("must be one of enum values ('FULL_TIME', 'CONTRACTOR', 'NON_EMPLOYEE', 'FORMER_EMPLOYEE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PersonMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in teams (list)
        _items = []
        if self.teams:
            for _item in self.teams:
                if _item:
                    _items.append(_item.to_dict())
            _dict['teams'] = _items
        # override the default output from pydantic by calling `to_dict()` of structured_location
        if self.structured_location:
            _dict['structuredLocation'] = self.structured_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manager
        if self.manager:
            _dict['manager'] = self.manager.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in management_chain (list)
        _items = []
        if self.management_chain:
            for _item in self.management_chain:
                if _item:
                    _items.append(_item.to_dict())
            _dict['managementChain'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in reports (list)
        _items = []
        if self.reports:
            for _item in self.reports:
                if _item:
                    _items.append(_item.to_dict())
            _dict['reports'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in social_network (list)
        _items = []
        if self.social_network:
            for _item in self.social_network:
                if _item:
                    _items.append(_item.to_dict())
            _dict['socialNetwork'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in datasource_profile (list)
        _items = []
        if self.datasource_profile:
            for _item in self.datasource_profile:
                if _item:
                    _items.append(_item.to_dict())
            _dict['datasourceProfile'] = _items
        # override the default output from pydantic by calling `to_dict()` of query_suggestions
        if self.query_suggestions:
            _dict['querySuggestions'] = self.query_suggestions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in people_distance (list)
        _items = []
        if self.people_distance:
            for _item in self.people_distance:
                if _item:
                    _items.append(_item.to_dict())
            _dict['peopleDistance'] = _items
        # override the default output from pydantic by calling `to_dict()` of invite_info
        if self.invite_info:
            _dict['inviteInfo'] = self.invite_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of permissions
        if self.permissions:
            _dict['permissions'] = self.permissions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_fields (list)
        _items = []
        if self.custom_fields:
            for _item in self.custom_fields:
                if _item:
                    _items.append(_item.to_dict())
            _dict['customFields'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in busy_events (list)
        _items = []
        if self.busy_events:
            for _item in self.busy_events:
                if _item:
                    _items.append(_item.to_dict())
            _dict['busyEvents'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in badges (list)
        _items = []
        if self.badges:
            for _item in self.badges:
                if _item:
                    _items.append(_item.to_dict())
            _dict['badges'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PersonMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "type": obj.get("type"),
            "firstName": obj.get("firstName"),
            "lastName": obj.get("lastName"),
            "title": obj.get("title"),
            "businessUnit": obj.get("businessUnit"),
            "department": obj.get("department"),
            "teams": [PersonTeam.from_dict(_item) for _item in obj["teams"]] if obj.get("teams") is not None else None,
            "departmentCount": obj.get("departmentCount"),
            "email": obj.get("email"),
            "aliasEmails": obj.get("aliasEmails"),
            "location": obj.get("location"),
            "structuredLocation": StructuredLocation.from_dict(obj["structuredLocation"]) if obj.get("structuredLocation") is not None else None,
            "externalProfileLink": obj.get("externalProfileLink"),
            "manager": Person.from_dict(obj["manager"]) if obj.get("manager") is not None else None,
            "managementChain": [Person.from_dict(_item) for _item in obj["managementChain"]] if obj.get("managementChain") is not None else None,
            "phone": obj.get("phone"),
            "photoUrl": obj.get("photoUrl"),
            "uneditedPhotoUrl": obj.get("uneditedPhotoUrl"),
            "bannerUrl": obj.get("bannerUrl"),
            "reports": [Person.from_dict(_item) for _item in obj["reports"]] if obj.get("reports") is not None else None,
            "startDate": obj.get("startDate"),
            "endDate": obj.get("endDate"),
            "bio": obj.get("bio"),
            "pronoun": obj.get("pronoun"),
            "orgSizeCount": obj.get("orgSizeCount"),
            "directReportsCount": obj.get("directReportsCount"),
            "preferredName": obj.get("preferredName"),
            "socialNetwork": [SocialNetwork.from_dict(_item) for _item in obj["socialNetwork"]] if obj.get("socialNetwork") is not None else None,
            "datasourceProfile": [DatasourceProfile.from_dict(_item) for _item in obj["datasourceProfile"]] if obj.get("datasourceProfile") is not None else None,
            "querySuggestions": QuerySuggestionList.from_dict(obj["querySuggestions"]) if obj.get("querySuggestions") is not None else None,
            "peopleDistance": [PersonDistance.from_dict(_item) for _item in obj["peopleDistance"]] if obj.get("peopleDistance") is not None else None,
            "inviteInfo": InviteInfo.from_dict(obj["inviteInfo"]) if obj.get("inviteInfo") is not None else None,
            "isSignedUp": obj.get("isSignedUp"),
            "lastExtensionUse": obj.get("lastExtensionUse"),
            "permissions": Permissions.from_dict(obj["permissions"]) if obj.get("permissions") is not None else None,
            "customFields": [CustomFieldData.from_dict(_item) for _item in obj["customFields"]] if obj.get("customFields") is not None else None,
            "loggingId": obj.get("loggingId"),
            "startDatePercentile": obj.get("startDatePercentile"),
            "busyEvents": [AnonymousEvent.from_dict(_item) for _item in obj["busyEvents"]] if obj.get("busyEvents") is not None else None,
            "profileBoolSettings": obj.get("profileBoolSettings"),
            "badges": [Badge.from_dict(_item) for _item in obj["badges"]] if obj.get("badges") is not None else None,
            "isOrgRoot": obj.get("isOrgRoot")
        })
        return _obj

from glean_client_api.models.custom_field_data import CustomFieldData
from glean_client_api.models.invite_info import InviteInfo
from glean_client_api.models.person import Person
from glean_client_api.models.query_suggestion_list import QuerySuggestionList
# TODO: Rewrite to not use raise_errors
PersonMetadata.model_rebuild(raise_errors=False)

