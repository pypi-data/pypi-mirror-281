class __AborApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.AborApi)

   def add_diary_entry(self, scope: Any, code: Any, diary_entry_code: Any, diary_entry_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] AddDiaryEntry: Add a diary entry to the specified Abor.  # noqa: E501

Adds a new diary entry to the specified Abor  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_diary_entry(scope, code, diary_entry_code, diary_entry_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param diary_entry_code: Diary entry code (required)
:type diary_entry_code: str
:param diary_entry_request: The diary entry to add. (required)
:type diary_entry_request: DiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DiaryEntry"""
        return self.__client.add_diary_entry(scope, code, diary_entry_code, diary_entry_request, **kwargs)

   def add_diary_entry_with_http_info(self, scope: Any, code: Any, diary_entry_code: Any, diary_entry_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] AddDiaryEntry: Add a diary entry to the specified Abor.  # noqa: E501

Adds a new diary entry to the specified Abor  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_diary_entry_with_http_info(scope, code, diary_entry_code, diary_entry_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param diary_entry_code: Diary entry code (required)
:type diary_entry_code: str
:param diary_entry_request: The diary entry to add. (required)
:type diary_entry_request: DiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DiaryEntry, int, HTTPHeaderDict)"""
        return self.__client.add_diary_entry_with_http_info(scope, code, diary_entry_code, diary_entry_request, **kwargs)

   def close_period(self, scope: Any, code: Any, close_period_diary_entry_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ClosePeriod: Closes or locks the current period for the given Abor.  # noqa: E501

Closes or Locks the current open period for the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.close_period(scope, code, close_period_diary_entry_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param close_period_diary_entry_request: The request body, containing details to apply to the closing/locking period. (required)
:type close_period_diary_entry_request: ClosePeriodDiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DiaryEntry"""
        return self.__client.close_period(scope, code, close_period_diary_entry_request, **kwargs)

   def close_period_with_http_info(self, scope: Any, code: Any, close_period_diary_entry_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ClosePeriod: Closes or locks the current period for the given Abor.  # noqa: E501

Closes or Locks the current open period for the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.close_period_with_http_info(scope, code, close_period_diary_entry_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param close_period_diary_entry_request: The request body, containing details to apply to the closing/locking period. (required)
:type close_period_diary_entry_request: ClosePeriodDiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DiaryEntry, int, HTTPHeaderDict)"""
        return self.__client.close_period_with_http_info(scope, code, close_period_diary_entry_request, **kwargs)

   def create_abor(self, scope: Any, abor_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateAbor: Create an Abor.  # noqa: E501

Create the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_abor(scope, abor_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param abor_request: The definition of the Abor. (required)
:type abor_request: AborRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Abor"""
        return self.__client.create_abor(scope, abor_request, **kwargs)

   def create_abor_with_http_info(self, scope: Any, abor_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateAbor: Create an Abor.  # noqa: E501

Create the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_abor_with_http_info(scope, abor_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param abor_request: The definition of the Abor. (required)
:type abor_request: AborRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Abor, int, HTTPHeaderDict)"""
        return self.__client.create_abor_with_http_info(scope, abor_request, **kwargs)

   def delete_abor(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteAbor: Delete an Abor.  # noqa: E501

Delete the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_abor(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor to be deleted. (required)
:type scope: str
:param code: The code of the Abor to be deleted. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_abor(scope, code, **kwargs)

   def delete_abor_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteAbor: Delete an Abor.  # noqa: E501

Delete the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_abor_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor to be deleted. (required)
:type scope: str
:param code: The code of the Abor to be deleted. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_abor_with_http_info(scope, code, **kwargs)

   def get_abor(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAbor: Get Abor.  # noqa: E501

Retrieve the definition of a particular Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_abor(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Abor properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Abor definition. Defaults to returning the latest version of the Abor definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Abor' domain to decorate onto the Abor.              These must take the format {domain}/{scope}/{code}, for example 'Abor/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Abor"""
        return self.__client.get_abor(scope, code, **kwargs)

   def get_abor_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAbor: Get Abor.  # noqa: E501

Retrieve the definition of a particular Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_abor_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Abor properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Abor definition. Defaults to returning the latest version of the Abor definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Abor' domain to decorate onto the Abor.              These must take the format {domain}/{scope}/{code}, for example 'Abor/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Abor, int, HTTPHeaderDict)"""
        return self.__client.get_abor_with_http_info(scope, code, **kwargs)

   def get_journal_entry_lines(self, scope: Any, code: Any, journal_entry_lines_query_parameters: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetJournalEntryLines: Get the Journal Entry lines for the given Abor.  # noqa: E501

Gets the Journal Entry lines for the given Abor                The Journal Entry lines have been generated from transactions and translated via posting rules  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_journal_entry_lines(scope, code, journal_entry_lines_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. Together with the scope is creating the unique identifier for the given Abor. (required)
:type code: str
:param journal_entry_lines_query_parameters: The query parameters used in running the generation of the Journal Entry lines. (required)
:type journal_entry_lines_query_parameters: JournalEntryLinesQueryParameters
:param as_at: The asAt datetime at which to retrieve Journal Entry lines. Defaults to returning the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: "Expression to filter the result set."
:type filter: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing Journal Entry lines from a previous call to GetJournalEntryLines.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfJournalEntryLine"""
        return self.__client.get_journal_entry_lines(scope, code, journal_entry_lines_query_parameters, **kwargs)

   def get_journal_entry_lines_with_http_info(self, scope: Any, code: Any, journal_entry_lines_query_parameters: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetJournalEntryLines: Get the Journal Entry lines for the given Abor.  # noqa: E501

Gets the Journal Entry lines for the given Abor                The Journal Entry lines have been generated from transactions and translated via posting rules  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_journal_entry_lines_with_http_info(scope, code, journal_entry_lines_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. Together with the scope is creating the unique identifier for the given Abor. (required)
:type code: str
:param journal_entry_lines_query_parameters: The query parameters used in running the generation of the Journal Entry lines. (required)
:type journal_entry_lines_query_parameters: JournalEntryLinesQueryParameters
:param as_at: The asAt datetime at which to retrieve Journal Entry lines. Defaults to returning the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: "Expression to filter the result set."
:type filter: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing Journal Entry lines from a previous call to GetJournalEntryLines.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfJournalEntryLine, int, HTTPHeaderDict)"""
        return self.__client.get_journal_entry_lines_with_http_info(scope, code, journal_entry_lines_query_parameters, **kwargs)

   def get_trial_balance(self, scope: Any, code: Any, trial_balance_query_parameters: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTrialBalance: Get the Trial balance for the given Abor.  # noqa: E501

Gets the Trial balance for the given Abor    The Trial balance has been generated from transactions, translated via posting rules and aggregated based on a General Ledger Profile (where specified)  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_trial_balance(scope, code, trial_balance_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. Together with the scope is the unique identifier for the given Abor. (required)
:type code: str
:param trial_balance_query_parameters: The query parameters used in running the generation of the Trial Balance. (required)
:type trial_balance_query_parameters: TrialBalanceQueryParameters
:param as_at: The asAt datetime at which to retrieve trial balance. Defaults to returning the latest version              of each transaction if not specified.
:type as_at: datetime
:param filter: "Expression to filter the result set."
:type filter: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing Trial balance from a previous call to Trial balance.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfTrialBalance"""
        return self.__client.get_trial_balance(scope, code, trial_balance_query_parameters, **kwargs)

   def get_trial_balance_with_http_info(self, scope: Any, code: Any, trial_balance_query_parameters: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTrialBalance: Get the Trial balance for the given Abor.  # noqa: E501

Gets the Trial balance for the given Abor    The Trial balance has been generated from transactions, translated via posting rules and aggregated based on a General Ledger Profile (where specified)  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_trial_balance_with_http_info(scope, code, trial_balance_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. Together with the scope is the unique identifier for the given Abor. (required)
:type code: str
:param trial_balance_query_parameters: The query parameters used in running the generation of the Trial Balance. (required)
:type trial_balance_query_parameters: TrialBalanceQueryParameters
:param as_at: The asAt datetime at which to retrieve trial balance. Defaults to returning the latest version              of each transaction if not specified.
:type as_at: datetime
:param filter: "Expression to filter the result set."
:type filter: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing Trial balance from a previous call to Trial balance.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfTrialBalance, int, HTTPHeaderDict)"""
        return self.__client.get_trial_balance_with_http_info(scope, code, trial_balance_query_parameters, **kwargs)

   def list_abors(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListAbors: List Abors.  # noqa: E501

List all the Abors matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_abors(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Abor. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the Abor. Defaults to returning the latest version of each Abor if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Abor; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Abor type, specify "id.Code eq 'Abor1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'Abor' domain to decorate onto each Abor.              These must take the format {domain}/{scope}/{code}, for example 'Abor/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfAbor"""
        return self.__client.list_abors(**kwargs)

   def list_abors_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListAbors: List Abors.  # noqa: E501

List all the Abors matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_abors_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Abor. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the Abor. Defaults to returning the latest version of each Abor if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Abor; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Abor type, specify "id.Code eq 'Abor1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'Abor' domain to decorate onto each Abor.              These must take the format {domain}/{scope}/{code}, for example 'Abor/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfAbor, int, HTTPHeaderDict)"""
        return self.__client.list_abors_with_http_info(**kwargs)

   def list_diary_entries(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListDiaryEntries: List diary entries.  # noqa: E501

List all the diary entries matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_diary_entries(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Diary Entries. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the DiaryEntry. Defaults to returning the latest version of each DiaryEntry if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing diary entries; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the DiaryEntry type, specify "type eq 'PeriodBoundary'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'DiaryEntry' domain to decorate onto each DiaryEntry.              These must take the format {domain}/{scope}/{code}, for example 'DiaryEntry/Report/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfDiaryEntry"""
        return self.__client.list_diary_entries(scope, code, **kwargs)

   def list_diary_entries_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListDiaryEntries: List diary entries.  # noqa: E501

List all the diary entries matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_diary_entries_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Diary Entries. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the DiaryEntry. Defaults to returning the latest version of each DiaryEntry if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing diary entries; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the DiaryEntry type, specify "type eq 'PeriodBoundary'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'DiaryEntry' domain to decorate onto each DiaryEntry.              These must take the format {domain}/{scope}/{code}, for example 'DiaryEntry/Report/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfDiaryEntry, int, HTTPHeaderDict)"""
        return self.__client.list_diary_entries_with_http_info(scope, code, **kwargs)

   def lock_period(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] LockPeriod: Locks the last Closed or given Closed Period.  # noqa: E501

Locks the specified or last locked period for the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.lock_period(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param lock_period_diary_entry_request: The request body, detailing lock details
:type lock_period_diary_entry_request: LockPeriodDiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DiaryEntry"""
        return self.__client.lock_period(scope, code, **kwargs)

   def lock_period_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] LockPeriod: Locks the last Closed or given Closed Period.  # noqa: E501

Locks the specified or last locked period for the given Abor.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.lock_period_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor. (required)
:type scope: str
:param code: The code of the Abor. (required)
:type code: str
:param lock_period_diary_entry_request: The request body, detailing lock details
:type lock_period_diary_entry_request: LockPeriodDiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DiaryEntry, int, HTTPHeaderDict)"""
        return self.__client.lock_period_with_http_info(scope, code, **kwargs)

   def re_open_periods(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ReOpenPeriods: Reopen periods from a seed Diary Entry Code or when not specified, the last Closed Period for the given Abor.  # noqa: E501

Reopens one or more periods.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.re_open_periods(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor to be deleted. (required)
:type scope: str
:param code: The code of the Abor to be deleted. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param re_open_period_diary_entry_request: The request body, detailing re open details
:type re_open_period_diary_entry_request: ReOpenPeriodDiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PeriodDiaryEntriesReopenedResponse"""
        return self.__client.re_open_periods(scope, code, **kwargs)

   def re_open_periods_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ReOpenPeriods: Reopen periods from a seed Diary Entry Code or when not specified, the last Closed Period for the given Abor.  # noqa: E501

Reopens one or more periods.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.re_open_periods_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor to be deleted. (required)
:type scope: str
:param code: The code of the Abor to be deleted. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param re_open_period_diary_entry_request: The request body, detailing re open details
:type re_open_period_diary_entry_request: ReOpenPeriodDiaryEntryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PeriodDiaryEntriesReopenedResponse, int, HTTPHeaderDict)"""
        return self.__client.re_open_periods_with_http_info(scope, code, **kwargs)

   def upsert_abor_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAborProperties: Upsert Abor properties  # noqa: E501

Update or insert one or more properties onto a single Abor. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'Abor'.                Upserting a property that exists for an Abor, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_abor_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Abor to update or insert the properties onto. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the Abor. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "Abor/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AborProperties"""
        return self.__client.upsert_abor_properties(scope, code, **kwargs)

   def upsert_abor_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAborProperties: Upsert Abor properties  # noqa: E501

Update or insert one or more properties onto a single Abor. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'Abor'.                Upserting a property that exists for an Abor, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_abor_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Abor to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Abor to update or insert the properties onto. Together with the scope this uniquely identifies the Abor. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the Abor. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "Abor/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AborProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_abor_properties_with_http_info(scope, code, **kwargs)

abor_api = __AborApiAuthedAndStubbed()

class __AborConfigurationApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.AborConfigurationApi)

   def create_abor_configuration(self, scope: Any, abor_configuration_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateAborConfiguration: Create an AborConfiguration.  # noqa: E501

Create the given AborConfiguration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_abor_configuration(scope, abor_configuration_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration. (required)
:type scope: str
:param abor_configuration_request: The definition of the AborConfiguration. (required)
:type abor_configuration_request: AborConfigurationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AborConfiguration"""
        return self.__client.create_abor_configuration(scope, abor_configuration_request, **kwargs)

   def create_abor_configuration_with_http_info(self, scope: Any, abor_configuration_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateAborConfiguration: Create an AborConfiguration.  # noqa: E501

Create the given AborConfiguration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_abor_configuration_with_http_info(scope, abor_configuration_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration. (required)
:type scope: str
:param abor_configuration_request: The definition of the AborConfiguration. (required)
:type abor_configuration_request: AborConfigurationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AborConfiguration, int, HTTPHeaderDict)"""
        return self.__client.create_abor_configuration_with_http_info(scope, abor_configuration_request, **kwargs)

   def delete_abor_configuration(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteAborConfiguration: Delete an AborConfiguration.  # noqa: E501

Delete the given AborConfiguration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_abor_configuration(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration to be deleted. (required)
:type scope: str
:param code: The code of the AborConfiguration to be deleted. Together with the scope this uniquely identifies the AborConfiguration. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_abor_configuration(scope, code, **kwargs)

   def delete_abor_configuration_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteAborConfiguration: Delete an AborConfiguration.  # noqa: E501

Delete the given AborConfiguration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_abor_configuration_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration to be deleted. (required)
:type scope: str
:param code: The code of the AborConfiguration to be deleted. Together with the scope this uniquely identifies the AborConfiguration. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_abor_configuration_with_http_info(scope, code, **kwargs)

   def get_abor_configuration(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAborConfiguration: Get AborConfiguration.  # noqa: E501

Retrieve the definition of a particular AborConfiguration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_abor_configuration(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration. (required)
:type scope: str
:param code: The code of the AborConfiguration. Together with the scope this uniquely identifies the AborConfiguration. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the AborConfiguration properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the AborConfiguration definition. Defaults to returning the latest version of the AborConfiguration definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'AborConfiguration' domain to decorate onto the AborConfiguration.              These must take the format {domain}/{scope}/{code}, for example 'AborConfiguration/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AborConfiguration"""
        return self.__client.get_abor_configuration(scope, code, **kwargs)

   def get_abor_configuration_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAborConfiguration: Get AborConfiguration.  # noqa: E501

Retrieve the definition of a particular AborConfiguration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_abor_configuration_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration. (required)
:type scope: str
:param code: The code of the AborConfiguration. Together with the scope this uniquely identifies the AborConfiguration. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the AborConfiguration properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the AborConfiguration definition. Defaults to returning the latest version of the AborConfiguration definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'AborConfiguration' domain to decorate onto the AborConfiguration.              These must take the format {domain}/{scope}/{code}, for example 'AborConfiguration/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AborConfiguration, int, HTTPHeaderDict)"""
        return self.__client.get_abor_configuration_with_http_info(scope, code, **kwargs)

   def list_abor_configurations(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListAborConfigurations: List AborConfiguration.  # noqa: E501

List all the AborConfiguration matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_abor_configurations(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the AborConfiguration. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the AborConfiguration. Defaults to returning the latest version of each AAborConfigurationbor if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing AborConfiguration; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the AborConfiguration type, specify "id.Code eq 'AborConfiguration1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'AborConfiguration' domain to decorate onto each AborConfiguration.              These must take the format {domain}/{scope}/{code}, for example 'AborConfiguration/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfAborConfiguration"""
        return self.__client.list_abor_configurations(**kwargs)

   def list_abor_configurations_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListAborConfigurations: List AborConfiguration.  # noqa: E501

List all the AborConfiguration matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_abor_configurations_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the AborConfiguration. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the AborConfiguration. Defaults to returning the latest version of each AAborConfigurationbor if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing AborConfiguration; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the AborConfiguration type, specify "id.Code eq 'AborConfiguration1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'AborConfiguration' domain to decorate onto each AborConfiguration.              These must take the format {domain}/{scope}/{code}, for example 'AborConfiguration/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfAborConfiguration, int, HTTPHeaderDict)"""
        return self.__client.list_abor_configurations_with_http_info(**kwargs)

   def upsert_abor_configuration_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAborConfigurationProperties: Upsert AborConfiguration properties  # noqa: E501

Update or insert one or more properties onto a single AborConfiguration. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'AborConfiguration'.                Upserting a property that exists for an AborConfiguration, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_abor_configuration_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the AborConfiguration to update or insert the properties onto. Together with the scope this uniquely identifies the AborConfiguration. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the chart of account. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "AborConfiguration/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AborConfigurationProperties"""
        return self.__client.upsert_abor_configuration_properties(scope, code, **kwargs)

   def upsert_abor_configuration_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAborConfigurationProperties: Upsert AborConfiguration properties  # noqa: E501

Update or insert one or more properties onto a single AborConfiguration. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'AborConfiguration'.                Upserting a property that exists for an AborConfiguration, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_abor_configuration_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the AborConfiguration to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the AborConfiguration to update or insert the properties onto. Together with the scope this uniquely identifies the AborConfiguration. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the chart of account. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "AborConfiguration/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AborConfigurationProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_abor_configuration_properties_with_http_info(scope, code, **kwargs)

abor_configuration_api = __AborConfigurationApiAuthedAndStubbed()

class __AddressKeyDefinitionApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.AddressKeyDefinitionApi)

   def create_address_key_definition(self, create_address_key_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateAddressKeyDefinition: Create an AddressKeyDefinition.  # noqa: E501

Create the given address key definition.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_address_key_definition(create_address_key_definition_request, async_req=True)
>>> result = thread.get()

:param create_address_key_definition_request: The request used to create the address key definition. (required)
:type create_address_key_definition_request: CreateAddressKeyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AddressKeyDefinition"""
        return self.__client.create_address_key_definition(create_address_key_definition_request, **kwargs)

   def create_address_key_definition_with_http_info(self, create_address_key_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateAddressKeyDefinition: Create an AddressKeyDefinition.  # noqa: E501

Create the given address key definition.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_address_key_definition_with_http_info(create_address_key_definition_request, async_req=True)
>>> result = thread.get()

:param create_address_key_definition_request: The request used to create the address key definition. (required)
:type create_address_key_definition_request: CreateAddressKeyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AddressKeyDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_address_key_definition_with_http_info(create_address_key_definition_request, **kwargs)

   def get_address_key_definition(self, key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAddressKeyDefinition: Get an AddressKeyDefinition.  # noqa: E501

Get the address key definition with the given address key at the specific asAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_address_key_definition(key, async_req=True)
>>> result = thread.get()

:param key: The address key of the address key definition. (required)
:type key: str
:param as_at: The asAt datetime at which to retrieve the address key definition. Defaults to return the latest version of the address key definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AddressKeyDefinition"""
        return self.__client.get_address_key_definition(key, **kwargs)

   def get_address_key_definition_with_http_info(self, key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAddressKeyDefinition: Get an AddressKeyDefinition.  # noqa: E501

Get the address key definition with the given address key at the specific asAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_address_key_definition_with_http_info(key, async_req=True)
>>> result = thread.get()

:param key: The address key of the address key definition. (required)
:type key: str
:param as_at: The asAt datetime at which to retrieve the address key definition. Defaults to return the latest version of the address key definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AddressKeyDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_address_key_definition_with_http_info(key, **kwargs)

   def list_address_key_definitions(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAddressKeyDefinitions: List AddressKeyDefinitions.  # noqa: E501

Fetch the last pre-AsAt date version of each address key definition.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_address_key_definitions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the address key definition.              Defaults to return the latest version of the address key definition if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing address key definitions from a previous call to list address key definitions.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfAddressKeyDefinition"""
        return self.__client.list_address_key_definitions(**kwargs)

   def list_address_key_definitions_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAddressKeyDefinitions: List AddressKeyDefinitions.  # noqa: E501

Fetch the last pre-AsAt date version of each address key definition.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_address_key_definitions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the address key definition.              Defaults to return the latest version of the address key definition if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing address key definitions from a previous call to list address key definitions.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfAddressKeyDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_address_key_definitions_with_http_info(**kwargs)

address_key_definition_api = __AddressKeyDefinitionApiAuthedAndStubbed()

class __AggregationApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.AggregationApi)

   def generate_configuration_recipe(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GenerateConfigurationRecipe: Generates a recipe sufficient to perform valuations for the given portfolio.  # noqa: E501

Given a set of scopes, a portfolio Id and a basic recipe, this endpoint generates a configuration recipe with relevant rules that can value the instruments in the portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.generate_configuration_recipe(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio (required)
:type scope: str
:param code: The code of the portfolio (required)
:type code: str
:param create_recipe_request: The request specifying the parameters to generating the recipe
:type create_recipe_request: CreateRecipeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ConfigurationRecipe"""
        return self.__client.generate_configuration_recipe(scope, code, **kwargs)

   def generate_configuration_recipe_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GenerateConfigurationRecipe: Generates a recipe sufficient to perform valuations for the given portfolio.  # noqa: E501

Given a set of scopes, a portfolio Id and a basic recipe, this endpoint generates a configuration recipe with relevant rules that can value the instruments in the portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.generate_configuration_recipe_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio (required)
:type scope: str
:param code: The code of the portfolio (required)
:type code: str
:param create_recipe_request: The request specifying the parameters to generating the recipe
:type create_recipe_request: CreateRecipeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ConfigurationRecipe, int, HTTPHeaderDict)"""
        return self.__client.generate_configuration_recipe_with_http_info(scope, code, **kwargs)

   def get_queryable_keys(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetQueryableKeys: Query the set of supported "addresses" that can be queried from the aggregation endpoint.  # noqa: E501

When a request is made for aggregation, the user needs to know what keys can be passed to it for queryable data. This endpoint allows to queries to provide the set of keys,  what they are and what they return.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_queryable_keys(async_req=True)
>>> result = thread.get()

:param page: The pagination token to use to continue listing queryable keys from a previous call to list queryable keys.              This value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAggregationQuery"""
        return self.__client.get_queryable_keys(**kwargs)

   def get_queryable_keys_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetQueryableKeys: Query the set of supported "addresses" that can be queried from the aggregation endpoint.  # noqa: E501

When a request is made for aggregation, the user needs to know what keys can be passed to it for queryable data. This endpoint allows to queries to provide the set of keys,  what they are and what they return.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_queryable_keys_with_http_info(async_req=True)
>>> result = thread.get()

:param page: The pagination token to use to continue listing queryable keys from a previous call to list queryable keys.              This value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAggregationQuery, int, HTTPHeaderDict)"""
        return self.__client.get_queryable_keys_with_http_info(**kwargs)

   def get_valuation(self, **kwargs) -> 'Any':
        """GetValuation: Perform valuation for a list of portfolios and/or portfolio groups  # noqa: E501

Perform valuation on specified list of portfolio and/or portfolio groups for a set of dates.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_valuation(async_req=True)
>>> result = thread.get()

:param valuation_request: The request specifying the set of portfolios and dates on which to calculate a set of valuation metrics
:type valuation_request: ValuationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ListAggregationResponse"""
        return self.__client.get_valuation(**kwargs)

   def get_valuation_of_weighted_instruments(self, **kwargs) -> 'Any':
        """GetValuationOfWeightedInstruments: Perform valuation for an inlined portfolio  # noqa: E501

Perform valuation on the portfolio that is defined by the weighted set of instruments passed to the request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_valuation_of_weighted_instruments(async_req=True)
>>> result = thread.get()

:param inline_valuation_request: The request specifying the set of portfolios and dates on which to calculate a set of valuation metrics
:type inline_valuation_request: InlineValuationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ListAggregationResponse"""
        return self.__client.get_valuation_of_weighted_instruments(**kwargs)

   def get_valuation_of_weighted_instruments_with_http_info(self, **kwargs) -> 'Any':
        """GetValuationOfWeightedInstruments: Perform valuation for an inlined portfolio  # noqa: E501

Perform valuation on the portfolio that is defined by the weighted set of instruments passed to the request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_valuation_of_weighted_instruments_with_http_info(async_req=True)
>>> result = thread.get()

:param inline_valuation_request: The request specifying the set of portfolios and dates on which to calculate a set of valuation metrics
:type inline_valuation_request: InlineValuationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ListAggregationResponse, int, HTTPHeaderDict)"""
        return self.__client.get_valuation_of_weighted_instruments_with_http_info(**kwargs)

   def get_valuation_with_http_info(self, **kwargs) -> 'Any':
        """GetValuation: Perform valuation for a list of portfolios and/or portfolio groups  # noqa: E501

Perform valuation on specified list of portfolio and/or portfolio groups for a set of dates.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_valuation_with_http_info(async_req=True)
>>> result = thread.get()

:param valuation_request: The request specifying the set of portfolios and dates on which to calculate a set of valuation metrics
:type valuation_request: ValuationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ListAggregationResponse, int, HTTPHeaderDict)"""
        return self.__client.get_valuation_with_http_info(**kwargs)

aggregation_api = __AggregationApiAuthedAndStubbed()

class __AllocationsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.AllocationsApi)

   def delete_allocation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteAllocation: Delete allocation  # noqa: E501

Delete an allocation. Deletion will be valid from the allocation's creation datetime.  This means that the allocation will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_allocation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The allocation scope. (required)
:type scope: str
:param code: The allocation's code. This, together with the scope uniquely identifies the allocation to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_allocation(scope, code, **kwargs)

   def delete_allocation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteAllocation: Delete allocation  # noqa: E501

Delete an allocation. Deletion will be valid from the allocation's creation datetime.  This means that the allocation will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_allocation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The allocation scope. (required)
:type scope: str
:param code: The allocation's code. This, together with the scope uniquely identifies the allocation to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_allocation_with_http_info(scope, code, **kwargs)

   def get_allocation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllocation: Get Allocation  # noqa: E501

Fetch an Allocation matching the provided identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_allocation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the allocation belongs. (required)
:type scope: str
:param code: The allocation's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the allocation. Defaults to return the latest version of the allocation if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Allocations" domain to decorate onto the allocation.              These take the format {domain}/{scope}/{code} e.g. "Allocations/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Allocation"""
        return self.__client.get_allocation(scope, code, **kwargs)

   def get_allocation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllocation: Get Allocation  # noqa: E501

Fetch an Allocation matching the provided identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_allocation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the allocation belongs. (required)
:type scope: str
:param code: The allocation's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the allocation. Defaults to return the latest version of the allocation if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Allocations" domain to decorate onto the allocation.              These take the format {domain}/{scope}/{code} e.g. "Allocations/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Allocation, int, HTTPHeaderDict)"""
        return self.__client.get_allocation_with_http_info(scope, code, **kwargs)

   def list_allocations(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAllocations: List Allocations  # noqa: E501

Fetch the last pre-AsAt date version of each allocation in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_allocations(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the allocation. Defaults to return the latest version of the allocation if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing allocations from a previous call to list allocations.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Allocations" domain to decorate onto each allocation.                  These take the format {domain}/{scope}/{code} e.g. "Allocations/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfAllocation"""
        return self.__client.list_allocations(**kwargs)

   def list_allocations_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAllocations: List Allocations  # noqa: E501

Fetch the last pre-AsAt date version of each allocation in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_allocations_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the allocation. Defaults to return the latest version of the allocation if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing allocations from a previous call to list allocations.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Allocations" domain to decorate onto each allocation.                  These take the format {domain}/{scope}/{code} e.g. "Allocations/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfAllocation, int, HTTPHeaderDict)"""
        return self.__client.list_allocations_with_http_info(**kwargs)

   def upsert_allocations(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertAllocations: Upsert Allocations  # noqa: E501

Upsert; update existing allocations with given ids, or create new allocations otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_allocations(async_req=True)
>>> result = thread.get()

:param allocation_set_request: The collection of allocation requests.
:type allocation_set_request: AllocationSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAllocation"""
        return self.__client.upsert_allocations(**kwargs)

   def upsert_allocations_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertAllocations: Upsert Allocations  # noqa: E501

Upsert; update existing allocations with given ids, or create new allocations otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_allocations_with_http_info(async_req=True)
>>> result = thread.get()

:param allocation_set_request: The collection of allocation requests.
:type allocation_set_request: AllocationSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAllocation, int, HTTPHeaderDict)"""
        return self.__client.upsert_allocations_with_http_info(**kwargs)

allocations_api = __AllocationsApiAuthedAndStubbed()

class __ApplicationMetadataApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ApplicationMetadataApi)

   def get_excel_addin(self, **kwargs) -> 'Any':
        """GetExcelAddin: Download Excel Addin  # noqa: E501

Download the LUSID Excel Addin for Microsoft Excel. Not providing a specific value will return the latest version being returned  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_excel_addin(async_req=True)
>>> result = thread.get()

:param version: The requested version of the Excel plugin
:type version: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: FileResponse"""
        return self.__client.get_excel_addin(**kwargs)

   def get_excel_addin_with_http_info(self, **kwargs) -> 'Any':
        """GetExcelAddin: Download Excel Addin  # noqa: E501

Download the LUSID Excel Addin for Microsoft Excel. Not providing a specific value will return the latest version being returned  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_excel_addin_with_http_info(async_req=True)
>>> result = thread.get()

:param version: The requested version of the Excel plugin
:type version: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (FileResponse, int, HTTPHeaderDict)"""
        return self.__client.get_excel_addin_with_http_info(**kwargs)

   def get_lusid_versions(self, **kwargs) -> 'Any':
        """GetLusidVersions: Get LUSID versions  # noqa: E501

Get the semantic versions associated with LUSID and its ecosystem  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_lusid_versions(async_req=True)
>>> result = thread.get()

:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionSummaryDto"""
        return self.__client.get_lusid_versions(**kwargs)

   def get_lusid_versions_with_http_info(self, **kwargs) -> 'Any':
        """GetLusidVersions: Get LUSID versions  # noqa: E501

Get the semantic versions associated with LUSID and its ecosystem  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_lusid_versions_with_http_info(async_req=True)
>>> result = thread.get()

:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionSummaryDto, int, HTTPHeaderDict)"""
        return self.__client.get_lusid_versions_with_http_info(**kwargs)

   def list_access_controlled_resources(self, **kwargs) -> 'Any':
        """ListAccessControlledResources: Get resources available for access control  # noqa: E501

Get the comprehensive set of resources that are available for access control  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_access_controlled_resources(async_req=True)
>>> result = thread.get()

:param filter: Optional. Expression to filter the result set.               For example, to filter on the Application, use "application eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAccessControlledResource"""
        return self.__client.list_access_controlled_resources(**kwargs)

   def list_access_controlled_resources_with_http_info(self, **kwargs) -> 'Any':
        """ListAccessControlledResources: Get resources available for access control  # noqa: E501

Get the comprehensive set of resources that are available for access control  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_access_controlled_resources_with_http_info(async_req=True)
>>> result = thread.get()

:param filter: Optional. Expression to filter the result set.               For example, to filter on the Application, use "application eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAccessControlledResource, int, HTTPHeaderDict)"""
        return self.__client.list_access_controlled_resources_with_http_info(**kwargs)

application_metadata_api = __ApplicationMetadataApiAuthedAndStubbed()

class __BlocksApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.BlocksApi)

   def delete_block(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteBlock: Delete block  # noqa: E501

Delete an block. Deletion will be valid from the block's creation datetime.  This means that the block will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_block(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The block scope. (required)
:type scope: str
:param code: The block's code. This, together with the scope uniquely identifies the block to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_block(scope, code, **kwargs)

   def delete_block_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteBlock: Delete block  # noqa: E501

Delete an block. Deletion will be valid from the block's creation datetime.  This means that the block will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_block_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The block scope. (required)
:type scope: str
:param code: The block's code. This, together with the scope uniquely identifies the block to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_block_with_http_info(scope, code, **kwargs)

   def get_block(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetBlock: Get Block  # noqa: E501

Fetch a Block that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_block(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the block belongs. (required)
:type scope: str
:param code: The block's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the block. Defaults to return the latest version of the block if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Block" domain to decorate onto the block.              These take the format {domain}/{scope}/{code} e.g. "Block/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Block"""
        return self.__client.get_block(scope, code, **kwargs)

   def get_block_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetBlock: Get Block  # noqa: E501

Fetch a Block that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_block_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the block belongs. (required)
:type scope: str
:param code: The block's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the block. Defaults to return the latest version of the block if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Block" domain to decorate onto the block.              These take the format {domain}/{scope}/{code} e.g. "Block/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Block, int, HTTPHeaderDict)"""
        return self.__client.get_block_with_http_info(scope, code, **kwargs)

   def list_blocks(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListBlocks: List Blocks  # noqa: E501

Fetch the last pre-AsAt date version of each block in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_blocks(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the block. Defaults to return the latest version of the block if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing blocks from a previous call to list blocks.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Block" domain to decorate onto each block.                  These take the format {domain}/{scope}/{code} e.g. "Block/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfBlock"""
        return self.__client.list_blocks(**kwargs)

   def list_blocks_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListBlocks: List Blocks  # noqa: E501

Fetch the last pre-AsAt date version of each block in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_blocks_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the block. Defaults to return the latest version of the block if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing blocks from a previous call to list blocks.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Block" domain to decorate onto each block.                  These take the format {domain}/{scope}/{code} e.g. "Block/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfBlock, int, HTTPHeaderDict)"""
        return self.__client.list_blocks_with_http_info(**kwargs)

   def upsert_blocks(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertBlocks: Upsert Block  # noqa: E501

Upsert; update existing blocks with given ids, or create new blocks otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_blocks(async_req=True)
>>> result = thread.get()

:param block_set_request: The collection of block requests.
:type block_set_request: BlockSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfBlock"""
        return self.__client.upsert_blocks(**kwargs)

   def upsert_blocks_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertBlocks: Upsert Block  # noqa: E501

Upsert; update existing blocks with given ids, or create new blocks otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_blocks_with_http_info(async_req=True)
>>> result = thread.get()

:param block_set_request: The collection of block requests.
:type block_set_request: BlockSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfBlock, int, HTTPHeaderDict)"""
        return self.__client.upsert_blocks_with_http_info(**kwargs)

blocks_api = __BlocksApiAuthedAndStubbed()

class __CalendarsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CalendarsApi)

   def add_business_days_to_date(self, scope: Any, add_business_days_to_date_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddBusinessDaysToDate: Adds the requested number of Business Days to the provided date.  # noqa: E501

A Business day is defined as a point in time that:      * Does not represent a day in the calendar's weekend      * Does not represent a day in the calendar's list of holidays (e.g. Christmas Day in the UK)                 All dates specified must be UTC and the upper bound of a calendar is not inclusive                 e.g. From: 2020-12-24-00-00-00:       Adding 3 business days returns 2020-12-30, assuming Saturday and Sunday are weekends, and the 25th and 28th are holidays.       Adding -2 business days returns 2020-12-22 under the same assumptions.                If the provided number of days to add is zero, returns a failure.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_business_days_to_date(scope, add_business_days_to_date_request, async_req=True)
>>> result = thread.get()

:param scope: Scope within which to search for the calendars (required)
:type scope: str
:param add_business_days_to_date_request: Request Details: start date, number of days to add (which can be negative, but not zero), calendar codes and optionally an AsAt date for searching the calendar store (required)
:type add_business_days_to_date_request: AddBusinessDaysToDateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AddBusinessDaysToDateResponse"""
        return self.__client.add_business_days_to_date(scope, add_business_days_to_date_request, **kwargs)

   def add_business_days_to_date_with_http_info(self, scope: Any, add_business_days_to_date_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddBusinessDaysToDate: Adds the requested number of Business Days to the provided date.  # noqa: E501

A Business day is defined as a point in time that:      * Does not represent a day in the calendar's weekend      * Does not represent a day in the calendar's list of holidays (e.g. Christmas Day in the UK)                 All dates specified must be UTC and the upper bound of a calendar is not inclusive                 e.g. From: 2020-12-24-00-00-00:       Adding 3 business days returns 2020-12-30, assuming Saturday and Sunday are weekends, and the 25th and 28th are holidays.       Adding -2 business days returns 2020-12-22 under the same assumptions.                If the provided number of days to add is zero, returns a failure.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_business_days_to_date_with_http_info(scope, add_business_days_to_date_request, async_req=True)
>>> result = thread.get()

:param scope: Scope within which to search for the calendars (required)
:type scope: str
:param add_business_days_to_date_request: Request Details: start date, number of days to add (which can be negative, but not zero), calendar codes and optionally an AsAt date for searching the calendar store (required)
:type add_business_days_to_date_request: AddBusinessDaysToDateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AddBusinessDaysToDateResponse, int, HTTPHeaderDict)"""
        return self.__client.add_business_days_to_date_with_http_info(scope, add_business_days_to_date_request, **kwargs)

   def add_date_to_calendar(self, scope: Any, code: Any, create_date_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddDateToCalendar: Add a date to a calendar  # noqa: E501

Add an event to the calendar. These Events can be a maximum of 24 hours and must be specified in UTC.  A local date will be calculated by the system and applied to the calendar before processing.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_date_to_calendar(scope, code, create_date_request, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param create_date_request: Add date to calendar request (required)
:type create_date_request: CreateDateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CalendarDate"""
        return self.__client.add_date_to_calendar(scope, code, create_date_request, **kwargs)

   def add_date_to_calendar_with_http_info(self, scope: Any, code: Any, create_date_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddDateToCalendar: Add a date to a calendar  # noqa: E501

Add an event to the calendar. These Events can be a maximum of 24 hours and must be specified in UTC.  A local date will be calculated by the system and applied to the calendar before processing.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_date_to_calendar_with_http_info(scope, code, create_date_request, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param create_date_request: Add date to calendar request (required)
:type create_date_request: CreateDateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CalendarDate, int, HTTPHeaderDict)"""
        return self.__client.add_date_to_calendar_with_http_info(scope, code, create_date_request, **kwargs)

   def create_calendar(self, create_calendar_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCalendar: Create a calendar in its generic form  # noqa: E501

Create a calendar in a generic form which can be used to store date events.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_calendar(create_calendar_request, async_req=True)
>>> result = thread.get()

:param create_calendar_request: A request to create the calendar (required)
:type create_calendar_request: CreateCalendarRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Calendar"""
        return self.__client.create_calendar(create_calendar_request, **kwargs)

   def create_calendar_with_http_info(self, create_calendar_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCalendar: Create a calendar in its generic form  # noqa: E501

Create a calendar in a generic form which can be used to store date events.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_calendar_with_http_info(create_calendar_request, async_req=True)
>>> result = thread.get()

:param create_calendar_request: A request to create the calendar (required)
:type create_calendar_request: CreateCalendarRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Calendar, int, HTTPHeaderDict)"""
        return self.__client.create_calendar_with_http_info(create_calendar_request, **kwargs)

   def delete_calendar(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCalendar: Delete a calendar  # noqa: E501

Delete a calendar and all of its respective dates  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_calendar(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Calendar"""
        return self.__client.delete_calendar(scope, code, **kwargs)

   def delete_calendar_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCalendar: Delete a calendar  # noqa: E501

Delete a calendar and all of its respective dates  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_calendar_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Calendar, int, HTTPHeaderDict)"""
        return self.__client.delete_calendar_with_http_info(scope, code, **kwargs)

   def delete_date_from_calendar(self, scope: Any, code: Any, date_id: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteDateFromCalendar: Remove a date from a calendar  # noqa: E501

Remove a date from a calendar.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_date_from_calendar(scope, code, date_id, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param date_id: Identifier of the date to be removed (required)
:type date_id: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CalendarDate"""
        return self.__client.delete_date_from_calendar(scope, code, date_id, **kwargs)

   def delete_date_from_calendar_with_http_info(self, scope: Any, code: Any, date_id: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteDateFromCalendar: Remove a date from a calendar  # noqa: E501

Remove a date from a calendar.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_date_from_calendar_with_http_info(scope, code, date_id, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param date_id: Identifier of the date to be removed (required)
:type date_id: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CalendarDate, int, HTTPHeaderDict)"""
        return self.__client.delete_date_from_calendar_with_http_info(scope, code, date_id, **kwargs)

   def generate_schedule(self, scope: Any, valuation_schedule: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GenerateSchedule: Generate an ordered schedule of dates.  # noqa: E501

Returns an ordered array of dates. The dates will only fall on business  days as defined by the scope and calendar codes in the valuation schedule.                Valuations are made at a frequency defined by the valuation schedule's tenor, e.g. every day ("1D"),  every other week ("2W") etc. These dates will be adjusted onto business days as defined by the schedule's  rollConvention.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.generate_schedule(scope, valuation_schedule, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendars to use (required)
:type scope: str
:param valuation_schedule: The ValuationSchedule to generate schedule dates from (required)
:type valuation_schedule: ValuationSchedule
:param as_at: Optional AsAt for searching the calendar store. Defaults to Latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[datetime]"""
        return self.__client.generate_schedule(scope, valuation_schedule, **kwargs)

   def generate_schedule_with_http_info(self, scope: Any, valuation_schedule: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GenerateSchedule: Generate an ordered schedule of dates.  # noqa: E501

Returns an ordered array of dates. The dates will only fall on business  days as defined by the scope and calendar codes in the valuation schedule.                Valuations are made at a frequency defined by the valuation schedule's tenor, e.g. every day ("1D"),  every other week ("2W") etc. These dates will be adjusted onto business days as defined by the schedule's  rollConvention.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.generate_schedule_with_http_info(scope, valuation_schedule, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendars to use (required)
:type scope: str
:param valuation_schedule: The ValuationSchedule to generate schedule dates from (required)
:type valuation_schedule: ValuationSchedule
:param as_at: Optional AsAt for searching the calendar store. Defaults to Latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[datetime], int, HTTPHeaderDict)"""
        return self.__client.generate_schedule_with_http_info(scope, valuation_schedule, **kwargs)

   def get_calendar(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCalendar: Get a calendar in its generic form  # noqa: E501

Retrieve a generic calendar by a specific ID at a point in AsAt time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_calendar(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar identifier (required)
:type scope: str
:param code: Code of the calendar identifier (required)
:type code: str
:param property_keys: A list of property keys from the "Calendar" domain to decorate onto the calendar,               These take the format {domain}/{scope}/{code} e.g. "Calendar/System/Name".
:type property_keys: list[str]
:param as_at: The AsAt datetime at which to retrieve the calendar
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Calendar"""
        return self.__client.get_calendar(scope, code, **kwargs)

   def get_calendar_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCalendar: Get a calendar in its generic form  # noqa: E501

Retrieve a generic calendar by a specific ID at a point in AsAt time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_calendar_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar identifier (required)
:type scope: str
:param code: Code of the calendar identifier (required)
:type code: str
:param property_keys: A list of property keys from the "Calendar" domain to decorate onto the calendar,               These take the format {domain}/{scope}/{code} e.g. "Calendar/System/Name".
:type property_keys: list[str]
:param as_at: The AsAt datetime at which to retrieve the calendar
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Calendar, int, HTTPHeaderDict)"""
        return self.__client.get_calendar_with_http_info(scope, code, **kwargs)

   def get_dates(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetDates: Get dates for a specific calendar  # noqa: E501

Get dates from a specific calendar within a specific window of effective time, at a point in AsAt time.  Providing an id filter can further refine the results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_dates(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param from_effective_at: Where the effective window of dates should begin from
:type from_effective_at: str
:param to_effective_at: Where the effective window of dates should end
:type to_effective_at: str
:param as_at: AsAt the dates should be retrieved at
:type as_at: datetime
:param id_filter: An additional filter that will filter dates based on their identifer
:type id_filter: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfCalendarDate"""
        return self.__client.get_dates(scope, code, **kwargs)

   def get_dates_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetDates: Get dates for a specific calendar  # noqa: E501

Get dates from a specific calendar within a specific window of effective time, at a point in AsAt time.  Providing an id filter can further refine the results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_dates_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param from_effective_at: Where the effective window of dates should begin from
:type from_effective_at: str
:param to_effective_at: Where the effective window of dates should end
:type to_effective_at: str
:param as_at: AsAt the dates should be retrieved at
:type as_at: datetime
:param id_filter: An additional filter that will filter dates based on their identifer
:type id_filter: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfCalendarDate, int, HTTPHeaderDict)"""
        return self.__client.get_dates_with_http_info(scope, code, **kwargs)

   def is_business_date_time(self, date_time: Any, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] IsBusinessDateTime: Check whether a DateTime is a "Business DateTime"  # noqa: E501

A Business DateTime is defined as a point in time that:      * Does not represent a day that overlaps with the calendars WeekendMask      * If the calendar is a "Holiday Calendar" Does not overlap with any dates in the calendar      * If the calendar is a "TradingHours Calendar" Does overlap with a date in the calendar                All dates specified must be UTC and the upper bound of a calendar is not inclusive   e.g. From: 2020-12-25-00-00-00        To: 2020-12-26-00-00-00  IsBusinessDay(2020-12-26-00-00-00) == false  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.is_business_date_time(date_time, scope, code, async_req=True)
>>> result = thread.get()

:param date_time: DateTime to check - This DateTime must be UTC (required)
:type date_time: datetime
:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param as_at: AsAt for the request
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: IsBusinessDayResponse"""
        return self.__client.is_business_date_time(date_time, scope, code, **kwargs)

   def is_business_date_time_with_http_info(self, date_time: Any, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] IsBusinessDateTime: Check whether a DateTime is a "Business DateTime"  # noqa: E501

A Business DateTime is defined as a point in time that:      * Does not represent a day that overlaps with the calendars WeekendMask      * If the calendar is a "Holiday Calendar" Does not overlap with any dates in the calendar      * If the calendar is a "TradingHours Calendar" Does overlap with a date in the calendar                All dates specified must be UTC and the upper bound of a calendar is not inclusive   e.g. From: 2020-12-25-00-00-00        To: 2020-12-26-00-00-00  IsBusinessDay(2020-12-26-00-00-00) == false  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.is_business_date_time_with_http_info(date_time, scope, code, async_req=True)
>>> result = thread.get()

:param date_time: DateTime to check - This DateTime must be UTC (required)
:type date_time: datetime
:param scope: Scope of the calendar (required)
:type scope: str
:param code: Code of the calendar (required)
:type code: str
:param as_at: AsAt for the request
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (IsBusinessDayResponse, int, HTTPHeaderDict)"""
        return self.__client.is_business_date_time_with_http_info(date_time, scope, code, **kwargs)

   def list_calendars(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCalendars: List Calendars  # noqa: E501

List calendars at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_calendars(async_req=True)
>>> result = thread.get()

:param as_at: The AsAt datetime at which to retrieve the calendars
:type as_at: datetime
:param page: The pagination token to use to continue listing calendars from a previous call to list calendars.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param property_keys: A list of property keys from the "Calendar" domain to decorate onto the calendar,               These take the format {domain}/{scope}/{code} e.g. "Calendar/System/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCalendar"""
        return self.__client.list_calendars(**kwargs)

   def list_calendars_in_scope(self, scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCalendarsInScope: List all calenders in a specified scope  # noqa: E501

List calendars in a Scope at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_calendars_in_scope(scope, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendars (required)
:type scope: str
:param as_at: The AsAt datetime at which to retrieve the calendars
:type as_at: datetime
:param page: The pagination token to use to continue listing calendars from a previous call to list calendars.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param property_keys: A list of property keys from the "Calendar" domain to decorate onto the calendar,               These take the format {domain}/{scope}/{code} e.g. "Calendar/System/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCalendar"""
        return self.__client.list_calendars_in_scope(scope, **kwargs)

   def list_calendars_in_scope_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCalendarsInScope: List all calenders in a specified scope  # noqa: E501

List calendars in a Scope at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_calendars_in_scope_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: Scope of the calendars (required)
:type scope: str
:param as_at: The AsAt datetime at which to retrieve the calendars
:type as_at: datetime
:param page: The pagination token to use to continue listing calendars from a previous call to list calendars.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param property_keys: A list of property keys from the "Calendar" domain to decorate onto the calendar,               These take the format {domain}/{scope}/{code} e.g. "Calendar/System/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCalendar, int, HTTPHeaderDict)"""
        return self.__client.list_calendars_in_scope_with_http_info(scope, **kwargs)

   def list_calendars_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCalendars: List Calendars  # noqa: E501

List calendars at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_calendars_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The AsAt datetime at which to retrieve the calendars
:type as_at: datetime
:param page: The pagination token to use to continue listing calendars from a previous call to list calendars.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param property_keys: A list of property keys from the "Calendar" domain to decorate onto the calendar,               These take the format {domain}/{scope}/{code} e.g. "Calendar/System/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCalendar, int, HTTPHeaderDict)"""
        return self.__client.list_calendars_with_http_info(**kwargs)

   def update_calendar(self, scope: Any, code: Any, update_calendar_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateCalendar: Update a calendar  # noqa: E501

Update the calendars WeekendMask, SourceProvider or Properties  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_calendar(scope, code, update_calendar_request, async_req=True)
>>> result = thread.get()

:param scope: Scope of the request (required)
:type scope: str
:param code: Code of the request (required)
:type code: str
:param update_calendar_request: The new state of the calendar (required)
:type update_calendar_request: UpdateCalendarRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Calendar"""
        return self.__client.update_calendar(scope, code, update_calendar_request, **kwargs)

   def update_calendar_with_http_info(self, scope: Any, code: Any, update_calendar_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateCalendar: Update a calendar  # noqa: E501

Update the calendars WeekendMask, SourceProvider or Properties  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_calendar_with_http_info(scope, code, update_calendar_request, async_req=True)
>>> result = thread.get()

:param scope: Scope of the request (required)
:type scope: str
:param code: Code of the request (required)
:type code: str
:param update_calendar_request: The new state of the calendar (required)
:type update_calendar_request: UpdateCalendarRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Calendar, int, HTTPHeaderDict)"""
        return self.__client.update_calendar_with_http_info(scope, code, update_calendar_request, **kwargs)

calendars_api = __CalendarsApiAuthedAndStubbed()

class __ChartOfAccountsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ChartOfAccountsApi)

   def create_chart_of_accounts(self, scope: Any, chart_of_accounts_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateChartOfAccounts: Create a Chart of Accounts  # noqa: E501

Create the given Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_chart_of_accounts(scope, chart_of_accounts_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param chart_of_accounts_request: The definition of the Chart of Accounts. (required)
:type chart_of_accounts_request: ChartOfAccountsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ChartOfAccounts"""
        return self.__client.create_chart_of_accounts(scope, chart_of_accounts_request, **kwargs)

   def create_chart_of_accounts_with_http_info(self, scope: Any, chart_of_accounts_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateChartOfAccounts: Create a Chart of Accounts  # noqa: E501

Create the given Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_chart_of_accounts_with_http_info(scope, chart_of_accounts_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param chart_of_accounts_request: The definition of the Chart of Accounts. (required)
:type chart_of_accounts_request: ChartOfAccountsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ChartOfAccounts, int, HTTPHeaderDict)"""
        return self.__client.create_chart_of_accounts_with_http_info(scope, chart_of_accounts_request, **kwargs)

   def create_cleardown_module(self, scope: Any, code: Any, cleardown_module_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateCleardownModule: Create a Cleardown Module  # noqa: E501

Create the given Cleardown Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_cleardown_module(scope, code, cleardown_module_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_request: The definition of the Cleardown Module. (required)
:type cleardown_module_request: CleardownModuleRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CleardownModuleResponse"""
        return self.__client.create_cleardown_module(scope, code, cleardown_module_request, **kwargs)

   def create_cleardown_module_with_http_info(self, scope: Any, code: Any, cleardown_module_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateCleardownModule: Create a Cleardown Module  # noqa: E501

Create the given Cleardown Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_cleardown_module_with_http_info(scope, code, cleardown_module_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_request: The definition of the Cleardown Module. (required)
:type cleardown_module_request: CleardownModuleRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CleardownModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.create_cleardown_module_with_http_info(scope, code, cleardown_module_request, **kwargs)

   def create_general_ledger_profile(self, scope: Any, code: Any, general_ledger_profile_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateGeneralLedgerProfile: Create a General Ledger Profile.  # noqa: E501

Create the given General Ledger profile.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_general_ledger_profile(scope, code, general_ledger_profile_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. (required)
:type code: str
:param general_ledger_profile_request: The definition of the General Ledger Profile. (required)
:type general_ledger_profile_request: GeneralLedgerProfileRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GeneralLedgerProfileResponse"""
        return self.__client.create_general_ledger_profile(scope, code, general_ledger_profile_request, **kwargs)

   def create_general_ledger_profile_with_http_info(self, scope: Any, code: Any, general_ledger_profile_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateGeneralLedgerProfile: Create a General Ledger Profile.  # noqa: E501

Create the given General Ledger profile.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_general_ledger_profile_with_http_info(scope, code, general_ledger_profile_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. (required)
:type code: str
:param general_ledger_profile_request: The definition of the General Ledger Profile. (required)
:type general_ledger_profile_request: GeneralLedgerProfileRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GeneralLedgerProfileResponse, int, HTTPHeaderDict)"""
        return self.__client.create_general_ledger_profile_with_http_info(scope, code, general_ledger_profile_request, **kwargs)

   def create_posting_module(self, scope: Any, code: Any, posting_module_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreatePostingModule: Create a Posting Module  # noqa: E501

Create the given Posting Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_posting_module(scope, code, posting_module_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_request: The definition of the Posting Module. (required)
:type posting_module_request: PostingModuleRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PostingModuleResponse"""
        return self.__client.create_posting_module(scope, code, posting_module_request, **kwargs)

   def create_posting_module_with_http_info(self, scope: Any, code: Any, posting_module_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreatePostingModule: Create a Posting Module  # noqa: E501

Create the given Posting Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_posting_module_with_http_info(scope, code, posting_module_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_request: The definition of the Posting Module. (required)
:type posting_module_request: PostingModuleRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PostingModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.create_posting_module_with_http_info(scope, code, posting_module_request, **kwargs)

   def delete_accounts(self, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteAccounts: Soft or hard delete multiple accounts  # noqa: E501

Delete one or more account from the Chart of Accounts. Soft deletion marks the account as inactive  While the Hard deletion is deleting the account.  The maximum number of accounts that this method can delete per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_accounts(scope, code, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies              the Chart of Accounts. (required)
:type code: str
:param request_body: The codes of the accounts to delete. (required)
:type request_body: list[str]
:param delete_mode: The delete mode to use (defaults to 'Soft').
:type delete_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeleteAccountsResponse"""
        return self.__client.delete_accounts(scope, code, request_body, **kwargs)

   def delete_accounts_with_http_info(self, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteAccounts: Soft or hard delete multiple accounts  # noqa: E501

Delete one or more account from the Chart of Accounts. Soft deletion marks the account as inactive  While the Hard deletion is deleting the account.  The maximum number of accounts that this method can delete per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_accounts_with_http_info(scope, code, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies              the Chart of Accounts. (required)
:type code: str
:param request_body: The codes of the accounts to delete. (required)
:type request_body: list[str]
:param delete_mode: The delete mode to use (defaults to 'Soft').
:type delete_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeleteAccountsResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_accounts_with_http_info(scope, code, request_body, **kwargs)

   def delete_chart_of_accounts(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteChartOfAccounts: Delete a Chart of Accounts  # noqa: E501

Delete the given Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_chart_of_accounts(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts to be deleted. (required)
:type scope: str
:param code: The code of the Chart of Accounts to be deleted. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_chart_of_accounts(scope, code, **kwargs)

   def delete_chart_of_accounts_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteChartOfAccounts: Delete a Chart of Accounts  # noqa: E501

Delete the given Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_chart_of_accounts_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts to be deleted. (required)
:type scope: str
:param code: The code of the Chart of Accounts to be deleted. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_chart_of_accounts_with_http_info(scope, code, **kwargs)

   def delete_cleardown_module(self, scope: Any, code: Any, cleardown_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteCleardownModule: Delete a Cleardown Module.  # noqa: E501

Delete the given Cleardown Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_cleardown_module(scope, code, cleardown_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module to be deleted. (required)
:type cleardown_module_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_cleardown_module(scope, code, cleardown_module_code, **kwargs)

   def delete_cleardown_module_with_http_info(self, scope: Any, code: Any, cleardown_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteCleardownModule: Delete a Cleardown Module.  # noqa: E501

Delete the given Cleardown Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_cleardown_module_with_http_info(scope, code, cleardown_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module to be deleted. (required)
:type cleardown_module_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_cleardown_module_with_http_info(scope, code, cleardown_module_code, **kwargs)

   def delete_general_ledger_profile(self, scope: Any, code: Any, general_ledger_profile_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteGeneralLedgerProfile: Delete a General Ledger Profile.  # noqa: E501

Delete the given General Ledger Profile.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_general_ledger_profile(scope, code, general_ledger_profile_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts for the General Ledger Profile. (required)
:type scope: str
:param code: The code of the Chart of Accounts for the General Ledger Profile. (required)
:type code: str
:param general_ledger_profile_code: The Code of the General Ledger Profile. (required)
:type general_ledger_profile_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_general_ledger_profile(scope, code, general_ledger_profile_code, **kwargs)

   def delete_general_ledger_profile_with_http_info(self, scope: Any, code: Any, general_ledger_profile_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteGeneralLedgerProfile: Delete a General Ledger Profile.  # noqa: E501

Delete the given General Ledger Profile.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_general_ledger_profile_with_http_info(scope, code, general_ledger_profile_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts for the General Ledger Profile. (required)
:type scope: str
:param code: The code of the Chart of Accounts for the General Ledger Profile. (required)
:type code: str
:param general_ledger_profile_code: The Code of the General Ledger Profile. (required)
:type general_ledger_profile_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_general_ledger_profile_with_http_info(scope, code, general_ledger_profile_code, **kwargs)

   def delete_posting_module(self, scope: Any, code: Any, posting_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeletePostingModule: Delete a Posting Module.  # noqa: E501

Delete the given Posting Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_posting_module(scope, code, posting_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module to be deleted. (required)
:type posting_module_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_posting_module(scope, code, posting_module_code, **kwargs)

   def delete_posting_module_with_http_info(self, scope: Any, code: Any, posting_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeletePostingModule: Delete a Posting Module.  # noqa: E501

Delete the given Posting Module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_posting_module_with_http_info(scope, code, posting_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module to be deleted. (required)
:type posting_module_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_posting_module_with_http_info(scope, code, posting_module_code, **kwargs)

   def get_account(self, scope: Any, code: Any, account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAccount: Get Account  # noqa: E501

Retrieve the definition of a particular Account which is part of a Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_account(scope, code, account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param account_code: The code of the Account. (required)
:type account_code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Account properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Account definition. Defaults to returning the latest version of the Account definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Account' domain to decorate onto the Account.              These must take the format {domain}/{scope}/{code}, for example 'Account/Manager/Id'. If not provided will return all the entitled properties for that Account.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Account"""
        return self.__client.get_account(scope, code, account_code, **kwargs)

   def get_account_with_http_info(self, scope: Any, code: Any, account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAccount: Get Account  # noqa: E501

Retrieve the definition of a particular Account which is part of a Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_account_with_http_info(scope, code, account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param account_code: The code of the Account. (required)
:type account_code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Account properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Account definition. Defaults to returning the latest version of the Account definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Account' domain to decorate onto the Account.              These must take the format {domain}/{scope}/{code}, for example 'Account/Manager/Id'. If not provided will return all the entitled properties for that Account.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Account, int, HTTPHeaderDict)"""
        return self.__client.get_account_with_http_info(scope, code, account_code, **kwargs)

   def get_chart_of_accounts(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetChartOfAccounts: Get ChartOfAccounts  # noqa: E501

Retrieve the definition of a particular Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_chart_of_accounts(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Chart of Accounts properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Chart of Accounts definition. Defaults to returning the latest version of the Chart of Accounts definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'ChartOfAccounts' domain to decorate onto the Chart of Accounts.              These must take the format {domain}/{scope}/{code}, for example 'ChartOfAccounts/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ChartOfAccounts"""
        return self.__client.get_chart_of_accounts(scope, code, **kwargs)

   def get_chart_of_accounts_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetChartOfAccounts: Get ChartOfAccounts  # noqa: E501

Retrieve the definition of a particular Chart of Accounts.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_chart_of_accounts_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Chart of Accounts properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Chart of Accounts definition. Defaults to returning the latest version of the Chart of Accounts definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'ChartOfAccounts' domain to decorate onto the Chart of Accounts.              These must take the format {domain}/{scope}/{code}, for example 'ChartOfAccounts/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ChartOfAccounts, int, HTTPHeaderDict)"""
        return self.__client.get_chart_of_accounts_with_http_info(scope, code, **kwargs)

   def get_cleardown_module(self, scope: Any, code: Any, cleardown_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetCleardownModule: Get a Cleardown Module  # noqa: E501

Retrieve the definition of a Cleardown Module complete with its rules.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_cleardown_module(scope, code, cleardown_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module. (required)
:type cleardown_module_code: str
:param as_at: The asAt datetime at which to retrieve the Cleardown Module. Defaults to return the latest version of the Cleardown Module if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CleardownModuleResponse"""
        return self.__client.get_cleardown_module(scope, code, cleardown_module_code, **kwargs)

   def get_cleardown_module_with_http_info(self, scope: Any, code: Any, cleardown_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetCleardownModule: Get a Cleardown Module  # noqa: E501

Retrieve the definition of a Cleardown Module complete with its rules.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_cleardown_module_with_http_info(scope, code, cleardown_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module. (required)
:type cleardown_module_code: str
:param as_at: The asAt datetime at which to retrieve the Cleardown Module. Defaults to return the latest version of the Cleardown Module if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CleardownModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.get_cleardown_module_with_http_info(scope, code, cleardown_module_code, **kwargs)

   def get_general_ledger_profile(self, scope: Any, code: Any, general_ledger_profile_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetGeneralLedgerProfile: Get a General Ledger Profile.  # noqa: E501

Get the given General Ledger Profile.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_general_ledger_profile(scope, code, general_ledger_profile_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts for the General Ledger Profile. (required)
:type scope: str
:param code: The code of the Chart of Accounts for the General Ledger Profile. (required)
:type code: str
:param general_ledger_profile_code: The General Ledger Profile Code of the General Ledger Profile. (required)
:type general_ledger_profile_code: str
:param as_at: The asAt datetime at which to retrieve the General Ledger Profile. Defaults to return the latest version of the General Ledger Profile if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GeneralLedgerProfileResponse"""
        return self.__client.get_general_ledger_profile(scope, code, general_ledger_profile_code, **kwargs)

   def get_general_ledger_profile_with_http_info(self, scope: Any, code: Any, general_ledger_profile_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetGeneralLedgerProfile: Get a General Ledger Profile.  # noqa: E501

Get the given General Ledger Profile.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_general_ledger_profile_with_http_info(scope, code, general_ledger_profile_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts for the General Ledger Profile. (required)
:type scope: str
:param code: The code of the Chart of Accounts for the General Ledger Profile. (required)
:type code: str
:param general_ledger_profile_code: The General Ledger Profile Code of the General Ledger Profile. (required)
:type general_ledger_profile_code: str
:param as_at: The asAt datetime at which to retrieve the General Ledger Profile. Defaults to return the latest version of the General Ledger Profile if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GeneralLedgerProfileResponse, int, HTTPHeaderDict)"""
        return self.__client.get_general_ledger_profile_with_http_info(scope, code, general_ledger_profile_code, **kwargs)

   def get_posting_module(self, scope: Any, code: Any, posting_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPostingModule: Get a Posting Module  # noqa: E501

Retrieve the definition of a Posting Module complete with its rules.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_posting_module(scope, code, posting_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module. (required)
:type posting_module_code: str
:param as_at: The asAt datetime at which to retrieve the Posting Module. Defaults to return the latest version of the Posting Module if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PostingModuleResponse"""
        return self.__client.get_posting_module(scope, code, posting_module_code, **kwargs)

   def get_posting_module_with_http_info(self, scope: Any, code: Any, posting_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPostingModule: Get a Posting Module  # noqa: E501

Retrieve the definition of a Posting Module complete with its rules.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_posting_module_with_http_info(scope, code, posting_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module. (required)
:type posting_module_code: str
:param as_at: The asAt datetime at which to retrieve the Posting Module. Defaults to return the latest version of the Posting Module if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PostingModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.get_posting_module_with_http_info(scope, code, posting_module_code, **kwargs)

   def list_accounts(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListAccounts: List Accounts  # noqa: E501

List the accounts in a Chart of Accounts  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_accounts(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies              the Chart of Accounts. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties decorated on Accounts. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Accounts. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing charts of accounts; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Account type, specify "code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'Account' domain to decorate onto the Account.              These must have the format {domain}/{scope}/{code}, for example 'Account/system/Name'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfAccount"""
        return self.__client.list_accounts(scope, code, **kwargs)

   def list_accounts_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListAccounts: List Accounts  # noqa: E501

List the accounts in a Chart of Accounts  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_accounts_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies              the Chart of Accounts. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties decorated on Accounts. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Accounts. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing charts of accounts; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Account type, specify "code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'Account' domain to decorate onto the Account.              These must have the format {domain}/{scope}/{code}, for example 'Account/system/Name'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfAccount, int, HTTPHeaderDict)"""
        return self.__client.list_accounts_with_http_info(scope, code, **kwargs)

   def list_charts_of_accounts(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListChartsOfAccounts: List Charts of Accounts  # noqa: E501

List all the Charts of Accounts matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_charts_of_accounts(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Chart Of Accounts. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the charts of accounts. Defaults to returning the latest version              of each Chart of Accounts if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing charts of accounts; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Chart of Accounts type, specify "id.Code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'ChartOfAccounts' domain to decorate onto each Chart of Accounts.              These must take the format {domain}/{scope}/{code}, for example 'ChartOfAccounts/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfChartOfAccounts"""
        return self.__client.list_charts_of_accounts(**kwargs)

   def list_charts_of_accounts_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListChartsOfAccounts: List Charts of Accounts  # noqa: E501

List all the Charts of Accounts matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_charts_of_accounts_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Chart Of Accounts. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the charts of accounts. Defaults to returning the latest version              of each Chart of Accounts if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing charts of accounts; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Chart of Accounts type, specify "id.Code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'ChartOfAccounts' domain to decorate onto each Chart of Accounts.              These must take the format {domain}/{scope}/{code}, for example 'ChartOfAccounts/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfChartOfAccounts, int, HTTPHeaderDict)"""
        return self.__client.list_charts_of_accounts_with_http_info(**kwargs)

   def list_cleardown_module_rules(self, scope: Any, code: Any, cleardown_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListCleardownModuleRules: List Cleardown Module Rules  # noqa: E501

List the Rules in a Cleardown Module  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cleardown_module_rules(scope, code, cleardown_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the cleardown module. (required)
:type cleardown_module_code: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing cleardown module rules; this              value is returned from the previous call. If a pagination token is provided, the filter              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the rule id, specify "ruleId eq 'rule 1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCleardownModuleRule"""
        return self.__client.list_cleardown_module_rules(scope, code, cleardown_module_code, **kwargs)

   def list_cleardown_module_rules_with_http_info(self, scope: Any, code: Any, cleardown_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListCleardownModuleRules: List Cleardown Module Rules  # noqa: E501

List the Rules in a Cleardown Module  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cleardown_module_rules_with_http_info(scope, code, cleardown_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the cleardown module. (required)
:type cleardown_module_code: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing cleardown module rules; this              value is returned from the previous call. If a pagination token is provided, the filter              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the rule id, specify "ruleId eq 'rule 1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCleardownModuleRule, int, HTTPHeaderDict)"""
        return self.__client.list_cleardown_module_rules_with_http_info(scope, code, cleardown_module_code, **kwargs)

   def list_cleardown_modules(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListCleardownModules: List Cleardown Modules  # noqa: E501

List all the Cleardown Modules matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cleardown_modules(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param as_at: The asAt datetime at which to list the Cleardown Module. Defaults to returning the latest version              of each Cleardown Module if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Cleardown Modules; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Cleardown Module status, specify "status eq 'Active'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCleardownModuleResponse"""
        return self.__client.list_cleardown_modules(scope, code, **kwargs)

   def list_cleardown_modules_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListCleardownModules: List Cleardown Modules  # noqa: E501

List all the Cleardown Modules matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cleardown_modules_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param as_at: The asAt datetime at which to list the Cleardown Module. Defaults to returning the latest version              of each Cleardown Module if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Cleardown Modules; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Cleardown Module status, specify "status eq 'Active'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCleardownModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.list_cleardown_modules_with_http_info(scope, code, **kwargs)

   def list_general_ledger_profiles(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListGeneralLedgerProfiles: List General Ledger Profiles.  # noqa: E501

List all the General Ledger profiles matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_general_ledger_profiles(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts (required)
:type scope: str
:param code: The code of the Chart of Accounts (required)
:type code: str
:param as_at: The asAt datetime at which to list the General Ledger Profiles. Defaults to returning the latest version of each General Ledger Profile if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing General Ledger Profiles; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the General Ledger profiles type, specify "type eq 'PeriodBoundary'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfGeneralLedgerProfileResponse"""
        return self.__client.list_general_ledger_profiles(scope, code, **kwargs)

   def list_general_ledger_profiles_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListGeneralLedgerProfiles: List General Ledger Profiles.  # noqa: E501

List all the General Ledger profiles matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_general_ledger_profiles_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts (required)
:type scope: str
:param code: The code of the Chart of Accounts (required)
:type code: str
:param as_at: The asAt datetime at which to list the General Ledger Profiles. Defaults to returning the latest version of each General Ledger Profile if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing General Ledger Profiles; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the General Ledger profiles type, specify "type eq 'PeriodBoundary'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfGeneralLedgerProfileResponse, int, HTTPHeaderDict)"""
        return self.__client.list_general_ledger_profiles_with_http_info(scope, code, **kwargs)

   def list_posting_module_rules(self, scope: Any, code: Any, posting_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListPostingModuleRules: List Posting Module Rules  # noqa: E501

List the Rules in a Posting Module  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_posting_module_rules(scope, code, posting_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the posting module. (required)
:type posting_module_code: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing posting module rules; this              value is returned from the previous call. If a pagination token is provided, the filter              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the rule id, specify "ruleId eq 'rule 1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPostingModuleRule"""
        return self.__client.list_posting_module_rules(scope, code, posting_module_code, **kwargs)

   def list_posting_module_rules_with_http_info(self, scope: Any, code: Any, posting_module_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListPostingModuleRules: List Posting Module Rules  # noqa: E501

List the Rules in a Posting Module  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_posting_module_rules_with_http_info(scope, code, posting_module_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the posting module. (required)
:type posting_module_code: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing posting module rules; this              value is returned from the previous call. If a pagination token is provided, the filter              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the rule id, specify "ruleId eq 'rule 1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPostingModuleRule, int, HTTPHeaderDict)"""
        return self.__client.list_posting_module_rules_with_http_info(scope, code, posting_module_code, **kwargs)

   def list_posting_modules(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListPostingModules: List Posting Modules  # noqa: E501

List all the Posting Modules matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_posting_modules(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param as_at: The asAt datetime at which to list the Posting Module. Defaults to returning the latest version              of each Posting Module if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Posting Modules; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Posting Module status, specify "status eq 'Active'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPostingModuleResponse"""
        return self.__client.list_posting_modules(scope, code, **kwargs)

   def list_posting_modules_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListPostingModules: List Posting Modules  # noqa: E501

List all the Posting Modules matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_posting_modules_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param as_at: The asAt datetime at which to list the Posting Module. Defaults to returning the latest version              of each Posting Module if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Posting Modules; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Posting Module status, specify "status eq 'Active'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPostingModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.list_posting_modules_with_http_info(scope, code, **kwargs)

   def set_cleardown_module_details(self, scope: Any, code: Any, cleardown_module_code: Any, cleardown_module_details: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetCleardownModuleDetails: Set the details of a Cleardown Module  # noqa: E501

Update the given Cleardown Module details.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_cleardown_module_details(scope, code, cleardown_module_code, cleardown_module_details, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module to be updated. (required)
:type cleardown_module_code: str
:param cleardown_module_details: The new details for the Cleardown Module. (required)
:type cleardown_module_details: CleardownModuleDetails
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CleardownModuleResponse"""
        return self.__client.set_cleardown_module_details(scope, code, cleardown_module_code, cleardown_module_details, **kwargs)

   def set_cleardown_module_details_with_http_info(self, scope: Any, code: Any, cleardown_module_code: Any, cleardown_module_details: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetCleardownModuleDetails: Set the details of a Cleardown Module  # noqa: E501

Update the given Cleardown Module details.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_cleardown_module_details_with_http_info(scope, code, cleardown_module_code, cleardown_module_details, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module to be updated. (required)
:type cleardown_module_code: str
:param cleardown_module_details: The new details for the Cleardown Module. (required)
:type cleardown_module_details: CleardownModuleDetails
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CleardownModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.set_cleardown_module_details_with_http_info(scope, code, cleardown_module_code, cleardown_module_details, **kwargs)

   def set_cleardown_module_rules(self, scope: Any, code: Any, cleardown_module_code: Any, cleardown_module_rule: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetCleardownModuleRules: Set the rules of a Cleardown Module  # noqa: E501

Set the given Cleardown Modules rules, this will replace the existing set of rules for the cleardown module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_cleardown_module_rules(scope, code, cleardown_module_code, cleardown_module_rule, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module to be updated. (required)
:type cleardown_module_code: str
:param cleardown_module_rule: The new rule set for the Cleardown Module. (required)
:type cleardown_module_rule: list[CleardownModuleRule]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CleardownModuleRulesUpdatedResponse"""
        return self.__client.set_cleardown_module_rules(scope, code, cleardown_module_code, cleardown_module_rule, **kwargs)

   def set_cleardown_module_rules_with_http_info(self, scope: Any, code: Any, cleardown_module_code: Any, cleardown_module_rule: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetCleardownModuleRules: Set the rules of a Cleardown Module  # noqa: E501

Set the given Cleardown Modules rules, this will replace the existing set of rules for the cleardown module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_cleardown_module_rules_with_http_info(scope, code, cleardown_module_code, cleardown_module_rule, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param cleardown_module_code: The code of the Cleardown Module to be updated. (required)
:type cleardown_module_code: str
:param cleardown_module_rule: The new rule set for the Cleardown Module. (required)
:type cleardown_module_rule: list[CleardownModuleRule]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CleardownModuleRulesUpdatedResponse, int, HTTPHeaderDict)"""
        return self.__client.set_cleardown_module_rules_with_http_info(scope, code, cleardown_module_code, cleardown_module_rule, **kwargs)

   def set_general_ledger_profile_mappings(self, scope: Any, code: Any, general_ledger_profile_code: Any, general_ledger_profile_mapping: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetGeneralLedgerProfileMappings: Sets the General Ledger Profile Mappings.  # noqa: E501

Update the given General Ledger profile Mappings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_general_ledger_profile_mappings(scope, code, general_ledger_profile_code, general_ledger_profile_mapping, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. (required)
:type code: str
:param general_ledger_profile_code: The code of the General Ledger Profile (required)
:type general_ledger_profile_code: str
:param general_ledger_profile_mapping: The updated General Ledger Profile Mappings, the previous mappings will be wholly replaced with this data. Mappings will be evaluated in the order they are provided. (required)
:type general_ledger_profile_mapping: list[GeneralLedgerProfileMapping]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GeneralLedgerProfileResponse"""
        return self.__client.set_general_ledger_profile_mappings(scope, code, general_ledger_profile_code, general_ledger_profile_mapping, **kwargs)

   def set_general_ledger_profile_mappings_with_http_info(self, scope: Any, code: Any, general_ledger_profile_code: Any, general_ledger_profile_mapping: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetGeneralLedgerProfileMappings: Sets the General Ledger Profile Mappings.  # noqa: E501

Update the given General Ledger profile Mappings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_general_ledger_profile_mappings_with_http_info(scope, code, general_ledger_profile_code, general_ledger_profile_mapping, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. (required)
:type code: str
:param general_ledger_profile_code: The code of the General Ledger Profile (required)
:type general_ledger_profile_code: str
:param general_ledger_profile_mapping: The updated General Ledger Profile Mappings, the previous mappings will be wholly replaced with this data. Mappings will be evaluated in the order they are provided. (required)
:type general_ledger_profile_mapping: list[GeneralLedgerProfileMapping]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GeneralLedgerProfileResponse, int, HTTPHeaderDict)"""
        return self.__client.set_general_ledger_profile_mappings_with_http_info(scope, code, general_ledger_profile_code, general_ledger_profile_mapping, **kwargs)

   def set_posting_module_details(self, scope: Any, code: Any, posting_module_code: Any, posting_module_details: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetPostingModuleDetails: Set the details of a Posting Module  # noqa: E501

Update the given Posting Module details.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_posting_module_details(scope, code, posting_module_code, posting_module_details, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module to be updated. (required)
:type posting_module_code: str
:param posting_module_details: The new details for the Posting Module. (required)
:type posting_module_details: PostingModuleDetails
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PostingModuleResponse"""
        return self.__client.set_posting_module_details(scope, code, posting_module_code, posting_module_details, **kwargs)

   def set_posting_module_details_with_http_info(self, scope: Any, code: Any, posting_module_code: Any, posting_module_details: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetPostingModuleDetails: Set the details of a Posting Module  # noqa: E501

Update the given Posting Module details.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_posting_module_details_with_http_info(scope, code, posting_module_code, posting_module_details, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module to be updated. (required)
:type posting_module_code: str
:param posting_module_details: The new details for the Posting Module. (required)
:type posting_module_details: PostingModuleDetails
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PostingModuleResponse, int, HTTPHeaderDict)"""
        return self.__client.set_posting_module_details_with_http_info(scope, code, posting_module_code, posting_module_details, **kwargs)

   def set_posting_module_rules(self, scope: Any, code: Any, posting_module_code: Any, posting_module_rule: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetPostingModuleRules: Set the rules of a Posting Module  # noqa: E501

Set the given Posting Modules rules, this will replace the existing set of rules for the posting module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_posting_module_rules(scope, code, posting_module_code, posting_module_rule, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module to be updated. (required)
:type posting_module_code: str
:param posting_module_rule: The new rule set for the Posting Module. (required)
:type posting_module_rule: list[PostingModuleRule]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PostingModuleRulesUpdatedResponse"""
        return self.__client.set_posting_module_rules(scope, code, posting_module_code, posting_module_rule, **kwargs)

   def set_posting_module_rules_with_http_info(self, scope: Any, code: Any, posting_module_code: Any, posting_module_rule: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetPostingModuleRules: Set the rules of a Posting Module  # noqa: E501

Set the given Posting Modules rules, this will replace the existing set of rules for the posting module.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_posting_module_rules_with_http_info(scope, code, posting_module_code, posting_module_rule, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param posting_module_code: The code of the Posting Module to be updated. (required)
:type posting_module_code: str
:param posting_module_rule: The new rule set for the Posting Module. (required)
:type posting_module_rule: list[PostingModuleRule]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PostingModuleRulesUpdatedResponse, int, HTTPHeaderDict)"""
        return self.__client.set_posting_module_rules_with_http_info(scope, code, posting_module_code, posting_module_rule, **kwargs)

   def upsert_account_properties(self, scope: Any, code: Any, account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAccountProperties: Upsert account properties  # noqa: E501

Update or insert one or more properties onto a single account. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'Account'.                Upserting a property that exists for an account, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_account_properties(scope, code, account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Chart of Accounts to update or insert the properties onto. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param account_code: The unique ID of the account to create or update properties for. (required)
:type account_code: str
:param request_body: The properties to be updated or inserted onto the chart of account. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "Account/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AccountProperties"""
        return self.__client.upsert_account_properties(scope, code, account_code, **kwargs)

   def upsert_account_properties_with_http_info(self, scope: Any, code: Any, account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAccountProperties: Upsert account properties  # noqa: E501

Update or insert one or more properties onto a single account. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'Account'.                Upserting a property that exists for an account, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_account_properties_with_http_info(scope, code, account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Chart of Accounts to update or insert the properties onto. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param account_code: The unique ID of the account to create or update properties for. (required)
:type account_code: str
:param request_body: The properties to be updated or inserted onto the chart of account. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "Account/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AccountProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_account_properties_with_http_info(scope, code, account_code, **kwargs)

   def upsert_accounts(self, scope: Any, code: Any, account: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAccounts: Upsert Accounts  # noqa: E501

Create or update accounts in the Chart of Accounts. An account will be updated  if it already exists and created if it does not.  The maximum number of accounts that this method can upsert per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_accounts(scope, code, account, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies              the Chart of Accounts. (required)
:type code: str
:param account: A list of accounts to be created or updated. (required)
:type account: list[Account]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AccountsUpsertResponse"""
        return self.__client.upsert_accounts(scope, code, account, **kwargs)

   def upsert_accounts_with_http_info(self, scope: Any, code: Any, account: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertAccounts: Upsert Accounts  # noqa: E501

Create or update accounts in the Chart of Accounts. An account will be updated  if it already exists and created if it does not.  The maximum number of accounts that this method can upsert per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_accounts_with_http_info(scope, code, account, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts. (required)
:type scope: str
:param code: The code of the Chart of Accounts. Together with the scope this uniquely identifies              the Chart of Accounts. (required)
:type code: str
:param account: A list of accounts to be created or updated. (required)
:type account: list[Account]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AccountsUpsertResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_accounts_with_http_info(scope, code, account, **kwargs)

   def upsert_chart_of_accounts_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertChartOfAccountsProperties: Upsert Chart of Accounts properties  # noqa: E501

Update or insert one or more properties onto a single Chart of Accounts. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'ChartOfAccounts'.                Upserting a property that exists for a Chart of Accounts, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_chart_of_accounts_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Chart of Accounts to update or insert the properties onto. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the chart of account. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "ChartOfAccounts/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ChartOfAccountsProperties"""
        return self.__client.upsert_chart_of_accounts_properties(scope, code, **kwargs)

   def upsert_chart_of_accounts_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertChartOfAccountsProperties: Upsert Chart of Accounts properties  # noqa: E501

Update or insert one or more properties onto a single Chart of Accounts. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'ChartOfAccounts'.                Upserting a property that exists for a Chart of Accounts, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_chart_of_accounts_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Chart of Accounts to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Chart of Accounts to update or insert the properties onto. Together with the scope this uniquely identifies the Chart of Accounts. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the chart of account. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "ChartOfAccounts/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ChartOfAccountsProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_chart_of_accounts_properties_with_http_info(scope, code, **kwargs)

chart_of_accounts_api = __ChartOfAccountsApiAuthedAndStubbed()

class __ComplexMarketDataApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ComplexMarketDataApi)

   def delete_complex_market_data(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteComplexMarketData: Delete one or more items of complex market data, assuming they are present.  # noqa: E501

Delete one or more specified complex market data items from a single scope. Each item is identified by a unique id which includes  information about its type as well as the exact effective datetime (to the microsecond) at which it entered the system (became valid).                In the request each complex market data item must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted  complex market data items, as well as those that failed.  For the failures a reason will be provided explaining why the it could not be deleted.                It is important to always check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_complex_market_data(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the complex market data to delete. (required)
:type scope: str
:param request_body: The complex market data Ids to delete, each keyed by a unique correlation id. (required)
:type request_body: dict(str, ComplexMarketDataId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulStructuredDataResponse"""
        return self.__client.delete_complex_market_data(scope, request_body, **kwargs)

   def delete_complex_market_data_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteComplexMarketData: Delete one or more items of complex market data, assuming they are present.  # noqa: E501

Delete one or more specified complex market data items from a single scope. Each item is identified by a unique id which includes  information about its type as well as the exact effective datetime (to the microsecond) at which it entered the system (became valid).                In the request each complex market data item must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted  complex market data items, as well as those that failed.  For the failures a reason will be provided explaining why the it could not be deleted.                It is important to always check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_complex_market_data_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the complex market data to delete. (required)
:type scope: str
:param request_body: The complex market data Ids to delete, each keyed by a unique correlation id. (required)
:type request_body: dict(str, ComplexMarketDataId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_complex_market_data_with_http_info(scope, request_body, **kwargs)

   def get_complex_market_data(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplexMarketData: Get complex market data  # noqa: E501

Get one or more items of complex market data from a single scope.                Each item can be identified by its time invariant complex market data identifier.                For each id LUSID will return the most recent matched item with respect to the provided (or default) effective datetime.                An optional maximum age range window can be specified which defines how far back to look back for data from the specified effective datetime.  LUSID will return the most recent item within this window.                In the request each complex market data id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each item in the response.                The response will return three collections. One, the successfully retrieved complex market data. Two, those that had a  valid identifier but could not be found. Three, those that failed because LUSID could not construct a valid identifier from the request.                For the ids that failed to resolve or could not be found a reason will be provided explaining why that is the case.                It is important to always check the failed and not found sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_complex_market_data(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the complex market data to retrieve. (required)
:type scope: str
:param request_body: The time invariant set of complex data identifiers to retrieve the data for. These need to be               keyed by a unique correlation id allowing the retrieved item to be identified in the response. (required)
:type request_body: dict(str, ComplexMarketDataId)
:param effective_at: The effective datetime at which to retrieve the complex market data.               Defaults to the current LUSID system datetime if not specified.               Must match the Effective at of each ComplexMarketDataId given in the request body.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the complex market data. Defaults to return the latest version if not specified.
:type as_at: datetime
:param max_age: The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime to generate a effective datetime window inside which a complex market data item must exist to be retrieved.
:type max_age: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetComplexMarketDataResponse"""
        return self.__client.get_complex_market_data(scope, request_body, **kwargs)

   def get_complex_market_data_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplexMarketData: Get complex market data  # noqa: E501

Get one or more items of complex market data from a single scope.                Each item can be identified by its time invariant complex market data identifier.                For each id LUSID will return the most recent matched item with respect to the provided (or default) effective datetime.                An optional maximum age range window can be specified which defines how far back to look back for data from the specified effective datetime.  LUSID will return the most recent item within this window.                In the request each complex market data id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each item in the response.                The response will return three collections. One, the successfully retrieved complex market data. Two, those that had a  valid identifier but could not be found. Three, those that failed because LUSID could not construct a valid identifier from the request.                For the ids that failed to resolve or could not be found a reason will be provided explaining why that is the case.                It is important to always check the failed and not found sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_complex_market_data_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the complex market data to retrieve. (required)
:type scope: str
:param request_body: The time invariant set of complex data identifiers to retrieve the data for. These need to be               keyed by a unique correlation id allowing the retrieved item to be identified in the response. (required)
:type request_body: dict(str, ComplexMarketDataId)
:param effective_at: The effective datetime at which to retrieve the complex market data.               Defaults to the current LUSID system datetime if not specified.               Must match the Effective at of each ComplexMarketDataId given in the request body.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the complex market data. Defaults to return the latest version if not specified.
:type as_at: datetime
:param max_age: The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime to generate a effective datetime window inside which a complex market data item must exist to be retrieved.
:type max_age: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetComplexMarketDataResponse, int, HTTPHeaderDict)"""
        return self.__client.get_complex_market_data_with_http_info(scope, request_body, **kwargs)

   def list_complex_market_data(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListComplexMarketData: List the set of ComplexMarketData  # noqa: E501

List the set of ComplexMarketData at the specified date/time,  along with the scope the data was stored in and its identifier in that scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_complex_market_data(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the ComplexMarketData. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfListComplexMarketDataWithMetaDataResponse"""
        return self.__client.list_complex_market_data(**kwargs)

   def list_complex_market_data_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListComplexMarketData: List the set of ComplexMarketData  # noqa: E501

List the set of ComplexMarketData at the specified date/time,  along with the scope the data was stored in and its identifier in that scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_complex_market_data_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the ComplexMarketData. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfListComplexMarketDataWithMetaDataResponse, int, HTTPHeaderDict)"""
        return self.__client.list_complex_market_data_with_http_info(**kwargs)

   def upsert_complex_market_data(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertComplexMarketData: Upsert a set of complex market data items. This creates or updates the data in Lusid.  # noqa: E501

Update or insert one or more complex market data items in a single scope. An item will be updated if it already exists  and inserted if it does not.                In the request each complex market data item must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each complex market data in the response.                The response will return both the collection of successfully updated or inserted complex market data, as well as those that failed.  For the failures a reason will be provided explaining why the item could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_complex_market_data(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the complex market data. (required)
:type scope: str
:param request_body: The set of complex market data items to update or insert keyed by a unique correlation id. (required)
:type request_body: dict(str, UpsertComplexMarketDataRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertStructuredDataResponse"""
        return self.__client.upsert_complex_market_data(scope, request_body, **kwargs)

   def upsert_complex_market_data_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertComplexMarketData: Upsert a set of complex market data items. This creates or updates the data in Lusid.  # noqa: E501

Update or insert one or more complex market data items in a single scope. An item will be updated if it already exists  and inserted if it does not.                In the request each complex market data item must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each complex market data in the response.                The response will return both the collection of successfully updated or inserted complex market data, as well as those that failed.  For the failures a reason will be provided explaining why the item could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_complex_market_data_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the complex market data. (required)
:type scope: str
:param request_body: The set of complex market data items to update or insert keyed by a unique correlation id. (required)
:type request_body: dict(str, UpsertComplexMarketDataRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_complex_market_data_with_http_info(scope, request_body, **kwargs)

complex_market_data_api = __ComplexMarketDataApiAuthedAndStubbed()

class __ComplianceApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ComplianceApi)

   def delete_compliance_rule(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteComplianceRule: Delete compliance rule.  # noqa: E501

Use this endpoint to delete a compliance rule. The rule will be recoverable for asat times earlier than the  delete time, but will otherwise appear to have never existed.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_compliance_rule(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule's scope. (required)
:type scope: str
:param code: The compliance rule's code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_compliance_rule(scope, code, **kwargs)

   def delete_compliance_rule_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteComplianceRule: Delete compliance rule.  # noqa: E501

Use this endpoint to delete a compliance rule. The rule will be recoverable for asat times earlier than the  delete time, but will otherwise appear to have never existed.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_compliance_rule_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule's scope. (required)
:type scope: str
:param code: The compliance rule's code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_compliance_rule_with_http_info(scope, code, **kwargs)

   def get_compliance_rule(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplianceRule: Get compliance rule.  # noqa: E501

Use this endpoint to retrieve a single compliance rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_compliance_rule(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule's scope. (required)
:type scope: str
:param code: The compliance rule's code. (required)
:type code: str
:param as_at: Optional. Asat time for query.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Compliance' domain to decorate onto the rule.              These must take the format {domain}/{scope}/{code}, for example 'Compliance/live/UCITS'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRuleResponse"""
        return self.__client.get_compliance_rule(scope, code, **kwargs)

   def get_compliance_rule_result(self, run_scope: Any, run_code: Any, rule_scope: Any, rule_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplianceRuleResult: Get detailed results for a specific rule within a compliance run.  # noqa: E501

Specify a run scope and code from a previously run compliance check, and the scope and code of a rule within that run, to get detailed results for that rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_compliance_rule_result(run_scope, run_code, rule_scope, rule_code, async_req=True)
>>> result = thread.get()

:param run_scope: Required: Run Scope. (required)
:type run_scope: str
:param run_code: Required: Run Code. (required)
:type run_code: str
:param rule_scope: Required: Rule Scope. (required)
:type rule_scope: str
:param rule_code: Required: Rule Code. (required)
:type rule_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRuleResultV2"""
        return self.__client.get_compliance_rule_result(run_scope, run_code, rule_scope, rule_code, **kwargs)

   def get_compliance_rule_result_with_http_info(self, run_scope: Any, run_code: Any, rule_scope: Any, rule_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplianceRuleResult: Get detailed results for a specific rule within a compliance run.  # noqa: E501

Specify a run scope and code from a previously run compliance check, and the scope and code of a rule within that run, to get detailed results for that rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_compliance_rule_result_with_http_info(run_scope, run_code, rule_scope, rule_code, async_req=True)
>>> result = thread.get()

:param run_scope: Required: Run Scope. (required)
:type run_scope: str
:param run_code: Required: Run Code. (required)
:type run_code: str
:param rule_scope: Required: Rule Scope. (required)
:type rule_scope: str
:param rule_code: Required: Rule Code. (required)
:type rule_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRuleResultV2, int, HTTPHeaderDict)"""
        return self.__client.get_compliance_rule_result_with_http_info(run_scope, run_code, rule_scope, rule_code, **kwargs)

   def get_compliance_rule_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplianceRule: Get compliance rule.  # noqa: E501

Use this endpoint to retrieve a single compliance rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_compliance_rule_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule's scope. (required)
:type scope: str
:param code: The compliance rule's code. (required)
:type code: str
:param as_at: Optional. Asat time for query.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Compliance' domain to decorate onto the rule.              These must take the format {domain}/{scope}/{code}, for example 'Compliance/live/UCITS'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRuleResponse, int, HTTPHeaderDict)"""
        return self.__client.get_compliance_rule_with_http_info(scope, code, **kwargs)

   def get_compliance_template(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplianceTemplate: Get the requested compliance template.  # noqa: E501

Use this endpoint to fetch a specific compliance template.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_compliance_template(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of TemplateID (required)
:type scope: str
:param code: Code of TemplateID (required)
:type code: str
:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceTemplate"""
        return self.__client.get_compliance_template(scope, code, **kwargs)

   def get_compliance_template_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetComplianceTemplate: Get the requested compliance template.  # noqa: E501

Use this endpoint to fetch a specific compliance template.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_compliance_template_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of TemplateID (required)
:type scope: str
:param code: Code of TemplateID (required)
:type code: str
:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceTemplate, int, HTTPHeaderDict)"""
        return self.__client.get_compliance_template_with_http_info(scope, code, **kwargs)

   def get_decorated_compliance_run_summary(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetDecoratedComplianceRunSummary: Get decorated summary results for a specific compliance run.  # noqa: E501

Specify a run scope and code from a previously run compliance check to get an overview of result details.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_decorated_compliance_run_summary(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Required: Run Scope. (required)
:type scope: str
:param code: Required: Run Code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DecoratedComplianceRunSummary"""
        return self.__client.get_decorated_compliance_run_summary(scope, code, **kwargs)

   def get_decorated_compliance_run_summary_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetDecoratedComplianceRunSummary: Get decorated summary results for a specific compliance run.  # noqa: E501

Specify a run scope and code from a previously run compliance check to get an overview of result details.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_decorated_compliance_run_summary_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Required: Run Scope. (required)
:type scope: str
:param code: Required: Run Code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DecoratedComplianceRunSummary, int, HTTPHeaderDict)"""
        return self.__client.get_decorated_compliance_run_summary_with_http_info(scope, code, **kwargs)

   def list_compliance_rules(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListComplianceRules: List compliance rules.  # noqa: E501

Use this endpoint to retrieve all compliance rules, or a subset defined by an optional filter.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_compliance_rules(async_req=True)
>>> result = thread.get()

:param as_at: Optional. Asat time.
:type as_at: datetime
:param page: Optional. Pagination token.
:type page: str
:param limit: Optional. Entries per page.
:type limit: int
:param filter: Optional. Filter.
:type filter: str
:param property_keys: A list of property keys from the 'Compliance' domain to decorate onto each rule.              These must take the format {domain}/{scope}/{code}, for example 'Compliance/live/UCITS'. If not provided will return all the entitled properties for each rule.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfComplianceRuleResponse"""
        return self.__client.list_compliance_rules(**kwargs)

   def list_compliance_rules_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListComplianceRules: List compliance rules.  # noqa: E501

Use this endpoint to retrieve all compliance rules, or a subset defined by an optional filter.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_compliance_rules_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. Asat time.
:type as_at: datetime
:param page: Optional. Pagination token.
:type page: str
:param limit: Optional. Entries per page.
:type limit: int
:param filter: Optional. Filter.
:type filter: str
:param property_keys: A list of property keys from the 'Compliance' domain to decorate onto each rule.              These must take the format {domain}/{scope}/{code}, for example 'Compliance/live/UCITS'. If not provided will return all the entitled properties for each rule.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfComplianceRuleResponse, int, HTTPHeaderDict)"""
        return self.__client.list_compliance_rules_with_http_info(**kwargs)

   def list_compliance_runs(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListComplianceRuns: List historical compliance run identifiers.  # noqa: E501

Lists RunIds of prior compliance runs, or a subset with a filter.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_compliance_runs(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param page: Optional. The pagination token to use to continue listing compliance runs from a previous call to list compliance runs.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Optional. A list of field names to sort by, each suffixed by "ASC" or "DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfComplianceRunInfoV2"""
        return self.__client.list_compliance_runs(**kwargs)

   def list_compliance_runs_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListComplianceRuns: List historical compliance run identifiers.  # noqa: E501

Lists RunIds of prior compliance runs, or a subset with a filter.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_compliance_runs_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param page: Optional. The pagination token to use to continue listing compliance runs from a previous call to list compliance runs.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Optional. A list of field names to sort by, each suffixed by "ASC" or "DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfComplianceRunInfoV2, int, HTTPHeaderDict)"""
        return self.__client.list_compliance_runs_with_http_info(**kwargs)

   def list_compliance_templates(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListComplianceTemplates: List compliance templates.  # noqa: E501

Use this endpoint to fetch a list of all available compliance template ids, or a subset using a filter.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_compliance_templates(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param page: Optional. The pagination token to use to continue listing compliance runs from a previous call to list compliance runs.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfComplianceTemplate"""
        return self.__client.list_compliance_templates(**kwargs)

   def list_compliance_templates_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListComplianceTemplates: List compliance templates.  # noqa: E501

Use this endpoint to fetch a list of all available compliance template ids, or a subset using a filter.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_compliance_templates_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param page: Optional. The pagination token to use to continue listing compliance runs from a previous call to list compliance runs.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfComplianceTemplate, int, HTTPHeaderDict)"""
        return self.__client.list_compliance_templates_with_http_info(**kwargs)

   def run_compliance(self, run_scope: Any, rule_scope: Any, is_pre_trade: Any, recipe_id_scope: Any, recipe_id_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] RunCompliance: Run a compliance check.  # noqa: E501

Use this endpoint to run a compliance check using rules from a specific scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.run_compliance(run_scope, rule_scope, is_pre_trade, recipe_id_scope, recipe_id_code, async_req=True)
>>> result = thread.get()

:param run_scope: Required: Scope to save the run results in. (required)
:type run_scope: str
:param rule_scope: Required: Scope from which to select rules to be run. (required)
:type rule_scope: str
:param is_pre_trade: Required: Boolean flag indicating if a run should be PreTrade (Including orders). For post-trade only, set to false (required)
:type is_pre_trade: bool
:param recipe_id_scope: Required: the scope of the recipe to be used (required)
:type recipe_id_scope: str
:param recipe_id_code: Required: The code of the recipe to be used. If left blank, the default recipe will be used. (required)
:type recipe_id_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRunInfoV2"""
        return self.__client.run_compliance(run_scope, rule_scope, is_pre_trade, recipe_id_scope, recipe_id_code, **kwargs)

   def run_compliance_with_http_info(self, run_scope: Any, rule_scope: Any, is_pre_trade: Any, recipe_id_scope: Any, recipe_id_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] RunCompliance: Run a compliance check.  # noqa: E501

Use this endpoint to run a compliance check using rules from a specific scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.run_compliance_with_http_info(run_scope, rule_scope, is_pre_trade, recipe_id_scope, recipe_id_code, async_req=True)
>>> result = thread.get()

:param run_scope: Required: Scope to save the run results in. (required)
:type run_scope: str
:param rule_scope: Required: Scope from which to select rules to be run. (required)
:type rule_scope: str
:param is_pre_trade: Required: Boolean flag indicating if a run should be PreTrade (Including orders). For post-trade only, set to false (required)
:type is_pre_trade: bool
:param recipe_id_scope: Required: the scope of the recipe to be used (required)
:type recipe_id_scope: str
:param recipe_id_code: Required: The code of the recipe to be used. If left blank, the default recipe will be used. (required)
:type recipe_id_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRunInfoV2, int, HTTPHeaderDict)"""
        return self.__client.run_compliance_with_http_info(run_scope, rule_scope, is_pre_trade, recipe_id_scope, recipe_id_code, **kwargs)

   def upsert_compliance_rule(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertComplianceRule: Upsert a compliance rule.  # noqa: E501

Use this endpoint to upsert a single compliance rule. The template and variation specified must already  exist, as must the portfolio group. The parameters passed must match those required by the template variation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_compliance_rule(async_req=True)
>>> result = thread.get()

:param upsert_compliance_rule_request:
:type upsert_compliance_rule_request: UpsertComplianceRuleRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRuleResponse"""
        return self.__client.upsert_compliance_rule(**kwargs)

   def upsert_compliance_rule_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertComplianceRule: Upsert a compliance rule.  # noqa: E501

Use this endpoint to upsert a single compliance rule. The template and variation specified must already  exist, as must the portfolio group. The parameters passed must match those required by the template variation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_compliance_rule_with_http_info(async_req=True)
>>> result = thread.get()

:param upsert_compliance_rule_request:
:type upsert_compliance_rule_request: UpsertComplianceRuleRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRuleResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_compliance_rule_with_http_info(**kwargs)

   def upsert_compliance_run_summary(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertComplianceRunSummary: Upsert a compliance run summary.  # noqa: E501

Use this endpoint to upsert a compliance run result summary.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_compliance_run_summary(async_req=True)
>>> result = thread.get()

:param upsert_compliance_run_summary_request:
:type upsert_compliance_run_summary_request: UpsertComplianceRunSummaryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertComplianceRunSummaryResult"""
        return self.__client.upsert_compliance_run_summary(**kwargs)

   def upsert_compliance_run_summary_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertComplianceRunSummary: Upsert a compliance run summary.  # noqa: E501

Use this endpoint to upsert a compliance run result summary.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_compliance_run_summary_with_http_info(async_req=True)
>>> result = thread.get()

:param upsert_compliance_run_summary_request:
:type upsert_compliance_run_summary_request: UpsertComplianceRunSummaryRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertComplianceRunSummaryResult, int, HTTPHeaderDict)"""
        return self.__client.upsert_compliance_run_summary_with_http_info(**kwargs)

compliance_api = __ComplianceApiAuthedAndStubbed()

class __ConfigurationRecipeApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ConfigurationRecipeApi)

   def delete_configuration_recipe(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """DeleteConfigurationRecipe: Delete a Configuration Recipe, assuming that it is present.  # noqa: E501

Delete the specified Configuration Recipe from a single scope.                The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_configuration_recipe(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Configuration Recipe to delete. (required)
:type scope: str
:param code: The Configuration Recipe to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_configuration_recipe(scope, code, **kwargs)

   def delete_configuration_recipe_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """DeleteConfigurationRecipe: Delete a Configuration Recipe, assuming that it is present.  # noqa: E501

Delete the specified Configuration Recipe from a single scope.                The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_configuration_recipe_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Configuration Recipe to delete. (required)
:type scope: str
:param code: The Configuration Recipe to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_configuration_recipe_with_http_info(scope, code, **kwargs)

   def delete_recipe_composer(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteRecipeComposer: Delete a Recipe Composer, assuming that it is present.  # noqa: E501

Delete the specified Recipe Composer from a single scope.                The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_recipe_composer(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Recipe Composer to delete. (required)
:type scope: str
:param code: The Recipe Composer to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_recipe_composer(scope, code, **kwargs)

   def delete_recipe_composer_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteRecipeComposer: Delete a Recipe Composer, assuming that it is present.  # noqa: E501

Delete the specified Recipe Composer from a single scope.                The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_recipe_composer_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Recipe Composer to delete. (required)
:type scope: str
:param code: The Recipe Composer to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_recipe_composer_with_http_info(scope, code, **kwargs)

   def get_configuration_recipe(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetConfigurationRecipe: Get Configuration Recipe  # noqa: E501

Get a Configuration Recipe from a single scope.                The response will return either the recipe that has been stored, or a failure explaining why the request was unsuccessful.                It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_configuration_recipe(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Configuration Recipe to retrieve. (required)
:type scope: str
:param code: The name of the recipe to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Configuration Recipe. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetRecipeResponse"""
        return self.__client.get_configuration_recipe(scope, code, **kwargs)

   def get_configuration_recipe_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetConfigurationRecipe: Get Configuration Recipe  # noqa: E501

Get a Configuration Recipe from a single scope.                The response will return either the recipe that has been stored, or a failure explaining why the request was unsuccessful.                It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_configuration_recipe_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Configuration Recipe to retrieve. (required)
:type scope: str
:param code: The name of the recipe to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Configuration Recipe. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetRecipeResponse, int, HTTPHeaderDict)"""
        return self.__client.get_configuration_recipe_with_http_info(scope, code, **kwargs)

   def get_derived_recipe(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetDerivedRecipe: Get Configuration Recipe either from the store or expanded from a Recipe Composer.  # noqa: E501

If scope-code is referring to a Configuration Recipe it is returned, if it refers to Recipe Composer, it is expanded into a Configuration Recipe and returned.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_derived_recipe(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Configuration Recipe or Recipe Composer to return. (required)
:type scope: str
:param code: The code of the Configuration Recipe or Recipe Composer to return. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Configuration Recipe. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetRecipeResponse"""
        return self.__client.get_derived_recipe(scope, code, **kwargs)

   def get_derived_recipe_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetDerivedRecipe: Get Configuration Recipe either from the store or expanded from a Recipe Composer.  # noqa: E501

If scope-code is referring to a Configuration Recipe it is returned, if it refers to Recipe Composer, it is expanded into a Configuration Recipe and returned.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_derived_recipe_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Configuration Recipe or Recipe Composer to return. (required)
:type scope: str
:param code: The code of the Configuration Recipe or Recipe Composer to return. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Configuration Recipe. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetRecipeResponse, int, HTTPHeaderDict)"""
        return self.__client.get_derived_recipe_with_http_info(scope, code, **kwargs)

   def get_recipe_composer(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetRecipeComposer: Get Recipe Composer  # noqa: E501

Get a Recipe Composer from a single scope.                The response will return either the recipe composer that has been stored, or a failure explaining why the request was unsuccessful.                It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_recipe_composer(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Recipe Composer to retrieve. (required)
:type scope: str
:param code: The name of the Recipe Composer to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Recipe Composer. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetRecipeComposerResponse"""
        return self.__client.get_recipe_composer(scope, code, **kwargs)

   def get_recipe_composer_resolved_inline(self, upsert_recipe_composer_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetRecipeComposerResolvedInline: Given a Recipe Composer, this endpoint expands into a Configuration Recipe without persistence. Primarily used for testing purposes.  # noqa: E501

Resolves an inline recipe composer into a ConfigurationRecipe.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_recipe_composer_resolved_inline(upsert_recipe_composer_request, async_req=True)
>>> result = thread.get()

:param upsert_recipe_composer_request: Recipe composer used to expand into the Configuration Recipe. (required)
:type upsert_recipe_composer_request: UpsertRecipeComposerRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetRecipeResponse"""
        return self.__client.get_recipe_composer_resolved_inline(upsert_recipe_composer_request, **kwargs)

   def get_recipe_composer_resolved_inline_with_http_info(self, upsert_recipe_composer_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetRecipeComposerResolvedInline: Given a Recipe Composer, this endpoint expands into a Configuration Recipe without persistence. Primarily used for testing purposes.  # noqa: E501

Resolves an inline recipe composer into a ConfigurationRecipe.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_recipe_composer_resolved_inline_with_http_info(upsert_recipe_composer_request, async_req=True)
>>> result = thread.get()

:param upsert_recipe_composer_request: Recipe composer used to expand into the Configuration Recipe. (required)
:type upsert_recipe_composer_request: UpsertRecipeComposerRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetRecipeResponse, int, HTTPHeaderDict)"""
        return self.__client.get_recipe_composer_resolved_inline_with_http_info(upsert_recipe_composer_request, **kwargs)

   def get_recipe_composer_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetRecipeComposer: Get Recipe Composer  # noqa: E501

Get a Recipe Composer from a single scope.                The response will return either the recipe composer that has been stored, or a failure explaining why the request was unsuccessful.                It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_recipe_composer_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Recipe Composer to retrieve. (required)
:type scope: str
:param code: The name of the Recipe Composer to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Recipe Composer. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetRecipeComposerResponse, int, HTTPHeaderDict)"""
        return self.__client.get_recipe_composer_with_http_info(scope, code, **kwargs)

   def list_configuration_recipes(self, **kwargs) -> 'Any':
        """ListConfigurationRecipes: List the set of Configuration Recipes  # noqa: E501

List the set of configuration recipes at the specified date/time and scope. Note this only returns recipes stored directly and does not include any recipes expanded from recipe composers.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_configuration_recipes(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Configuration Recipes. Defaults to latest if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetRecipeResponse"""
        return self.__client.list_configuration_recipes(**kwargs)

   def list_configuration_recipes_with_http_info(self, **kwargs) -> 'Any':
        """ListConfigurationRecipes: List the set of Configuration Recipes  # noqa: E501

List the set of configuration recipes at the specified date/time and scope. Note this only returns recipes stored directly and does not include any recipes expanded from recipe composers.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_configuration_recipes_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Configuration Recipes. Defaults to latest if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetRecipeResponse, int, HTTPHeaderDict)"""
        return self.__client.list_configuration_recipes_with_http_info(**kwargs)

   def list_derived_recipes(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListDerivedRecipes: List the complete set of all Configuration Recipes, both from the configuration recipe store and also from expanded recipe composers.  # noqa: E501

This endpoints returns a union of the output of ListConfigurationRecipes and the resolved Recipe Composers from the ListRecipeComposers endpoints.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_derived_recipes(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Configuration Recipes. Defaults to latest if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set, note this functionality is not yet enabled for this endpoint.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetRecipeResponse"""
        return self.__client.list_derived_recipes(**kwargs)

   def list_derived_recipes_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListDerivedRecipes: List the complete set of all Configuration Recipes, both from the configuration recipe store and also from expanded recipe composers.  # noqa: E501

This endpoints returns a union of the output of ListConfigurationRecipes and the resolved Recipe Composers from the ListRecipeComposers endpoints.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_derived_recipes_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Configuration Recipes. Defaults to latest if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set, note this functionality is not yet enabled for this endpoint.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetRecipeResponse, int, HTTPHeaderDict)"""
        return self.__client.list_derived_recipes_with_http_info(**kwargs)

   def list_recipe_composers(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListRecipeComposers: List the set of Recipe Composers  # noqa: E501

List the set of Recipe Composers at the specified date/time and scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_recipe_composers(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Recipes Composers. Defaults to latest if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set, note this functionality is not yet enabled for this endpoint.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetRecipeComposerResponse"""
        return self.__client.list_recipe_composers(**kwargs)

   def list_recipe_composers_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListRecipeComposers: List the set of Recipe Composers  # noqa: E501

List the set of Recipe Composers at the specified date/time and scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_recipe_composers_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Recipes Composers. Defaults to latest if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set, note this functionality is not yet enabled for this endpoint.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetRecipeComposerResponse, int, HTTPHeaderDict)"""
        return self.__client.list_recipe_composers_with_http_info(**kwargs)

   def upsert_configuration_recipe(self, upsert_recipe_request: Any, **kwargs) -> 'Any':
        """UpsertConfigurationRecipe: Upsert a Configuration Recipe. This creates or updates the data in Lusid.  # noqa: E501

Update or insert one Configuration Recipe in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Configuration Recipe or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_configuration_recipe(upsert_recipe_request, async_req=True)
>>> result = thread.get()

:param upsert_recipe_request: The Configuration Recipe to update or insert (required)
:type upsert_recipe_request: UpsertRecipeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_configuration_recipe(upsert_recipe_request, **kwargs)

   def upsert_configuration_recipe_with_http_info(self, upsert_recipe_request: Any, **kwargs) -> 'Any':
        """UpsertConfigurationRecipe: Upsert a Configuration Recipe. This creates or updates the data in Lusid.  # noqa: E501

Update or insert one Configuration Recipe in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Configuration Recipe or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_configuration_recipe_with_http_info(upsert_recipe_request, async_req=True)
>>> result = thread.get()

:param upsert_recipe_request: The Configuration Recipe to update or insert (required)
:type upsert_recipe_request: UpsertRecipeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_configuration_recipe_with_http_info(upsert_recipe_request, **kwargs)

   def upsert_recipe_composer(self, upsert_recipe_composer_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertRecipeComposer: Upsert a Recipe Composer. This creates or updates the data in Lusid.  # noqa: E501

Update or insert one Recipe Composer in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Recipe Composer or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_recipe_composer(upsert_recipe_composer_request, async_req=True)
>>> result = thread.get()

:param upsert_recipe_composer_request: The Recipe Composer to update or insert (required)
:type upsert_recipe_composer_request: UpsertRecipeComposerRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_recipe_composer(upsert_recipe_composer_request, **kwargs)

   def upsert_recipe_composer_with_http_info(self, upsert_recipe_composer_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertRecipeComposer: Upsert a Recipe Composer. This creates or updates the data in Lusid.  # noqa: E501

Update or insert one Recipe Composer in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Recipe Composer or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_recipe_composer_with_http_info(upsert_recipe_composer_request, async_req=True)
>>> result = thread.get()

:param upsert_recipe_composer_request: The Recipe Composer to update or insert (required)
:type upsert_recipe_composer_request: UpsertRecipeComposerRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_recipe_composer_with_http_info(upsert_recipe_composer_request, **kwargs)

configuration_recipe_api = __ConfigurationRecipeApiAuthedAndStubbed()

class __ConventionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ConventionsApi)

   def delete_cds_flow_conventions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteCdsFlowConventions: Delete the CDS Flow Conventions of given scope and code, assuming that it is present.  # noqa: E501

Delete the specified CDS Flow Conventions from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.  It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_cds_flow_conventions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the CDS Flow Conventions to delete. (required)
:type scope: str
:param code: The CDS Flow Conventions to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_cds_flow_conventions(scope, code, **kwargs)

   def delete_cds_flow_conventions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteCdsFlowConventions: Delete the CDS Flow Conventions of given scope and code, assuming that it is present.  # noqa: E501

Delete the specified CDS Flow Conventions from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.  It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_cds_flow_conventions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the CDS Flow Conventions to delete. (required)
:type scope: str
:param code: The CDS Flow Conventions to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_cds_flow_conventions_with_http_info(scope, code, **kwargs)

   def delete_flow_conventions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteFlowConventions: Delete the Flow Conventions of given scope and code, assuming that it is present.  # noqa: E501

Delete the specified conventions from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.  It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_flow_conventions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Flow Conventions to delete. (required)
:type scope: str
:param code: The Flow Conventions to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_flow_conventions(scope, code, **kwargs)

   def delete_flow_conventions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteFlowConventions: Delete the Flow Conventions of given scope and code, assuming that it is present.  # noqa: E501

Delete the specified conventions from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.  It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_flow_conventions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Flow Conventions to delete. (required)
:type scope: str
:param code: The Flow Conventions to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_flow_conventions_with_http_info(scope, code, **kwargs)

   def delete_index_convention(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteIndexConvention: Delete the Index Convention of given scope and code, assuming that it is present.  # noqa: E501

Delete the specified Index Convention from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.  It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_index_convention(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Index Convention to delete. (required)
:type scope: str
:param code: The Index Convention to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_index_convention(scope, code, **kwargs)

   def delete_index_convention_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteIndexConvention: Delete the Index Convention of given scope and code, assuming that it is present.  # noqa: E501

Delete the specified Index Convention from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.  It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_index_convention_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Index Convention to delete. (required)
:type scope: str
:param code: The Index Convention to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_index_convention_with_http_info(scope, code, **kwargs)

   def get_cds_flow_conventions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetCdsFlowConventions: Get CDS Flow Conventions  # noqa: E501

Get a CDS Flow Conventions from a single scope.  The response will return either the conventions that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_cds_flow_conventions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the CDS Flow Conventions to retrieve. (required)
:type scope: str
:param code: The name of the CDS Flow Conventions to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the CDS Flow Conventions. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetCdsFlowConventionsResponse"""
        return self.__client.get_cds_flow_conventions(scope, code, **kwargs)

   def get_cds_flow_conventions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetCdsFlowConventions: Get CDS Flow Conventions  # noqa: E501

Get a CDS Flow Conventions from a single scope.  The response will return either the conventions that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_cds_flow_conventions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the CDS Flow Conventions to retrieve. (required)
:type scope: str
:param code: The name of the CDS Flow Conventions to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the CDS Flow Conventions. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetCdsFlowConventionsResponse, int, HTTPHeaderDict)"""
        return self.__client.get_cds_flow_conventions_with_http_info(scope, code, **kwargs)

   def get_flow_conventions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetFlowConventions: Get Flow Conventions  # noqa: E501

Get a Flow Conventions from a single scope.  The response will return either the conventions that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_flow_conventions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Flow Conventions to retrieve. (required)
:type scope: str
:param code: The name of the Flow Conventions to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Flow Conventions. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetFlowConventionsResponse"""
        return self.__client.get_flow_conventions(scope, code, **kwargs)

   def get_flow_conventions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetFlowConventions: Get Flow Conventions  # noqa: E501

Get a Flow Conventions from a single scope.  The response will return either the conventions that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_flow_conventions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Flow Conventions to retrieve. (required)
:type scope: str
:param code: The name of the Flow Conventions to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Flow Conventions. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetFlowConventionsResponse, int, HTTPHeaderDict)"""
        return self.__client.get_flow_conventions_with_http_info(scope, code, **kwargs)

   def get_index_convention(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetIndexConvention: Get Index Convention  # noqa: E501

Get a Index Convention from a single scope.  The response will return either the conventions that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_index_convention(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Index Convention to retrieve. (required)
:type scope: str
:param code: The name of the Index Convention to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Index Convention. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetIndexConventionResponse"""
        return self.__client.get_index_convention(scope, code, **kwargs)

   def get_index_convention_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetIndexConvention: Get Index Convention  # noqa: E501

Get a Index Convention from a single scope.  The response will return either the conventions that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_index_convention_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Index Convention to retrieve. (required)
:type scope: str
:param code: The name of the Index Convention to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Index Convention. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetIndexConventionResponse, int, HTTPHeaderDict)"""
        return self.__client.get_index_convention_with_http_info(scope, code, **kwargs)

   def list_cds_flow_conventions(self, **kwargs) -> 'Any':
        """[BETA] ListCdsFlowConventions: List the set of CDS Flow Conventions  # noqa: E501

List the set of CDS Flow Conventions at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cds_flow_conventions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the conventions. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetCdsFlowConventionsResponse"""
        return self.__client.list_cds_flow_conventions(**kwargs)

   def list_cds_flow_conventions_with_http_info(self, **kwargs) -> 'Any':
        """[BETA] ListCdsFlowConventions: List the set of CDS Flow Conventions  # noqa: E501

List the set of CDS Flow Conventions at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cds_flow_conventions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the conventions. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetCdsFlowConventionsResponse, int, HTTPHeaderDict)"""
        return self.__client.list_cds_flow_conventions_with_http_info(**kwargs)

   def list_flow_conventions(self, **kwargs) -> 'Any':
        """[BETA] ListFlowConventions: List the set of Flow Conventions  # noqa: E501

List the set of Flow Conventions at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_flow_conventions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the conventions. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetFlowConventionsResponse"""
        return self.__client.list_flow_conventions(**kwargs)

   def list_flow_conventions_with_http_info(self, **kwargs) -> 'Any':
        """[BETA] ListFlowConventions: List the set of Flow Conventions  # noqa: E501

List the set of Flow Conventions at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_flow_conventions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the conventions. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetFlowConventionsResponse, int, HTTPHeaderDict)"""
        return self.__client.list_flow_conventions_with_http_info(**kwargs)

   def list_index_convention(self, **kwargs) -> 'Any':
        """[BETA] ListIndexConvention: List the set of Index Conventions  # noqa: E501

List the set of Index Conventions at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_index_convention(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the conventions. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetIndexConventionResponse"""
        return self.__client.list_index_convention(**kwargs)

   def list_index_convention_with_http_info(self, **kwargs) -> 'Any':
        """[BETA] ListIndexConvention: List the set of Index Conventions  # noqa: E501

List the set of Index Conventions at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_index_convention_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the conventions. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetIndexConventionResponse, int, HTTPHeaderDict)"""
        return self.__client.list_index_convention_with_http_info(**kwargs)

   def upsert_cds_flow_conventions(self, upsert_cds_flow_conventions_request: Any, **kwargs) -> 'Any':
        """[BETA] UpsertCdsFlowConventions: Upsert a set of CDS Flow Conventions. This creates or updates the data in Lusid.  # noqa: E501

Update or insert CDS Flow Conventions in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted CDS Flow Conventions or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_cds_flow_conventions(upsert_cds_flow_conventions_request, async_req=True)
>>> result = thread.get()

:param upsert_cds_flow_conventions_request: The CDS Flow Conventions to update or insert (required)
:type upsert_cds_flow_conventions_request: UpsertCdsFlowConventionsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_cds_flow_conventions(upsert_cds_flow_conventions_request, **kwargs)

   def upsert_cds_flow_conventions_with_http_info(self, upsert_cds_flow_conventions_request: Any, **kwargs) -> 'Any':
        """[BETA] UpsertCdsFlowConventions: Upsert a set of CDS Flow Conventions. This creates or updates the data in Lusid.  # noqa: E501

Update or insert CDS Flow Conventions in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted CDS Flow Conventions or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_cds_flow_conventions_with_http_info(upsert_cds_flow_conventions_request, async_req=True)
>>> result = thread.get()

:param upsert_cds_flow_conventions_request: The CDS Flow Conventions to update or insert (required)
:type upsert_cds_flow_conventions_request: UpsertCdsFlowConventionsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_cds_flow_conventions_with_http_info(upsert_cds_flow_conventions_request, **kwargs)

   def upsert_flow_conventions(self, upsert_flow_conventions_request: Any, **kwargs) -> 'Any':
        """[BETA] UpsertFlowConventions: Upsert Flow Conventions. This creates or updates the data in Lusid.  # noqa: E501

Update or insert Flow Conventions in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Flow Conventions or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_flow_conventions(upsert_flow_conventions_request, async_req=True)
>>> result = thread.get()

:param upsert_flow_conventions_request: The Flow Conventions to update or insert (required)
:type upsert_flow_conventions_request: UpsertFlowConventionsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_flow_conventions(upsert_flow_conventions_request, **kwargs)

   def upsert_flow_conventions_with_http_info(self, upsert_flow_conventions_request: Any, **kwargs) -> 'Any':
        """[BETA] UpsertFlowConventions: Upsert Flow Conventions. This creates or updates the data in Lusid.  # noqa: E501

Update or insert Flow Conventions in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Flow Conventions or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_flow_conventions_with_http_info(upsert_flow_conventions_request, async_req=True)
>>> result = thread.get()

:param upsert_flow_conventions_request: The Flow Conventions to update or insert (required)
:type upsert_flow_conventions_request: UpsertFlowConventionsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_flow_conventions_with_http_info(upsert_flow_conventions_request, **kwargs)

   def upsert_index_convention(self, upsert_index_convention_request: Any, **kwargs) -> 'Any':
        """[BETA] UpsertIndexConvention: Upsert a set of Index Convention. This creates or updates the data in Lusid.  # noqa: E501

Update or insert Index Convention in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Index Convention or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_index_convention(upsert_index_convention_request, async_req=True)
>>> result = thread.get()

:param upsert_index_convention_request: The Index Conventions to update or insert (required)
:type upsert_index_convention_request: UpsertIndexConventionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_index_convention(upsert_index_convention_request, **kwargs)

   def upsert_index_convention_with_http_info(self, upsert_index_convention_request: Any, **kwargs) -> 'Any':
        """[BETA] UpsertIndexConvention: Upsert a set of Index Convention. This creates or updates the data in Lusid.  # noqa: E501

Update or insert Index Convention in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Index Convention or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_index_convention_with_http_info(upsert_index_convention_request, async_req=True)
>>> result = thread.get()

:param upsert_index_convention_request: The Index Conventions to update or insert (required)
:type upsert_index_convention_request: UpsertIndexConventionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_index_convention_with_http_info(upsert_index_convention_request, **kwargs)

conventions_api = __ConventionsApiAuthedAndStubbed()

class __CorporateActionSourcesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CorporateActionSourcesApi)

   def batch_upsert_corporate_actions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchUpsertCorporateActions: Batch upsert corporate actions (instrument transition events) to corporate action source.  # noqa: E501

Create or update one or more corporate actions in a particular corporate action source. Failures are identified in the body of the response.                If a corporate action is upserted at exactly the same effective datetime as a transaction for the same instrument, the corporate action takes precedence. Depending on the nature of the corporate action, this may mean it affects the transaction.                The maximum number of corporate actions that this method can upsert per request is 10,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_upsert_corporate_actions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of corporate action source (required)
:type scope: str
:param code: The code of the corporate action source (required)
:type code: str
:param upsert_corporate_action_request: The corporate action definitions
:type upsert_corporate_action_request: list[UpsertCorporateActionRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertCorporateActionsResponse"""
        return self.__client.batch_upsert_corporate_actions(scope, code, **kwargs)

   def batch_upsert_corporate_actions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchUpsertCorporateActions: Batch upsert corporate actions (instrument transition events) to corporate action source.  # noqa: E501

Create or update one or more corporate actions in a particular corporate action source. Failures are identified in the body of the response.                If a corporate action is upserted at exactly the same effective datetime as a transaction for the same instrument, the corporate action takes precedence. Depending on the nature of the corporate action, this may mean it affects the transaction.                The maximum number of corporate actions that this method can upsert per request is 10,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_upsert_corporate_actions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of corporate action source (required)
:type scope: str
:param code: The code of the corporate action source (required)
:type code: str
:param upsert_corporate_action_request: The corporate action definitions
:type upsert_corporate_action_request: list[UpsertCorporateActionRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertCorporateActionsResponse, int, HTTPHeaderDict)"""
        return self.__client.batch_upsert_corporate_actions_with_http_info(scope, code, **kwargs)

   def create_corporate_action_source(self, create_corporate_action_source_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCorporateActionSource: Create corporate action source  # noqa: E501

Create a corporate action source.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_corporate_action_source(create_corporate_action_source_request, async_req=True)
>>> result = thread.get()

:param create_corporate_action_source_request: The corporate action source definition (required)
:type create_corporate_action_source_request: CreateCorporateActionSourceRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CorporateActionSource"""
        return self.__client.create_corporate_action_source(create_corporate_action_source_request, **kwargs)

   def create_corporate_action_source_with_http_info(self, create_corporate_action_source_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCorporateActionSource: Create corporate action source  # noqa: E501

Create a corporate action source.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_corporate_action_source_with_http_info(create_corporate_action_source_request, async_req=True)
>>> result = thread.get()

:param create_corporate_action_source_request: The corporate action source definition (required)
:type create_corporate_action_source_request: CreateCorporateActionSourceRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CorporateActionSource, int, HTTPHeaderDict)"""
        return self.__client.create_corporate_action_source_with_http_info(create_corporate_action_source_request, **kwargs)

   def delete_corporate_action_source(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteCorporateActionSource: Delete corporate actions (instrument transition events) from the corporate action source.  # noqa: E501

Deletes a single corporate action source  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_corporate_action_source(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source to be deleted (required)
:type scope: str
:param code: The code of the corporate action source to be deleted (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_corporate_action_source(scope, code, **kwargs)

   def delete_corporate_action_source_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] DeleteCorporateActionSource: Delete corporate actions (instrument transition events) from the corporate action source.  # noqa: E501

Deletes a single corporate action source  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_corporate_action_source_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source to be deleted (required)
:type scope: str
:param code: The code of the corporate action source to be deleted (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_corporate_action_source_with_http_info(scope, code, **kwargs)

   def delete_corporate_actions(self, scope: Any, code: Any, corporate_action_ids: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCorporateActions: Delete corporate actions  # noqa: E501

Delete one or more corporate actions from a particular corporate action source.                The maximum number of corporate actions that this method can delete per request is 1,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_corporate_actions(scope, code, corporate_action_ids, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source (required)
:type scope: str
:param code: The code of the corporate action source (required)
:type code: str
:param corporate_action_ids: The IDs of the corporate actions to delete (required)
:type corporate_action_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_corporate_actions(scope, code, corporate_action_ids, **kwargs)

   def delete_corporate_actions_with_http_info(self, scope: Any, code: Any, corporate_action_ids: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCorporateActions: Delete corporate actions  # noqa: E501

Delete one or more corporate actions from a particular corporate action source.                The maximum number of corporate actions that this method can delete per request is 1,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_corporate_actions_with_http_info(scope, code, corporate_action_ids, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source (required)
:type scope: str
:param code: The code of the corporate action source (required)
:type code: str
:param corporate_action_ids: The IDs of the corporate actions to delete (required)
:type corporate_action_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_corporate_actions_with_http_info(scope, code, corporate_action_ids, **kwargs)

   def delete_instrument_events(self, scope: Any, code: Any, instrument_event_ids: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstrumentEvents: Delete corporate actions (instrument transition events) from the corporate action source.  # noqa: E501

Delete one or more corporate actions from a particular corporate action source.                The maximum number of instrument events that this method can delete per request is 1,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instrument_events(scope, code, instrument_event_ids, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source (required)
:type scope: str
:param code: The code of the corporate action source (required)
:type code: str
:param instrument_event_ids: The IDs of the instrument events to delete (required)
:type instrument_event_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_instrument_events(scope, code, instrument_event_ids, **kwargs)

   def delete_instrument_events_with_http_info(self, scope: Any, code: Any, instrument_event_ids: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstrumentEvents: Delete corporate actions (instrument transition events) from the corporate action source.  # noqa: E501

Delete one or more corporate actions from a particular corporate action source.                The maximum number of instrument events that this method can delete per request is 1,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instrument_events_with_http_info(scope, code, instrument_event_ids, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source (required)
:type scope: str
:param code: The code of the corporate action source (required)
:type code: str
:param instrument_event_ids: The IDs of the instrument events to delete (required)
:type instrument_event_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_instrument_events_with_http_info(scope, code, instrument_event_ids, **kwargs)

   def get_corporate_actions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCorporateActions: List corporate actions (instrument transition events) from the corporate action source.  # noqa: E501

Get corporate actions from a particular corporate action source.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_corporate_actions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source. (required)
:type scope: str
:param code: The code of the corporate action source. (required)
:type code: str
:param from_effective_at: Optional. The start effective date of the data range.
:type from_effective_at: str
:param to_effective_at: Optional. The end effective date of the data range.
:type to_effective_at: str
:param as_at: Optional. The AsAt date of the data.
:type as_at: datetime
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the results to this number.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on the Announcement Date, use "announcementDate eq '2020-03-06'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfCorporateAction"""
        return self.__client.get_corporate_actions(scope, code, **kwargs)

   def get_corporate_actions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCorporateActions: List corporate actions (instrument transition events) from the corporate action source.  # noqa: E501

Get corporate actions from a particular corporate action source.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_corporate_actions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source. (required)
:type scope: str
:param code: The code of the corporate action source. (required)
:type code: str
:param from_effective_at: Optional. The start effective date of the data range.
:type from_effective_at: str
:param to_effective_at: Optional. The end effective date of the data range.
:type to_effective_at: str
:param as_at: Optional. The AsAt date of the data.
:type as_at: datetime
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the results to this number.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on the Announcement Date, use "announcementDate eq '2020-03-06'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfCorporateAction, int, HTTPHeaderDict)"""
        return self.__client.get_corporate_actions_with_http_info(scope, code, **kwargs)

   def get_instrument_events(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentEvents: Get extrinsic instrument events out of a given corporate actions source.  # noqa: E501

Retrieves extrinsic corporate actions out of a corporate actions source  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_events(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source. (required)
:type scope: str
:param code: The code of the corporate action source. (required)
:type code: str
:param as_at: Optional. The AsAt date of the data.
:type as_at: datetime
:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, asAt, filter and limit must not  be modified.
:type page: str
:param filter: Optional. Expression to filter the result set.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfInstrumentEventHolder"""
        return self.__client.get_instrument_events(scope, code, **kwargs)

   def get_instrument_events_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentEvents: Get extrinsic instrument events out of a given corporate actions source.  # noqa: E501

Retrieves extrinsic corporate actions out of a corporate actions source  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_events_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source. (required)
:type scope: str
:param code: The code of the corporate action source. (required)
:type code: str
:param as_at: Optional. The AsAt date of the data.
:type as_at: datetime
:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, asAt, filter and limit must not  be modified.
:type page: str
:param filter: Optional. Expression to filter the result set.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfInstrumentEventHolder, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_events_with_http_info(scope, code, **kwargs)

   def list_corporate_action_sources(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCorporateActionSources: List corporate action sources  # noqa: E501

Gets a list of all corporate action sources  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_corporate_action_sources(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The AsAt date of the data
:type as_at: datetime
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 100 is used.
:type limit: int
:param filter: Optional. Expression to filter the result set. For example, to  filter on the Display Name, use "displayName eq 'string'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, the filter, asAt, and limit must not  be modified.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCorporateActionSource"""
        return self.__client.list_corporate_action_sources(**kwargs)

   def list_corporate_action_sources_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCorporateActionSources: List corporate action sources  # noqa: E501

Gets a list of all corporate action sources  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_corporate_action_sources_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The AsAt date of the data
:type as_at: datetime
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 100 is used.
:type limit: int
:param filter: Optional. Expression to filter the result set. For example, to  filter on the Display Name, use "displayName eq 'string'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, the filter, asAt, and limit must not  be modified.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCorporateActionSource, int, HTTPHeaderDict)"""
        return self.__client.list_corporate_action_sources_with_http_info(**kwargs)

   def upsert_instrument_events(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertInstrumentEvents: Upsert instrument events to the provided corporate actions source.  # noqa: E501

Batch upsert instrument events to corporate action sources.                The maximum number of instrument events that this method can upsert per request is 10,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_instrument_events(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source. (required)
:type scope: str
:param code: The code of the corporate action source. (required)
:type code: str
:param upsert_instrument_event_request: The instrument event definitions.
:type upsert_instrument_event_request: list[UpsertInstrumentEventRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertInstrumentEventsResponse"""
        return self.__client.upsert_instrument_events(scope, code, **kwargs)

   def upsert_instrument_events_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertInstrumentEvents: Upsert instrument events to the provided corporate actions source.  # noqa: E501

Batch upsert instrument events to corporate action sources.                The maximum number of instrument events that this method can upsert per request is 10,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_instrument_events_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the corporate action source. (required)
:type scope: str
:param code: The code of the corporate action source. (required)
:type code: str
:param upsert_instrument_event_request: The instrument event definitions.
:type upsert_instrument_event_request: list[UpsertInstrumentEventRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertInstrumentEventsResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_instrument_events_with_http_info(scope, code, **kwargs)

corporate_action_sources_api = __CorporateActionSourcesApiAuthedAndStubbed()

class __CounterpartiesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CounterpartiesApi)

   def delete_counterparty_agreement(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCounterpartyAgreement: Delete the Counterparty Agreement of given scope and code  # noqa: E501

Delete the specified Counterparty Agreement from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_counterparty_agreement(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Counterparty Agreement to delete. (required)
:type scope: str
:param code: The Counterparty Agreement to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_counterparty_agreement(scope, code, **kwargs)

   def delete_counterparty_agreement_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCounterpartyAgreement: Delete the Counterparty Agreement of given scope and code  # noqa: E501

Delete the specified Counterparty Agreement from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_counterparty_agreement_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Counterparty Agreement to delete. (required)
:type scope: str
:param code: The Counterparty Agreement to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_counterparty_agreement_with_http_info(scope, code, **kwargs)

   def delete_credit_support_annex(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCreditSupportAnnex: Delete the Credit Support Annex of given scope and code  # noqa: E501

Delete the specified Credit Support Annex from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_credit_support_annex(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Credit Support Annex to delete. (required)
:type scope: str
:param code: The Credit Support Annex to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulSingleStructuredDataResponse"""
        return self.__client.delete_credit_support_annex(scope, code, **kwargs)

   def delete_credit_support_annex_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCreditSupportAnnex: Delete the Credit Support Annex of given scope and code  # noqa: E501

Delete the specified Credit Support Annex from a single scope.  The response will return either detail of the deleted item, or an explanation (failure) as to why this did not succeed.                It is important to always check for any unsuccessful response.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_credit_support_annex_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Credit Support Annex to delete. (required)
:type scope: str
:param code: The Credit Support Annex to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_credit_support_annex_with_http_info(scope, code, **kwargs)

   def get_counterparty_agreement(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCounterpartyAgreement: Get Counterparty Agreement  # noqa: E501

Get a Counterparty Agreement from a single scope.  The response will return either the Counterparty Agreement that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_counterparty_agreement(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Counterparty Agreement to retrieve. (required)
:type scope: str
:param code: The name of the Counterparty Agreement to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Counterparty Agreement. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetCounterpartyAgreementResponse"""
        return self.__client.get_counterparty_agreement(scope, code, **kwargs)

   def get_counterparty_agreement_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCounterpartyAgreement: Get Counterparty Agreement  # noqa: E501

Get a Counterparty Agreement from a single scope.  The response will return either the Counterparty Agreement that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_counterparty_agreement_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Counterparty Agreement to retrieve. (required)
:type scope: str
:param code: The name of the Counterparty Agreement to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Counterparty Agreement. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetCounterpartyAgreementResponse, int, HTTPHeaderDict)"""
        return self.__client.get_counterparty_agreement_with_http_info(scope, code, **kwargs)

   def get_credit_support_annex(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCreditSupportAnnex: Get Credit Support Annex  # noqa: E501

Get a Credit Support Annex from a single scope.  The response will return either the Credit Support Annex that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_credit_support_annex(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Credit Support Annex to retrieve. (required)
:type scope: str
:param code: The name of the Credit Support Annex to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Credit Support Annex . Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetCreditSupportAnnexResponse"""
        return self.__client.get_credit_support_annex(scope, code, **kwargs)

   def get_credit_support_annex_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCreditSupportAnnex: Get Credit Support Annex  # noqa: E501

Get a Credit Support Annex from a single scope.  The response will return either the Credit Support Annex that has been stored, or a failure explaining why the request was unsuccessful.  It is important to always check for any unsuccessful requests (failures).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_credit_support_annex_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Credit Support Annex to retrieve. (required)
:type scope: str
:param code: The name of the Credit Support Annex to retrieve the data for. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Credit Support Annex . Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetCreditSupportAnnexResponse, int, HTTPHeaderDict)"""
        return self.__client.get_credit_support_annex_with_http_info(scope, code, **kwargs)

   def list_counterparty_agreements(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCounterpartyAgreements: List the set of Counterparty Agreements  # noqa: E501

List the set of Counterparty Agreements at the specified AsAt date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_counterparty_agreements(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Counterparty Agreements. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetCounterpartyAgreementResponse"""
        return self.__client.list_counterparty_agreements(**kwargs)

   def list_counterparty_agreements_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCounterpartyAgreements: List the set of Counterparty Agreements  # noqa: E501

List the set of Counterparty Agreements at the specified AsAt date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_counterparty_agreements_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Counterparty Agreements. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetCounterpartyAgreementResponse, int, HTTPHeaderDict)"""
        return self.__client.list_counterparty_agreements_with_http_info(**kwargs)

   def list_credit_support_annexes(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCreditSupportAnnexes: List the set of Credit Support Annexes  # noqa: E501

List the set of Credit Support Annexes at the specified AsAt date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_credit_support_annexes(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Credit Support Annexes. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfGetCreditSupportAnnexResponse"""
        return self.__client.list_credit_support_annexes(**kwargs)

   def list_credit_support_annexes_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCreditSupportAnnexes: List the set of Credit Support Annexes  # noqa: E501

List the set of Credit Support Annexes at the specified AsAt date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_credit_support_annexes_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the Credit Support Annexes. Defaults to latest if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfGetCreditSupportAnnexResponse, int, HTTPHeaderDict)"""
        return self.__client.list_credit_support_annexes_with_http_info(**kwargs)

   def upsert_counterparty_agreement(self, upsert_counterparty_agreement_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCounterpartyAgreement: Upsert Counterparty Agreement  # noqa: E501

Update or insert Counterparty Agreement in a single scope. An item will be updated if it already exists and inserted if it does not.                The response will return the successfully updated or inserted Counterparty Agreement or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_counterparty_agreement(upsert_counterparty_agreement_request, async_req=True)
>>> result = thread.get()

:param upsert_counterparty_agreement_request: The Counterparty Agreement to update or insert (required)
:type upsert_counterparty_agreement_request: UpsertCounterpartyAgreementRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_counterparty_agreement(upsert_counterparty_agreement_request, **kwargs)

   def upsert_counterparty_agreement_with_http_info(self, upsert_counterparty_agreement_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCounterpartyAgreement: Upsert Counterparty Agreement  # noqa: E501

Update or insert Counterparty Agreement in a single scope. An item will be updated if it already exists and inserted if it does not.                The response will return the successfully updated or inserted Counterparty Agreement or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_counterparty_agreement_with_http_info(upsert_counterparty_agreement_request, async_req=True)
>>> result = thread.get()

:param upsert_counterparty_agreement_request: The Counterparty Agreement to update or insert (required)
:type upsert_counterparty_agreement_request: UpsertCounterpartyAgreementRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_counterparty_agreement_with_http_info(upsert_counterparty_agreement_request, **kwargs)

   def upsert_credit_support_annex(self, upsert_credit_support_annex_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCreditSupportAnnex: Upsert Credit Support Annex  # noqa: E501

Update or insert Credit Support Annex in a single scope. An item will be updated if it already exists and inserted if it does not.                The response will return the successfully updated or inserted Credit Support Annex or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_credit_support_annex(upsert_credit_support_annex_request, async_req=True)
>>> result = thread.get()

:param upsert_credit_support_annex_request: The Credit Support Annex to update or insert (required)
:type upsert_credit_support_annex_request: UpsertCreditSupportAnnexRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertSingleStructuredDataResponse"""
        return self.__client.upsert_credit_support_annex(upsert_credit_support_annex_request, **kwargs)

   def upsert_credit_support_annex_with_http_info(self, upsert_credit_support_annex_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCreditSupportAnnex: Upsert Credit Support Annex  # noqa: E501

Update or insert Credit Support Annex in a single scope. An item will be updated if it already exists and inserted if it does not.                The response will return the successfully updated or inserted Credit Support Annex or failure message if unsuccessful                It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_credit_support_annex_with_http_info(upsert_credit_support_annex_request, async_req=True)
>>> result = thread.get()

:param upsert_credit_support_annex_request: The Credit Support Annex to update or insert (required)
:type upsert_credit_support_annex_request: UpsertCreditSupportAnnexRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertSingleStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_credit_support_annex_with_http_info(upsert_credit_support_annex_request, **kwargs)

counterparties_api = __CounterpartiesApiAuthedAndStubbed()

class __CustomEntitiesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CustomEntitiesApi)

   def delete_custom_entity(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCustomEntity: Delete a Custom Entity instance.  # noqa: E501

Delete a Custom Entity instance by a specific entity type.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_custom_entity(entity_type, identifier_type, identifier_value, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of Custom Entity to remove. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_custom_entity(entity_type, identifier_type, identifier_value, identifier_scope, **kwargs)

   def delete_custom_entity_access_metadata(self, entity_type: Any, identifier_type: Any, identifier_value: Any, metadata_key: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry  # noqa: E501

Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param metadata_key: Key of the metadata entry to delete. (required)
:type metadata_key: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata.
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata.
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, **kwargs)

   def delete_custom_entity_access_metadata_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, metadata_key: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCustomEntityAccessMetadata: Delete a Custom Entity Access Metadata entry  # noqa: E501

Deletes the Custom Entity Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param metadata_key: Key of the metadata entry to delete. (required)
:type metadata_key: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata.
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata.
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, **kwargs)

   def delete_custom_entity_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteCustomEntity: Delete a Custom Entity instance.  # noqa: E501

Delete a Custom Entity instance by a specific entity type.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_custom_entity_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of Custom Entity to remove. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_custom_entity_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, **kwargs)

   def get_all_custom_entity_access_metadata(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity  # noqa: E501

Get all the Custom Entity access metadata for the specified identifier scope, code and value  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param effective_at: The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.get_all_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, identifier_scope, **kwargs)

   def get_all_custom_entity_access_metadata_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllCustomEntityAccessMetadata: Get all the Access Metadata rules for a Custom Entity  # noqa: E501

Get all the Custom Entity access metadata for the specified identifier scope, code and value  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param effective_at: The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.get_all_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, **kwargs)

   def get_custom_entity(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntity: Get a Custom Entity instance.  # noqa: E501

Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity(entity_type, identifier_type, identifier_value, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of Custom Entity to retrieve. An entityType can be created using the "CreateCustomEntityDefinition" endpoint for CustomEntityDefinitions. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param as_at: The AsAt datetime at which to retrieve the Custom Entity instance.
:type as_at: datetime
:param effective_at: The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityResponse"""
        return self.__client.get_custom_entity(entity_type, identifier_type, identifier_value, identifier_scope, **kwargs)

   def get_custom_entity_access_metadata_by_key(self, entity_type: Any, identifier_type: Any, identifier_value: Any, metadata_key: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity  # noqa: E501

Get Custom Entity access metadata for the specified metadata key  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_access_metadata_by_key(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param effective_at: The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[AccessMetadataValue]"""
        return self.__client.get_custom_entity_access_metadata_by_key(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, **kwargs)

   def get_custom_entity_access_metadata_by_key_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, metadata_key: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Custom Entity  # noqa: E501

Get Custom Entity access metadata for the specified metadata key  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_access_metadata_by_key_with_http_info(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param effective_at: The effective datetime or cut label at which to get the entities. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata. Defaults to returning the latest version of the metadata if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[AccessMetadataValue], int, HTTPHeaderDict)"""
        return self.__client.get_custom_entity_access_metadata_by_key_with_http_info(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, **kwargs)

   def get_custom_entity_relationships(self, entity_type: Any, identifier_scope: Any, identifier_type: Any, identifier_value: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity  # noqa: E501

Get relationships for the specified Custom Entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_relationships(entity_type, identifier_scope, identifier_type, identifier_value, async_req=True)
>>> result = thread.get()

:param entity_type: The type of entity get relationships for. (required)
:type entity_type: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param identifier_type: An identifier type attached to the Custom Entity. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelationship"""
        return self.__client.get_custom_entity_relationships(entity_type, identifier_scope, identifier_type, identifier_value, **kwargs)

   def get_custom_entity_relationships_with_http_info(self, entity_type: Any, identifier_scope: Any, identifier_type: Any, identifier_value: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntityRelationships: Get Relationships for Custom Entity  # noqa: E501

Get relationships for the specified Custom Entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_relationships_with_http_info(entity_type, identifier_scope, identifier_type, identifier_value, async_req=True)
>>> result = thread.get()

:param entity_type: The type of entity get relationships for. (required)
:type entity_type: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param identifier_type: An identifier type attached to the Custom Entity. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relationships. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelationship, int, HTTPHeaderDict)"""
        return self.__client.get_custom_entity_relationships_with_http_info(entity_type, identifier_scope, identifier_type, identifier_value, **kwargs)

   def get_custom_entity_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntity: Get a Custom Entity instance.  # noqa: E501

Retrieve a Custom Entity instance by a specific entity type at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, async_req=True)
>>> result = thread.get()

:param entity_type: The type of Custom Entity to retrieve. An entityType can be created using the "CreateCustomEntityDefinition" endpoint for CustomEntityDefinitions. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param as_at: The AsAt datetime at which to retrieve the Custom Entity instance.
:type as_at: datetime
:param effective_at: The effective datetime or cut label at which to get the Custom Entity instance. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.get_custom_entity_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, **kwargs)

   def list_custom_entities(self, entity_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCustomEntities: List Custom Entities of the specified entityType.  # noqa: E501

List all the Custom Entities matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custom_entities(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The type of Custom Entity to list. (required)
:type entity_type: str
:param effective_at: The effective datetime or cut label at which to list the entities. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the entities. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param page: The pagination token to use to continue listing entities; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCustomEntityResponse"""
        return self.__client.list_custom_entities(entity_type, **kwargs)

   def list_custom_entities_with_http_info(self, entity_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCustomEntities: List Custom Entities of the specified entityType.  # noqa: E501

List all the Custom Entities matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custom_entities_with_http_info(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The type of Custom Entity to list. (required)
:type entity_type: str
:param effective_at: The effective datetime or cut label at which to list the entities. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the entities. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param page: The pagination token to use to continue listing entities; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the entities in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCustomEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.list_custom_entities_with_http_info(entity_type, **kwargs)

   def patch_custom_entity_access_metadata(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity.  # noqa: E501

Patch Custom Entity Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document    Currently only valid metadata keys are supported paths on the patch document                The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, identifier_scope, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The effectiveAt datetime at which the Access Metadata will be effective from
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.patch_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, identifier_scope, access_metadata_operation, **kwargs)

   def patch_custom_entity_access_metadata_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, identifier_scope: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchCustomEntityAccessMetadata: Patch Access Metadata rules for a Custom Entity.  # noqa: E501

Patch Custom Entity Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document    Currently only valid metadata keys are supported paths on the patch document                The response will return any affected Custom Entity Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The effectiveAt datetime at which the Access Metadata will be effective from
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.patch_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, identifier_scope, access_metadata_operation, **kwargs)

   def upsert_custom_entities(self, entity_type: Any, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities  # noqa: E501

Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custom_entities(entity_type, success_mode, request_body, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity to be created. An entityType can be created using the "CreateCustomEntityDefinition" endpoint for CustomEntityDefinitions. (required)
:type entity_type: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial (required)
:type success_mode: str
:param request_body: The payload describing the Custom Entity instances (required)
:type request_body: dict(str, CustomEntityRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertCustomEntitiesResponse"""
        return self.__client.upsert_custom_entities(entity_type, success_mode, request_body, **kwargs)

   def upsert_custom_entities_with_http_info(self, entity_type: Any, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCustomEntities: Batch upsert instances of Custom Entities  # noqa: E501

Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custom_entities_with_http_info(entity_type, success_mode, request_body, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity to be created. An entityType can be created using the "CreateCustomEntityDefinition" endpoint for CustomEntityDefinitions. (required)
:type entity_type: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial (required)
:type success_mode: str
:param request_body: The payload describing the Custom Entity instances (required)
:type request_body: dict(str, CustomEntityRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertCustomEntitiesResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_custom_entities_with_http_info(entity_type, success_mode, request_body, **kwargs)

   def upsert_custom_entity(self, entity_type: Any, custom_entity_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCustomEntity: Upsert a Custom Entity instance  # noqa: E501

Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custom_entity(entity_type, custom_entity_request, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity to be created. An entityType can be created using the "CreateCustomEntityDefinition" endpoint for CustomEntityDefinitions. (required)
:type entity_type: str
:param custom_entity_request: The payload describing the Custom Entity instance. (required)
:type custom_entity_request: CustomEntityRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityResponse"""
        return self.__client.upsert_custom_entity(entity_type, custom_entity_request, **kwargs)

   def upsert_custom_entity_access_metadata(self, entity_type: Any, identifier_type: Any, identifier_value: Any, metadata_key: Any, identifier_scope: Any, upsert_custom_entity_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, upsert_custom_entity_access_metadata_request, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param upsert_custom_entity_access_metadata_request: The Custom Entity Access Metadata entry to upsert (required)
:type upsert_custom_entity_access_metadata_request: UpsertCustomEntityAccessMetadataRequest
:param effective_at: The effectiveAt datetime at which the Access Metadata will be effective from
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[AccessMetadataValue]"""
        return self.__client.upsert_custom_entity_access_metadata(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, upsert_custom_entity_access_metadata_request, **kwargs)

   def upsert_custom_entity_access_metadata_with_http_info(self, entity_type: Any, identifier_type: Any, identifier_value: Any, metadata_key: Any, identifier_scope: Any, upsert_custom_entity_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCustomEntityAccessMetadata: Upsert a Custom Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Custom Entity Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Custom Entity Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, upsert_custom_entity_access_metadata_request, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity. (required)
:type entity_type: str
:param identifier_type: An identifier type attached to the Custom Entity instance. (required)
:type identifier_type: str
:param identifier_value: The identifier value. (required)
:type identifier_value: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param identifier_scope: The identifier scope. (required)
:type identifier_scope: str
:param upsert_custom_entity_access_metadata_request: The Custom Entity Access Metadata entry to upsert (required)
:type upsert_custom_entity_access_metadata_request: UpsertCustomEntityAccessMetadataRequest
:param effective_at: The effectiveAt datetime at which the Access Metadata will be effective from
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[AccessMetadataValue], int, HTTPHeaderDict)"""
        return self.__client.upsert_custom_entity_access_metadata_with_http_info(entity_type, identifier_type, identifier_value, metadata_key, identifier_scope, upsert_custom_entity_access_metadata_request, **kwargs)

   def upsert_custom_entity_with_http_info(self, entity_type: Any, custom_entity_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertCustomEntity: Upsert a Custom Entity instance  # noqa: E501

Insert the Custom Entity if it does not exist or update the Custom Entity with the supplied state if it does exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custom_entity_with_http_info(entity_type, custom_entity_request, async_req=True)
>>> result = thread.get()

:param entity_type: The type of the Custom Entity to be created. An entityType can be created using the "CreateCustomEntityDefinition" endpoint for CustomEntityDefinitions. (required)
:type entity_type: str
:param custom_entity_request: The payload describing the Custom Entity instance. (required)
:type custom_entity_request: CustomEntityRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_custom_entity_with_http_info(entity_type, custom_entity_request, **kwargs)

custom_entities_api = __CustomEntitiesApiAuthedAndStubbed()

class __CustomEntityDefinitionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CustomEntityDefinitionsApi)

   def create_custom_entity_definition(self, custom_entity_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCustomEntityDefinition: Define a new Custom Entity type.  # noqa: E501

The API will return a Bad Request if the Custom Entity type already exists.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_custom_entity_definition(custom_entity_definition_request, async_req=True)
>>> result = thread.get()

:param custom_entity_definition_request: The payload containing the description of the Custom Entity type. (required)
:type custom_entity_definition_request: CustomEntityDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityDefinition"""
        return self.__client.create_custom_entity_definition(custom_entity_definition_request, **kwargs)

   def create_custom_entity_definition_with_http_info(self, custom_entity_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCustomEntityDefinition: Define a new Custom Entity type.  # noqa: E501

The API will return a Bad Request if the Custom Entity type already exists.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_custom_entity_definition_with_http_info(custom_entity_definition_request, async_req=True)
>>> result = thread.get()

:param custom_entity_definition_request: The payload containing the description of the Custom Entity type. (required)
:type custom_entity_definition_request: CustomEntityDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_custom_entity_definition_with_http_info(custom_entity_definition_request, **kwargs)

   def get_definition(self, entity_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetDefinition: Get a Custom Entity type definition.  # noqa: E501

Retrieve a CustomEntityDefinition by a specific entityType at a point in AsAt time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_definition(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param as_at: The AsAt datetime at which to retrieve the definition.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityDefinition"""
        return self.__client.get_definition(entity_type, **kwargs)

   def get_definition_with_http_info(self, entity_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetDefinition: Get a Custom Entity type definition.  # noqa: E501

Retrieve a CustomEntityDefinition by a specific entityType at a point in AsAt time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_definition_with_http_info(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param as_at: The AsAt datetime at which to retrieve the definition.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_definition_with_http_info(entity_type, **kwargs)

   def list_custom_entity_definitions(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCustomEntityDefinitions: List the Custom Entity type definitions  # noqa: E501

List all Custom Entity type definitions matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custom_entity_definitions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the entities. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing entities; this              value is returned from the previous call. If a pagination token is provided, the filter, limit              and asAt fields must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCustomEntityDefinition"""
        return self.__client.list_custom_entity_definitions(**kwargs)

   def list_custom_entity_definitions_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCustomEntityDefinitions: List the Custom Entity type definitions  # noqa: E501

List all Custom Entity type definitions matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custom_entity_definitions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the entities. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing entities; this              value is returned from the previous call. If a pagination token is provided, the filter, limit              and asAt fields must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCustomEntityDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_custom_entity_definitions_with_http_info(**kwargs)

   def update_custom_entity_definition(self, entity_type: Any, update_custom_entity_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateCustomEntityDefinition: Modify an existing Custom Entity type.  # noqa: E501

The API will return a Bad Request if the Custom Entity type does not exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_custom_entity_definition(entity_type, update_custom_entity_definition_request, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param update_custom_entity_definition_request: The payload containing the description of the Custom Entity type. (required)
:type update_custom_entity_definition_request: UpdateCustomEntityDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityDefinition"""
        return self.__client.update_custom_entity_definition(entity_type, update_custom_entity_definition_request, **kwargs)

   def update_custom_entity_definition_with_http_info(self, entity_type: Any, update_custom_entity_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateCustomEntityDefinition: Modify an existing Custom Entity type.  # noqa: E501

The API will return a Bad Request if the Custom Entity type does not exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_custom_entity_definition_with_http_info(entity_type, update_custom_entity_definition_request, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param update_custom_entity_definition_request: The payload containing the description of the Custom Entity type. (required)
:type update_custom_entity_definition_request: UpdateCustomEntityDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityDefinition, int, HTTPHeaderDict)"""
        return self.__client.update_custom_entity_definition_with_http_info(entity_type, update_custom_entity_definition_request, **kwargs)

custom_entity_definitions_api = __CustomEntityDefinitionsApiAuthedAndStubbed()

class __CustomEntityTypesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CustomEntityTypesApi)

   def create_custom_entity_type(self, create_custom_entity_type_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCustomEntityType: Define a new Custom Entity Type.  # noqa: E501

The API will return a Bad Request if the Custom Entity Type already exists.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_custom_entity_type(create_custom_entity_type_request, async_req=True)
>>> result = thread.get()

:param create_custom_entity_type_request: The payload containing the description of the Custom Entity Type. (required)
:type create_custom_entity_type_request: CreateCustomEntityTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityType"""
        return self.__client.create_custom_entity_type(create_custom_entity_type_request, **kwargs)

   def create_custom_entity_type_with_http_info(self, create_custom_entity_type_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateCustomEntityType: Define a new Custom Entity Type.  # noqa: E501

The API will return a Bad Request if the Custom Entity Type already exists.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_custom_entity_type_with_http_info(create_custom_entity_type_request, async_req=True)
>>> result = thread.get()

:param create_custom_entity_type_request: The payload containing the description of the Custom Entity Type. (required)
:type create_custom_entity_type_request: CreateCustomEntityTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityType, int, HTTPHeaderDict)"""
        return self.__client.create_custom_entity_type_with_http_info(create_custom_entity_type_request, **kwargs)

   def get_custom_entity_type(self, entity_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntityType: Get a Custom Entity Type.  # noqa: E501

Retrieve a specific Custom Entity Type at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_type(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity Type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param as_at: The AsAt datetime at which to retrieve the definition.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityType"""
        return self.__client.get_custom_entity_type(entity_type, **kwargs)

   def get_custom_entity_type_with_http_info(self, entity_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCustomEntityType: Get a Custom Entity Type.  # noqa: E501

Retrieve a specific Custom Entity Type at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custom_entity_type_with_http_info(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity Type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param as_at: The AsAt datetime at which to retrieve the definition.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityType, int, HTTPHeaderDict)"""
        return self.__client.get_custom_entity_type_with_http_info(entity_type, **kwargs)

   def list_custom_entity_types(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCustomEntityTypes: List Custom Entity Types.  # noqa: E501

List all Custom Entity Types matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custom_entity_types(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the entities. Defaults to returning the latest version              of each Custom Entity Type if not specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param page: The pagination token to use to continue listing entities; this              value is returned from the previous call. If a pagination token is provided, the filter, limit, sortBy,              and asAt fields must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCustomEntityType"""
        return self.__client.list_custom_entity_types(**kwargs)

   def list_custom_entity_types_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListCustomEntityTypes: List Custom Entity Types.  # noqa: E501

List all Custom Entity Types matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custom_entity_types_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the entities. Defaults to returning the latest version              of each Custom Entity Type if not specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param page: The pagination token to use to continue listing entities; this              value is returned from the previous call. If a pagination token is provided, the filter, limit, sortBy,              and asAt fields must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCustomEntityType, int, HTTPHeaderDict)"""
        return self.__client.list_custom_entity_types_with_http_info(**kwargs)

   def update_custom_entity_type(self, entity_type: Any, update_custom_entity_type_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateCustomEntityType: Modify an existing Custom Entity Type.  # noqa: E501

The API will return a Bad Request if the Custom Entity Type does not exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_custom_entity_type(entity_type, update_custom_entity_type_request, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity Type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param update_custom_entity_type_request: The payload containing the description of the Custom Entity Type. (required)
:type update_custom_entity_type_request: UpdateCustomEntityTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustomEntityType"""
        return self.__client.update_custom_entity_type(entity_type, update_custom_entity_type_request, **kwargs)

   def update_custom_entity_type_with_http_info(self, entity_type: Any, update_custom_entity_type_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateCustomEntityType: Modify an existing Custom Entity Type.  # noqa: E501

The API will return a Bad Request if the Custom Entity Type does not exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_custom_entity_type_with_http_info(entity_type, update_custom_entity_type_request, async_req=True)
>>> result = thread.get()

:param entity_type: The identifier for the Custom Entity Type, derived from the "entityTypeName" provided on creation. (required)
:type entity_type: str
:param update_custom_entity_type_request: The payload containing the description of the Custom Entity Type. (required)
:type update_custom_entity_type_request: UpdateCustomEntityTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustomEntityType, int, HTTPHeaderDict)"""
        return self.__client.update_custom_entity_type_with_http_info(entity_type, update_custom_entity_type_request, **kwargs)

custom_entity_types_api = __CustomEntityTypesApiAuthedAndStubbed()

class __CutLabelDefinitionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.CutLabelDefinitionsApi)

   def create_cut_label_definition(self, **kwargs) -> 'Any':
        """CreateCutLabelDefinition: Create a Cut Label  # noqa: E501

Create a Cut Label valid in all scopes  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_cut_label_definition(async_req=True)
>>> result = thread.get()

:param create_cut_label_definition_request: The cut label definition
:type create_cut_label_definition_request: CreateCutLabelDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CutLabelDefinition"""
        return self.__client.create_cut_label_definition(**kwargs)

   def create_cut_label_definition_with_http_info(self, **kwargs) -> 'Any':
        """CreateCutLabelDefinition: Create a Cut Label  # noqa: E501

Create a Cut Label valid in all scopes  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_cut_label_definition_with_http_info(async_req=True)
>>> result = thread.get()

:param create_cut_label_definition_request: The cut label definition
:type create_cut_label_definition_request: CreateCutLabelDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CutLabelDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_cut_label_definition_with_http_info(**kwargs)

   def delete_cut_label_definition(self, code: Any, **kwargs) -> 'Any':
        """DeleteCutLabelDefinition: Delete a Cut Label  # noqa: E501

Delete a specified cut label  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_cut_label_definition(code, async_req=True)
>>> result = thread.get()

:param code: The Code of the Cut Label that is being Deleted (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: datetime"""
        return self.__client.delete_cut_label_definition(code, **kwargs)

   def delete_cut_label_definition_with_http_info(self, code: Any, **kwargs) -> 'Any':
        """DeleteCutLabelDefinition: Delete a Cut Label  # noqa: E501

Delete a specified cut label  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_cut_label_definition_with_http_info(code, async_req=True)
>>> result = thread.get()

:param code: The Code of the Cut Label that is being Deleted (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (datetime, int, HTTPHeaderDict)"""
        return self.__client.delete_cut_label_definition_with_http_info(code, **kwargs)

   def get_cut_label_definition(self, code: Any, **kwargs) -> 'Any':
        """GetCutLabelDefinition: Get a Cut Label  # noqa: E501

Get a specified cut label at a given time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_cut_label_definition(code, async_req=True)
>>> result = thread.get()

:param code: The Code of the Cut Label that is being queried (required)
:type code: str
:param as_at: The time at which to get the Cut Label
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CutLabelDefinition"""
        return self.__client.get_cut_label_definition(code, **kwargs)

   def get_cut_label_definition_with_http_info(self, code: Any, **kwargs) -> 'Any':
        """GetCutLabelDefinition: Get a Cut Label  # noqa: E501

Get a specified cut label at a given time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_cut_label_definition_with_http_info(code, async_req=True)
>>> result = thread.get()

:param code: The Code of the Cut Label that is being queried (required)
:type code: str
:param as_at: The time at which to get the Cut Label
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CutLabelDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_cut_label_definition_with_http_info(code, **kwargs)

   def list_cut_label_definitions(self, **kwargs) -> 'Any':
        """ListCutLabelDefinitions: List Existing Cut Labels  # noqa: E501

List all the Cut Label Definitions that are valid at the given AsAt time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cut_label_definitions(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The As At time at which listed Cut Labels are valid
:type as_at: datetime
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on code, use "code eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing cut labels from a previous call This value is returned from the previous call.  If a pagination token is provided the sortBy, filter, and asAt fields  must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCutLabelDefinition"""
        return self.__client.list_cut_label_definitions(**kwargs)

   def list_cut_label_definitions_with_http_info(self, **kwargs) -> 'Any':
        """ListCutLabelDefinitions: List Existing Cut Labels  # noqa: E501

List all the Cut Label Definitions that are valid at the given AsAt time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_cut_label_definitions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The As At time at which listed Cut Labels are valid
:type as_at: datetime
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on code, use "code eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing cut labels from a previous call This value is returned from the previous call.  If a pagination token is provided the sortBy, filter, and asAt fields  must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCutLabelDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_cut_label_definitions_with_http_info(**kwargs)

   def update_cut_label_definition(self, code: Any, **kwargs) -> 'Any':
        """UpdateCutLabelDefinition: Update a Cut Label  # noqa: E501

Update a specified cut label  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_cut_label_definition(code, async_req=True)
>>> result = thread.get()

:param code: The Code of the Cut Label that is being updated (required)
:type code: str
:param update_cut_label_definition_request: The cut label update definition
:type update_cut_label_definition_request: UpdateCutLabelDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CutLabelDefinition"""
        return self.__client.update_cut_label_definition(code, **kwargs)

   def update_cut_label_definition_with_http_info(self, code: Any, **kwargs) -> 'Any':
        """UpdateCutLabelDefinition: Update a Cut Label  # noqa: E501

Update a specified cut label  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_cut_label_definition_with_http_info(code, async_req=True)
>>> result = thread.get()

:param code: The Code of the Cut Label that is being updated (required)
:type code: str
:param update_cut_label_definition_request: The cut label update definition
:type update_cut_label_definition_request: UpdateCutLabelDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CutLabelDefinition, int, HTTPHeaderDict)"""
        return self.__client.update_cut_label_definition_with_http_info(code, **kwargs)

cut_label_definitions_api = __CutLabelDefinitionsApiAuthedAndStubbed()

class __DataTypesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.DataTypesApi)

   def create_data_type(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateDataType: Create data type definition  # noqa: E501

Create a new data type definition    Data types cannot be created in either the "default" or "system" scopes.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_data_type(async_req=True)
>>> result = thread.get()

:param create_data_type_request: The definition of the new data type
:type create_data_type_request: CreateDataTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DataType"""
        return self.__client.create_data_type(**kwargs)

   def create_data_type_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateDataType: Create data type definition  # noqa: E501

Create a new data type definition    Data types cannot be created in either the "default" or "system" scopes.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_data_type_with_http_info(async_req=True)
>>> result = thread.get()

:param create_data_type_request: The definition of the new data type
:type create_data_type_request: CreateDataTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DataType, int, HTTPHeaderDict)"""
        return self.__client.create_data_type_with_http_info(**kwargs)

   def get_data_type(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetDataType: Get data type definition  # noqa: E501

Get the definition of a specified data type  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_data_type(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the data type definition. Defaults to              return the latest version of the instrument definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DataType"""
        return self.__client.get_data_type(scope, code, **kwargs)

   def get_data_type_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetDataType: Get data type definition  # noqa: E501

Get the definition of a specified data type  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_data_type_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the data type definition. Defaults to              return the latest version of the instrument definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DataType, int, HTTPHeaderDict)"""
        return self.__client.get_data_type_with_http_info(scope, code, **kwargs)

   def get_units_from_data_type(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetUnitsFromDataType: Get units from data type  # noqa: E501

Get the definitions of the specified units associated bound to a specific data type  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_units_from_data_type(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param units: One or more unit identifiers for which the definition is being requested
:type units: list[str]
:param filter: Optional. Expression to filter the result set.               For example, to filter on the Schema, use "schema eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param as_at: Optional. The as at of the requested data type
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfIUnitDefinitionDto"""
        return self.__client.get_units_from_data_type(scope, code, **kwargs)

   def get_units_from_data_type_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetUnitsFromDataType: Get units from data type  # noqa: E501

Get the definitions of the specified units associated bound to a specific data type  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_units_from_data_type_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param units: One or more unit identifiers for which the definition is being requested
:type units: list[str]
:param filter: Optional. Expression to filter the result set.               For example, to filter on the Schema, use "schema eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param as_at: Optional. The as at of the requested data type
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfIUnitDefinitionDto, int, HTTPHeaderDict)"""
        return self.__client.get_units_from_data_type_with_http_info(scope, code, **kwargs)

   def list_data_type_summaries(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListDataTypeSummaries: List all data type summaries, without the reference data  # noqa: E501

List all data type summaries  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_data_type_summaries(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the data type summaries. Defaults to returning the latest version               of each summary if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing data type summaries. This  value is returned from the previous call. If a pagination token is provided, the filter, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Optional. Expression to filter the result set.                For example, to filter on the Scope, use "id.scope eq 'myscope'", to filter on Schema, use "schema eq 'string'",               to filter on AcceptableValues use "acceptableValues any (~ eq 'value')"               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfDataTypeSummary"""
        return self.__client.list_data_type_summaries(**kwargs)

   def list_data_type_summaries_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListDataTypeSummaries: List all data type summaries, without the reference data  # noqa: E501

List all data type summaries  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_data_type_summaries_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list the data type summaries. Defaults to returning the latest version               of each summary if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing data type summaries. This  value is returned from the previous call. If a pagination token is provided, the filter, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Optional. Expression to filter the result set.                For example, to filter on the Scope, use "id.scope eq 'myscope'", to filter on Schema, use "schema eq 'string'",               to filter on AcceptableValues use "acceptableValues any (~ eq 'value')"               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfDataTypeSummary, int, HTTPHeaderDict)"""
        return self.__client.list_data_type_summaries_with_http_info(**kwargs)

   def list_data_types(self, scope: Any, **kwargs) -> 'Any':
        """ListDataTypes: List data types  # noqa: E501

List all data types in a specified scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_data_types(scope, async_req=True)
>>> result = thread.get()

:param scope: The requested scope of the data types (required)
:type scope: str
:param as_at: The as at of the requested data types
:type as_at: datetime
:param include_system: Whether to additionally include those data types in the "system" scope
:type include_system: bool
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on the Display Name, use "displayName eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfDataType"""
        return self.__client.list_data_types(scope, **kwargs)

   def list_data_types_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """ListDataTypes: List data types  # noqa: E501

List all data types in a specified scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_data_types_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The requested scope of the data types (required)
:type scope: str
:param as_at: The as at of the requested data types
:type as_at: datetime
:param include_system: Whether to additionally include those data types in the "system" scope
:type include_system: bool
:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on the Display Name, use "displayName eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfDataType, int, HTTPHeaderDict)"""
        return self.__client.list_data_types_with_http_info(scope, **kwargs)

   def update_data_type(self, scope: Any, code: Any, update_data_type_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateDataType: Update data type definition  # noqa: E501

Update the definition of the specified existing data type    Not all elements within a data type definition are modifiable due to the potential implications for data  already stored against the types  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_data_type(scope, code, update_data_type_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param update_data_type_request: The updated definition of the data type (required)
:type update_data_type_request: UpdateDataTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DataType"""
        return self.__client.update_data_type(scope, code, update_data_type_request, **kwargs)

   def update_data_type_with_http_info(self, scope: Any, code: Any, update_data_type_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateDataType: Update data type definition  # noqa: E501

Update the definition of the specified existing data type    Not all elements within a data type definition are modifiable due to the potential implications for data  already stored against the types  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_data_type_with_http_info(scope, code, update_data_type_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param update_data_type_request: The updated definition of the data type (required)
:type update_data_type_request: UpdateDataTypeRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DataType, int, HTTPHeaderDict)"""
        return self.__client.update_data_type_with_http_info(scope, code, update_data_type_request, **kwargs)

   def update_reference_values(self, scope: Any, code: Any, field_value: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateReferenceValues: Update reference data on a data type  # noqa: E501

Replaces the whole set of reference values  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_reference_values(scope, code, field_value, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param field_value: The updated reference values (required)
:type field_value: list[FieldValue]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DataType"""
        return self.__client.update_reference_values(scope, code, field_value, **kwargs)

   def update_reference_values_with_http_info(self, scope: Any, code: Any, field_value: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateReferenceValues: Update reference data on a data type  # noqa: E501

Replaces the whole set of reference values  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_reference_values_with_http_info(scope, code, field_value, async_req=True)
>>> result = thread.get()

:param scope: The scope of the data type (required)
:type scope: str
:param code: The code of the data type (required)
:type code: str
:param field_value: The updated reference values (required)
:type field_value: list[FieldValue]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DataType, int, HTTPHeaderDict)"""
        return self.__client.update_reference_values_with_http_info(scope, code, field_value, **kwargs)

data_types_api = __DataTypesApiAuthedAndStubbed()

class __DerivedTransactionPortfoliosApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.DerivedTransactionPortfoliosApi)

   def create_derived_portfolio(self, scope: Any, **kwargs) -> 'Any':
        """CreateDerivedPortfolio: Create derived portfolio  # noqa: E501

Create a derived transaction portfolio from a parent transaction portfolio (which may itself be derived).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_derived_portfolio(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create the derived transaction portfolio. (required)
:type scope: str
:param create_derived_transaction_portfolio_request: The definition of the derived transaction portfolio.
:type create_derived_transaction_portfolio_request: CreateDerivedTransactionPortfolioRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Portfolio"""
        return self.__client.create_derived_portfolio(scope, **kwargs)

   def create_derived_portfolio_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """CreateDerivedPortfolio: Create derived portfolio  # noqa: E501

Create a derived transaction portfolio from a parent transaction portfolio (which may itself be derived).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_derived_portfolio_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create the derived transaction portfolio. (required)
:type scope: str
:param create_derived_transaction_portfolio_request: The definition of the derived transaction portfolio.
:type create_derived_transaction_portfolio_request: CreateDerivedTransactionPortfolioRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Portfolio, int, HTTPHeaderDict)"""
        return self.__client.create_derived_portfolio_with_http_info(scope, **kwargs)

   def delete_derived_portfolio_details(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteDerivedPortfolioDetails: Delete derived portfolio details  # noqa: E501

Delete all the portfolio details for a derived transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_derived_portfolio_details(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the derived transaction portfolio. (required)
:type scope: str
:param code: The code of the derived transaction portfolio. Together with the scope this uniquely identifies              the derived transaction portfolio. (required)
:type code: str
:param effective_at: The effective date of the change.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_derived_portfolio_details(scope, code, **kwargs)

   def delete_derived_portfolio_details_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteDerivedPortfolioDetails: Delete derived portfolio details  # noqa: E501

Delete all the portfolio details for a derived transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_derived_portfolio_details_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the derived transaction portfolio. (required)
:type scope: str
:param code: The code of the derived transaction portfolio. Together with the scope this uniquely identifies              the derived transaction portfolio. (required)
:type code: str
:param effective_at: The effective date of the change.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_derived_portfolio_details_with_http_info(scope, code, **kwargs)

derived_transaction_portfolios_api = __DerivedTransactionPortfoliosApiAuthedAndStubbed()

class __EntitiesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.EntitiesApi)

   def get_portfolio_changes(self, scope: Any, effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioChanges: Get the next change to each portfolio in a scope.  # noqa: E501

Gets the time of the next (earliest effective at) modification (correction and/or amendment) to each portfolio in a scope relative to a point in bitemporal time.  Includes changes from parent portfolios in different scopes.  Excludes changes from subscriptions (e.g corporate actions).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_changes(scope, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope (required)
:type scope: str
:param effective_at: The effective date of the origin. (required)
:type effective_at: str
:param as_at: The as-at date of the origin.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfChange"""
        return self.__client.get_portfolio_changes(scope, effective_at, **kwargs)

   def get_portfolio_changes_with_http_info(self, scope: Any, effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioChanges: Get the next change to each portfolio in a scope.  # noqa: E501

Gets the time of the next (earliest effective at) modification (correction and/or amendment) to each portfolio in a scope relative to a point in bitemporal time.  Includes changes from parent portfolios in different scopes.  Excludes changes from subscriptions (e.g corporate actions).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_changes_with_http_info(scope, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope (required)
:type scope: str
:param effective_at: The effective date of the origin. (required)
:type effective_at: str
:param as_at: The as-at date of the origin.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfChange, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_changes_with_http_info(scope, effective_at, **kwargs)

entities_api = __EntitiesApiAuthedAndStubbed()

class __ExecutionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ExecutionsApi)

   def delete_execution(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteExecution: Delete execution  # noqa: E501

Delete an execution. Deletion will be valid from the execution's creation datetime.  This means that the execution will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_execution(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The execution scope. (required)
:type scope: str
:param code: The execution's code. This, together with the scope uniquely identifies the execution to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_execution(scope, code, **kwargs)

   def delete_execution_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteExecution: Delete execution  # noqa: E501

Delete an execution. Deletion will be valid from the execution's creation datetime.  This means that the execution will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_execution_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The execution scope. (required)
:type scope: str
:param code: The execution's code. This, together with the scope uniquely identifies the execution to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_execution_with_http_info(scope, code, **kwargs)

   def get_execution(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetExecution: Get Execution  # noqa: E501

Fetch a Execution that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_execution(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the execution belongs. (required)
:type scope: str
:param code: The execution's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the execution. Defaults to return the latest version of the execution if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Execution" domain to decorate onto the execution.              These take the format {domain}/{scope}/{code} e.g. "Execution/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Execution"""
        return self.__client.get_execution(scope, code, **kwargs)

   def get_execution_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetExecution: Get Execution  # noqa: E501

Fetch a Execution that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_execution_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the execution belongs. (required)
:type scope: str
:param code: The execution's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the execution. Defaults to return the latest version of the execution if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Execution" domain to decorate onto the execution.              These take the format {domain}/{scope}/{code} e.g. "Execution/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Execution, int, HTTPHeaderDict)"""
        return self.__client.get_execution_with_http_info(scope, code, **kwargs)

   def list_executions(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListExecutions: List Executions  # noqa: E501

Fetch the last pre-AsAt date version of each execution in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_executions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the execution. Defaults to return the latest version of the execution if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing execution from a previous call to list executions.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Execution" domain to decorate onto each execution.                  These take the format {domain}/{scope}/{code} e.g. "Execution/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfExecution"""
        return self.__client.list_executions(**kwargs)

   def list_executions_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListExecutions: List Executions  # noqa: E501

Fetch the last pre-AsAt date version of each execution in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_executions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the execution. Defaults to return the latest version of the execution if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing execution from a previous call to list executions.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Execution" domain to decorate onto each execution.                  These take the format {domain}/{scope}/{code} e.g. "Execution/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfExecution, int, HTTPHeaderDict)"""
        return self.__client.list_executions_with_http_info(**kwargs)

   def upsert_executions(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertExecutions: Upsert Execution  # noqa: E501

Upsert; update existing executions with given ids, or create new executions otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_executions(async_req=True)
>>> result = thread.get()

:param execution_set_request: The collection of execution requests.
:type execution_set_request: ExecutionSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfExecution"""
        return self.__client.upsert_executions(**kwargs)

   def upsert_executions_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertExecutions: Upsert Execution  # noqa: E501

Upsert; update existing executions with given ids, or create new executions otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_executions_with_http_info(async_req=True)
>>> result = thread.get()

:param execution_set_request: The collection of execution requests.
:type execution_set_request: ExecutionSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfExecution, int, HTTPHeaderDict)"""
        return self.__client.upsert_executions_with_http_info(**kwargs)

executions_api = __ExecutionsApiAuthedAndStubbed()

class __FundsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.FundsApi)

   def create_fund(self, scope: Any, fund_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateFund: Create a Fund.  # noqa: E501

Create the given Fund.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_fund(scope, fund_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund. (required)
:type scope: str
:param fund_request: The definition of the Fund. (required)
:type fund_request: FundRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Fund"""
        return self.__client.create_fund(scope, fund_request, **kwargs)

   def create_fund_with_http_info(self, scope: Any, fund_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateFund: Create a Fund.  # noqa: E501

Create the given Fund.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_fund_with_http_info(scope, fund_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund. (required)
:type scope: str
:param fund_request: The definition of the Fund. (required)
:type fund_request: FundRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Fund, int, HTTPHeaderDict)"""
        return self.__client.create_fund_with_http_info(scope, fund_request, **kwargs)

   def delete_fund(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteFund: Delete a Fund.  # noqa: E501

Delete the given Fund.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_fund(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund to be deleted. (required)
:type scope: str
:param code: The code of the Fund to be deleted. Together with the scope this uniquely identifies the Fund. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_fund(scope, code, **kwargs)

   def delete_fund_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteFund: Delete a Fund.  # noqa: E501

Delete the given Fund.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_fund_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund to be deleted. (required)
:type scope: str
:param code: The code of the Fund to be deleted. Together with the scope this uniquely identifies the Fund. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_fund_with_http_info(scope, code, **kwargs)

   def get_fund(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetFund: Get a Fund.  # noqa: E501

Retrieve the definition of a particular Fund.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_fund(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund. (required)
:type scope: str
:param code: The code of the Fund. Together with the scope this uniquely identifies the Fund. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Fund properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Fund definition. Defaults to returning the latest version of the Fund definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Fund' domain to decorate onto the Fund.              These must take the format {domain}/{scope}/{code}, for example 'Fund/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Fund"""
        return self.__client.get_fund(scope, code, **kwargs)

   def get_fund_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetFund: Get a Fund.  # noqa: E501

Retrieve the definition of a particular Fund.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_fund_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund. (required)
:type scope: str
:param code: The code of the Fund. Together with the scope this uniquely identifies the Fund. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Fund properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Fund definition. Defaults to returning the latest version of the Fund definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Fund' domain to decorate onto the Fund.              These must take the format {domain}/{scope}/{code}, for example 'Fund/Manager/Id'. If no properties are specified, then no properties will be returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Fund, int, HTTPHeaderDict)"""
        return self.__client.get_fund_with_http_info(scope, code, **kwargs)

   def list_funds(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListFunds: List Funds.  # noqa: E501

List all the Funds matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_funds(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Funds. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the Funds. Defaults to returning the latest version of each Fund if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Funds; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Fund type, specify "id.Code eq 'Fund1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'Fund' domain to decorate onto each Fund.              These must take the format {domain}/{scope}/{code}, for example 'Fund/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfFund"""
        return self.__client.list_funds(**kwargs)

   def list_funds_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListFunds: List Funds.  # noqa: E501

List all the Funds matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_funds_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the Funds. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the Funds. Defaults to returning the latest version of each Fund if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Funds; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Fund type, specify "id.Code eq 'Fund1'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'Fund' domain to decorate onto each Fund.              These must take the format {domain}/{scope}/{code}, for example 'Fund/Manager/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfFund, int, HTTPHeaderDict)"""
        return self.__client.list_funds_with_http_info(**kwargs)

   def upsert_fund_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertFundProperties: Upsert Fund properties  # noqa: E501

Update or insert one or more properties onto a single Fund. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'Fund'.                Upserting a property that exists for an Fund, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_fund_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Fund to update or insert the properties onto. Together with the scope this uniquely identifies the Fund. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the Fund. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "Fund/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: FundProperties"""
        return self.__client.upsert_fund_properties(scope, code, **kwargs)

   def upsert_fund_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertFundProperties: Upsert Fund properties  # noqa: E501

Update or insert one or more properties onto a single Fund. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'Fund'.                Upserting a property that exists for an Fund, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_fund_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Fund to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Fund to update or insert the properties onto. Together with the scope this uniquely identifies the Fund. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the Fund. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "Fund/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (FundProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_fund_properties_with_http_info(scope, code, **kwargs)

funds_api = __FundsApiAuthedAndStubbed()

class __InstrumentEventTypesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.InstrumentEventTypesApi)

   def create_transaction_template(self, instrument_event_type: Any, instrument_type: Any, scope: Any, transaction_template_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateTransactionTemplate: Create Transaction Template  # noqa: E501

Create a transaction template for a particular instrument event type in a scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_transaction_template(instrument_event_type, instrument_type, scope, transaction_template_request, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The type of instrument events that the template is applied to. (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope in which the template lies. (required)
:type scope: str
:param transaction_template_request: A request defining a new transaction template to be created. (required)
:type transaction_template_request: TransactionTemplateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionTemplate"""
        return self.__client.create_transaction_template(instrument_event_type, instrument_type, scope, transaction_template_request, **kwargs)

   def create_transaction_template_with_http_info(self, instrument_event_type: Any, instrument_type: Any, scope: Any, transaction_template_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateTransactionTemplate: Create Transaction Template  # noqa: E501

Create a transaction template for a particular instrument event type in a scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, transaction_template_request, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The type of instrument events that the template is applied to. (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope in which the template lies. (required)
:type scope: str
:param transaction_template_request: A request defining a new transaction template to be created. (required)
:type transaction_template_request: TransactionTemplateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionTemplate, int, HTTPHeaderDict)"""
        return self.__client.create_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, transaction_template_request, **kwargs)

   def delete_transaction_template(self, instrument_event_type: Any, instrument_type: Any, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTransactionTemplate: Delete Transaction Template  # noqa: E501

Delete a transaction template for a particular instrument event type in a scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_template(instrument_event_type, instrument_type, scope, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The type of instrument events that the template is applied to. (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope of the template. (required)
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: datetime"""
        return self.__client.delete_transaction_template(instrument_event_type, instrument_type, scope, **kwargs)

   def delete_transaction_template_with_http_info(self, instrument_event_type: Any, instrument_type: Any, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTransactionTemplate: Delete Transaction Template  # noqa: E501

Delete a transaction template for a particular instrument event type in a scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The type of instrument events that the template is applied to. (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope of the template. (required)
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (datetime, int, HTTPHeaderDict)"""
        return self.__client.delete_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, **kwargs)

   def get_transaction_template(self, instrument_event_type: Any, instrument_type: Any, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionTemplate: Get Transaction Template  # noqa: E501

Gets the Transaction Template that for the instrument event type within the scope specified.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_template(instrument_event_type, instrument_type, scope, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The instrument event type of the transaction template (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope in which the template lies. When not supplied the scope is 'default'. (required)
:type scope: str
:param as_at: The AsAt time of the requested Transaction Template
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionTemplate"""
        return self.__client.get_transaction_template(instrument_event_type, instrument_type, scope, **kwargs)

   def get_transaction_template_specification(self, instrument_event_type: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionTemplateSpecification: Get Transaction Template Specification.  # noqa: E501

Retrieve the transaction template specification for a particular event type.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_template_specification(instrument_event_type, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The requested instrument event type. (required)
:type instrument_event_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionTemplateSpecification"""
        return self.__client.get_transaction_template_specification(instrument_event_type, **kwargs)

   def get_transaction_template_specification_with_http_info(self, instrument_event_type: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionTemplateSpecification: Get Transaction Template Specification.  # noqa: E501

Retrieve the transaction template specification for a particular event type.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_template_specification_with_http_info(instrument_event_type, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The requested instrument event type. (required)
:type instrument_event_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionTemplateSpecification, int, HTTPHeaderDict)"""
        return self.__client.get_transaction_template_specification_with_http_info(instrument_event_type, **kwargs)

   def get_transaction_template_with_http_info(self, instrument_event_type: Any, instrument_type: Any, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionTemplate: Get Transaction Template  # noqa: E501

Gets the Transaction Template that for the instrument event type within the scope specified.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The instrument event type of the transaction template (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope in which the template lies. When not supplied the scope is 'default'. (required)
:type scope: str
:param as_at: The AsAt time of the requested Transaction Template
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionTemplate, int, HTTPHeaderDict)"""
        return self.__client.get_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, **kwargs)

   def list_transaction_template_specifications(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTransactionTemplateSpecifications: List Transaction Template Specifications.  # noqa: E501

Retrieves all transaction template specifications.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_template_specifications(async_req=True)
>>> result = thread.get()

:param as_at: AsAt of the request
:type as_at: datetime
:param page: The pagination token to use to continue listing Transaction Template Specifications from              a previous call to list Transaction Template Specifications.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt              fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfTransactionTemplateSpecification"""
        return self.__client.list_transaction_template_specifications(**kwargs)

   def list_transaction_template_specifications_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTransactionTemplateSpecifications: List Transaction Template Specifications.  # noqa: E501

Retrieves all transaction template specifications.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_template_specifications_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: AsAt of the request
:type as_at: datetime
:param page: The pagination token to use to continue listing Transaction Template Specifications from              a previous call to list Transaction Template Specifications.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt              fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfTransactionTemplateSpecification, int, HTTPHeaderDict)"""
        return self.__client.list_transaction_template_specifications_with_http_info(**kwargs)

   def list_transaction_templates(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTransactionTemplates: List Transaction Templates  # noqa: E501

Lists all Transaction Templates.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_templates(async_req=True)
>>> result = thread.get()

:param as_at: The AsAt time at which to retrieve the Transaction Templates
:type as_at: datetime
:param page: The pagination token to use to continue listing Transaction Templates from a previous call to list Transaction Templates.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, limit, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfTransactionTemplate"""
        return self.__client.list_transaction_templates(**kwargs)

   def list_transaction_templates_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTransactionTemplates: List Transaction Templates  # noqa: E501

Lists all Transaction Templates.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_templates_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The AsAt time at which to retrieve the Transaction Templates
:type as_at: datetime
:param page: The pagination token to use to continue listing Transaction Templates from a previous call to list Transaction Templates.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, limit, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfTransactionTemplate, int, HTTPHeaderDict)"""
        return self.__client.list_transaction_templates_with_http_info(**kwargs)

   def update_transaction_template(self, instrument_event_type: Any, instrument_type: Any, scope: Any, transaction_template_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpdateTransactionTemplate: Update Transaction Template  # noqa: E501

Update a transaction template for a particular instrument event type in a scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_transaction_template(instrument_event_type, instrument_type, scope, transaction_template_request, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The type of instrument events that the template is applied to. (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope in which the template lies. (required)
:type scope: str
:param transaction_template_request: A request defining the updated values for the transaction template. (required)
:type transaction_template_request: TransactionTemplateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionTemplate"""
        return self.__client.update_transaction_template(instrument_event_type, instrument_type, scope, transaction_template_request, **kwargs)

   def update_transaction_template_with_http_info(self, instrument_event_type: Any, instrument_type: Any, scope: Any, transaction_template_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpdateTransactionTemplate: Update Transaction Template  # noqa: E501

Update a transaction template for a particular instrument event type in a scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, transaction_template_request, async_req=True)
>>> result = thread.get()

:param instrument_event_type: The type of instrument events that the template is applied to. (required)
:type instrument_event_type: str
:param instrument_type: The instrument type of the transaction template. The combination of the instrument              event type, instrument type and scope uniquely identifies a transaction template (required)
:type instrument_type: str
:param scope: The scope in which the template lies. (required)
:type scope: str
:param transaction_template_request: A request defining the updated values for the transaction template. (required)
:type transaction_template_request: TransactionTemplateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionTemplate, int, HTTPHeaderDict)"""
        return self.__client.update_transaction_template_with_http_info(instrument_event_type, instrument_type, scope, transaction_template_request, **kwargs)

instrument_event_types_api = __InstrumentEventTypesApiAuthedAndStubbed()

class __InstrumentEventsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.InstrumentEventsApi)

   def query_bucketed_cash_flows(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryBucketedCashFlows: Returns bucketed cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns bucketed cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_bucketed_cash_flows(async_req=True)
>>> result = thread.get()

:param query_bucketed_cash_flows_request: The Query Information.
:type query_bucketed_cash_flows_request: QueryBucketedCashFlowsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BucketedCashFlowResponse"""
        return self.__client.query_bucketed_cash_flows(**kwargs)

   def query_bucketed_cash_flows_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryBucketedCashFlows: Returns bucketed cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns bucketed cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_bucketed_cash_flows_with_http_info(async_req=True)
>>> result = thread.get()

:param query_bucketed_cash_flows_request: The Query Information.
:type query_bucketed_cash_flows_request: QueryBucketedCashFlowsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BucketedCashFlowResponse, int, HTTPHeaderDict)"""
        return self.__client.query_bucketed_cash_flows_with_http_info(**kwargs)

   def query_cash_flows(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryCashFlows: Returns a list of cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns a list of cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_cash_flows(async_req=True)
>>> result = thread.get()

:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, queryBody, and limit must not  be modified.
:type page: str
:param query_cash_flows_request: The filter parameters used to retrieve instrument events.
:type query_cash_flows_request: QueryCashFlowsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfInstrumentCashFlow"""
        return self.__client.query_cash_flows(**kwargs)

   def query_cash_flows_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryCashFlows: Returns a list of cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns a list of cashflows based on the holdings of the portfolios and date range specified in the query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_cash_flows_with_http_info(async_req=True)
>>> result = thread.get()

:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, queryBody, and limit must not  be modified.
:type page: str
:param query_cash_flows_request: The filter parameters used to retrieve instrument events.
:type query_cash_flows_request: QueryCashFlowsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfInstrumentCashFlow, int, HTTPHeaderDict)"""
        return self.__client.query_cash_flows_with_http_info(**kwargs)

   def query_instrument_events(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryInstrumentEvents: Returns a list of instrument events based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns a list of instrument events based on the holdings of the portfolios and date range specified in the query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_instrument_events(async_req=True)
>>> result = thread.get()

:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, queryBody, and limit must not  be modified.
:type page: str
:param query_instrument_events_request: The filter parameters used to retrieve instrument events.
:type query_instrument_events_request: QueryInstrumentEventsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfInstrumentEventHolder"""
        return self.__client.query_instrument_events(**kwargs)

   def query_instrument_events_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryInstrumentEvents: Returns a list of instrument events based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns a list of instrument events based on the holdings of the portfolios and date range specified in the query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_instrument_events_with_http_info(async_req=True)
>>> result = thread.get()

:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, queryBody, and limit must not  be modified.
:type page: str
:param query_instrument_events_request: The filter parameters used to retrieve instrument events.
:type query_instrument_events_request: QueryInstrumentEventsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfInstrumentEventHolder, int, HTTPHeaderDict)"""
        return self.__client.query_instrument_events_with_http_info(**kwargs)

   def query_trade_tickets(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryTradeTickets: Returns a list of trade tickets based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns a list of trade tickets based on the holdings of the portfolios and date range specified in the query.    These trade tickets are derived from events that involve transition of instrument states, such as transitions  on exercise or default of an instrument. The trade tickets are to allow the new position to be created given the  existing portfolio configuration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_trade_tickets(async_req=True)
>>> result = thread.get()

:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, queryBody, and limit must not  be modified.
:type page: str
:param query_trade_tickets_request: The filter parameters used to retrieve instrument events.
:type query_trade_tickets_request: QueryTradeTicketsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPortfolioTradeTicket"""
        return self.__client.query_trade_tickets(**kwargs)

   def query_trade_tickets_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryTradeTickets: Returns a list of trade tickets based on the holdings of the portfolios and date range specified in the query.  # noqa: E501

Returns a list of trade tickets based on the holdings of the portfolios and date range specified in the query.    These trade tickets are derived from events that involve transition of instrument states, such as transitions  on exercise or default of an instrument. The trade tickets are to allow the new position to be created given the  existing portfolio configuration.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_trade_tickets_with_http_info(async_req=True)
>>> result = thread.get()

:param limit: Optional. When paginating, limit the number of returned results to this many. If not specified, a default  of 1000 is used.
:type limit: int
:param page: Optional. The pagination token to use to continue listing items from a previous call. Page values are  return from list calls, and must be supplied exactly as returned. Additionally, when specifying this  value, queryBody, and limit must not  be modified.
:type page: str
:param query_trade_tickets_request: The filter parameters used to retrieve instrument events.
:type query_trade_tickets_request: QueryTradeTicketsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPortfolioTradeTicket, int, HTTPHeaderDict)"""
        return self.__client.query_trade_tickets_with_http_info(**kwargs)

instrument_events_api = __InstrumentEventsApiAuthedAndStubbed()

class __InstrumentsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.InstrumentsApi)

   def batch_upsert_instrument_properties(self, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchUpsertInstrumentProperties: Batch upsert instruments properties  # noqa: E501

Create or update one or more properties for particular instruments.    Each instrument property is updated if it exists and created if it does not. For any failures, a reason  is provided.    Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_upsert_instrument_properties(request_body, async_req=True)
>>> result = thread.get()

:param request_body: A list of instruments and associated instrument properties to create or update. (required)
:type request_body: dict(str, UpsertInstrumentPropertyRequest)
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param identifier_effective_at: The effective datetime used to resolve each instrument from the provided identifiers. Defaults to the current LUSID system datetime if not specified.
:type identifier_effective_at: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial.
:type success_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BatchUpsertInstrumentPropertiesResponse"""
        return self.__client.batch_upsert_instrument_properties(request_body, **kwargs)

   def batch_upsert_instrument_properties_with_http_info(self, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchUpsertInstrumentProperties: Batch upsert instruments properties  # noqa: E501

Create or update one or more properties for particular instruments.    Each instrument property is updated if it exists and created if it does not. For any failures, a reason  is provided.    Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_upsert_instrument_properties_with_http_info(request_body, async_req=True)
>>> result = thread.get()

:param request_body: A list of instruments and associated instrument properties to create or update. (required)
:type request_body: dict(str, UpsertInstrumentPropertyRequest)
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param identifier_effective_at: The effective datetime used to resolve each instrument from the provided identifiers. Defaults to the current LUSID system datetime if not specified.
:type identifier_effective_at: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial.
:type success_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BatchUpsertInstrumentPropertiesResponse, int, HTTPHeaderDict)"""
        return self.__client.batch_upsert_instrument_properties_with_http_info(request_body, **kwargs)

   def delete_instrument(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstrument: Soft delete a single instrument  # noqa: E501

Soft delete a particular instrument, as identified by a particular instrument identifier.                Once deleted, an instrument is marked as inactive and can no longer be referenced when creating or updating  transactions or holdings. You can still query existing transactions and holdings related to the  deleted instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instrument(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeleteInstrumentResponse"""
        return self.__client.delete_instrument(identifier_type, identifier, **kwargs)

   def delete_instrument_properties(self, identifier_type: Any, identifier: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstrumentProperties: Delete instrument properties  # noqa: E501

Delete one or more properties from a particular instrument. If the properties are time-variant then an effective datetime from which  to delete properties must be specified. If the properties are perpetual then it is invalid to specify an effective datetime for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instrument_properties(identifier_type, identifier, request_body, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param request_body: A list of property keys from the 'Instruments' domain whose properties to delete. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeleteInstrumentPropertiesResponse"""
        return self.__client.delete_instrument_properties(identifier_type, identifier, request_body, **kwargs)

   def delete_instrument_properties_with_http_info(self, identifier_type: Any, identifier: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstrumentProperties: Delete instrument properties  # noqa: E501

Delete one or more properties from a particular instrument. If the properties are time-variant then an effective datetime from which  to delete properties must be specified. If the properties are perpetual then it is invalid to specify an effective datetime for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instrument_properties_with_http_info(identifier_type, identifier, request_body, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param request_body: A list of property keys from the 'Instruments' domain whose properties to delete. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeleteInstrumentPropertiesResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_instrument_properties_with_http_info(identifier_type, identifier, request_body, **kwargs)

   def delete_instrument_with_http_info(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstrument: Soft delete a single instrument  # noqa: E501

Soft delete a particular instrument, as identified by a particular instrument identifier.                Once deleted, an instrument is marked as inactive and can no longer be referenced when creating or updating  transactions or holdings. You can still query existing transactions and holdings related to the  deleted instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instrument_with_http_info(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeleteInstrumentResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_instrument_with_http_info(identifier_type, identifier, **kwargs)

   def delete_instruments(self, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstruments: Soft or hard delete multiple instruments  # noqa: E501

Deletes a number of instruments identified by LusidInstrumentId.                Soft deletion marks the instrument as inactive so it can no longer be referenced when creating or updating transactions or holdings. You can still query existing transactions and holdings related to the inactive instrument.                In addition to the above behaviour, hard deletion: (i) completely removes all external identifiers from the instrument; (ii) marks the instrument as 'Deleted'; (iii) prepends the instrument's name with 'DELETED '; (iv) prevents the instrument from being returned in list instruments queries.                Following hard deletion, an instrument may only be retrieved by making a direct get instrument request for the LusidInstrumentId. Instrument deletion cannot be undone. Please note that currency instruments cannot currently be deleted.  The maximum number of instruments that this method can delete per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instruments(request_body, async_req=True)
>>> result = thread.get()

:param request_body: The list of lusidInstrumentId's to delete. (required)
:type request_body: list[str]
:param delete_mode: The delete mode to use (defaults to 'Soft').
:type delete_mode: str
:param scope: The scope in which the instruments lie. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeleteInstrumentsResponse"""
        return self.__client.delete_instruments(request_body, **kwargs)

   def delete_instruments_with_http_info(self, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteInstruments: Soft or hard delete multiple instruments  # noqa: E501

Deletes a number of instruments identified by LusidInstrumentId.                Soft deletion marks the instrument as inactive so it can no longer be referenced when creating or updating transactions or holdings. You can still query existing transactions and holdings related to the inactive instrument.                In addition to the above behaviour, hard deletion: (i) completely removes all external identifiers from the instrument; (ii) marks the instrument as 'Deleted'; (iii) prepends the instrument's name with 'DELETED '; (iv) prevents the instrument from being returned in list instruments queries.                Following hard deletion, an instrument may only be retrieved by making a direct get instrument request for the LusidInstrumentId. Instrument deletion cannot be undone. Please note that currency instruments cannot currently be deleted.  The maximum number of instruments that this method can delete per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_instruments_with_http_info(request_body, async_req=True)
>>> result = thread.get()

:param request_body: The list of lusidInstrumentId's to delete. (required)
:type request_body: list[str]
:param delete_mode: The delete mode to use (defaults to 'Soft').
:type delete_mode: str
:param scope: The scope in which the instruments lie. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeleteInstrumentsResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_instruments_with_http_info(request_body, **kwargs)

   def get_all_possible_features(self, instrument_type: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAllPossibleFeatures: Provides list of all possible features for instrument type.  # noqa: E501

Provides all possible instrument features an instrument of a given type can provide.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_possible_features(instrument_type, async_req=True)
>>> result = thread.get()

:param instrument_type: A lusid instrument type e.g. Bond, FxOption. (required)
:type instrument_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[str])"""
        return self.__client.get_all_possible_features(instrument_type, **kwargs)

   def get_all_possible_features_with_http_info(self, instrument_type: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetAllPossibleFeatures: Provides list of all possible features for instrument type.  # noqa: E501

Provides all possible instrument features an instrument of a given type can provide.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_possible_features_with_http_info(instrument_type, async_req=True)
>>> result = thread.get()

:param instrument_type: A lusid instrument type e.g. Bond, FxOption. (required)
:type instrument_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[str]), int, HTTPHeaderDict)"""
        return self.__client.get_all_possible_features_with_http_info(instrument_type, **kwargs)

   def get_existing_instrument_capabilities(self, identifier: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetExistingInstrumentCapabilities: Retrieve capabilities of an existing instrument identified by LUID. These include instrument features, and if model is provided it also includes supported address keys and economic dependencies.  Given an lusid instrument id provides instrument capabilities, outlining features, and, given the model, the capabilities also include supported addresses as well as economic dependencies.  # noqa: E501

Returns instrument capabilities containing useful information about the instrument and the model. This includes  - features corresponding to the instrument e.g. Optionality:American, Other:InflationLinked  - supported addresses (if model provided) e.g. Valuation/Pv, Valuation/DirtyPriceKey, Valuation/Accrued  - economic dependencies (if model provided) e.g. Cash:USD, Fx:GBP.USD, Rates:GBP.GBPOIS  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_existing_instrument_capabilities(identifier, async_req=True)
>>> result = thread.get()

:param identifier: A lusid instrument id identifying the instrument. (required)
:type identifier: str
:param model: A pricing model for the instrument. Defaults to Unknown if not specified. If not specified the SupportedAddresses and EconomicDependencies are not provided.
:type model: str
:param effective_at: The effective datetime or cut label at which to retrieve the instrument.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param instrument_scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type instrument_scope: str
:param recipe_scope: The scope in which the recipe lies. When not supplied the scope is 'default'.
:type recipe_scope: str
:param recipe_code: A unique identifier for an entity, used to obtain configuration recipe details. Default configuration recipe is used if not provided.
:type recipe_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: InstrumentCapabilities"""
        return self.__client.get_existing_instrument_capabilities(identifier, **kwargs)

   def get_existing_instrument_capabilities_with_http_info(self, identifier: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetExistingInstrumentCapabilities: Retrieve capabilities of an existing instrument identified by LUID. These include instrument features, and if model is provided it also includes supported address keys and economic dependencies.  Given an lusid instrument id provides instrument capabilities, outlining features, and, given the model, the capabilities also include supported addresses as well as economic dependencies.  # noqa: E501

Returns instrument capabilities containing useful information about the instrument and the model. This includes  - features corresponding to the instrument e.g. Optionality:American, Other:InflationLinked  - supported addresses (if model provided) e.g. Valuation/Pv, Valuation/DirtyPriceKey, Valuation/Accrued  - economic dependencies (if model provided) e.g. Cash:USD, Fx:GBP.USD, Rates:GBP.GBPOIS  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_existing_instrument_capabilities_with_http_info(identifier, async_req=True)
>>> result = thread.get()

:param identifier: A lusid instrument id identifying the instrument. (required)
:type identifier: str
:param model: A pricing model for the instrument. Defaults to Unknown if not specified. If not specified the SupportedAddresses and EconomicDependencies are not provided.
:type model: str
:param effective_at: The effective datetime or cut label at which to retrieve the instrument.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param instrument_scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type instrument_scope: str
:param recipe_scope: The scope in which the recipe lies. When not supplied the scope is 'default'.
:type recipe_scope: str
:param recipe_code: A unique identifier for an entity, used to obtain configuration recipe details. Default configuration recipe is used if not provided.
:type recipe_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (InstrumentCapabilities, int, HTTPHeaderDict)"""
        return self.__client.get_existing_instrument_capabilities_with_http_info(identifier, **kwargs)

   def get_existing_instrument_models(self, identifier: Any, **kwargs) -> 'Any':
        """GetExistingInstrumentModels: Retrieve supported pricing models for an existing instrument identified by LUID.  # noqa: E501

Get the supported pricing models of a single instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_existing_instrument_models(identifier, async_req=True)
>>> result = thread.get()

:param identifier: A lusid instrument id identifying the instrument. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to retrieve the instrument.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param instrument_scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type instrument_scope: str
:param recipe_scope: The scope in which the recipe lies. When not supplied the scope is 'default'.
:type recipe_scope: str
:param recipe_code: A unique identifier for an entity, used to obtain configuration recipe details. Default configuration recipe is used if not provided.
:type recipe_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: InstrumentModels"""
        return self.__client.get_existing_instrument_models(identifier, **kwargs)

   def get_existing_instrument_models_with_http_info(self, identifier: Any, **kwargs) -> 'Any':
        """GetExistingInstrumentModels: Retrieve supported pricing models for an existing instrument identified by LUID.  # noqa: E501

Get the supported pricing models of a single instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_existing_instrument_models_with_http_info(identifier, async_req=True)
>>> result = thread.get()

:param identifier: A lusid instrument id identifying the instrument. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to retrieve the instrument.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param instrument_scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type instrument_scope: str
:param recipe_scope: The scope in which the recipe lies. When not supplied the scope is 'default'.
:type recipe_scope: str
:param recipe_code: A unique identifier for an entity, used to obtain configuration recipe details. Default configuration recipe is used if not provided.
:type recipe_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (InstrumentModels, int, HTTPHeaderDict)"""
        return self.__client.get_existing_instrument_models_with_http_info(identifier, **kwargs)

   def get_instrument(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """GetInstrument: Get instrument  # noqa: E501

Retrieve the definition of a particular instrument, as identified by a particular unique identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to use, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to retrieve the instrument.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Instrument' domain to decorate onto              the instrument, or from any domain that supports relationships to decorate onto related entities.              These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.
:type property_keys: list[str]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the instrument in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Instrument"""
        return self.__client.get_instrument(identifier_type, identifier, **kwargs)

   def get_instrument_identifier_types(self, **kwargs) -> 'Any':
        """GetInstrumentIdentifierTypes: Get instrument identifier types  # noqa: E501

Retrieve a list of all valid instrument identifier types and whether they are unique or not.                An instrument must have a value for at least one unique identifier type (it can have more than one unique type and value).  In addition, a value is automatically generated for a LUSID Instrument ID (LUID) unique type by the system.                An instrument can have values for multiple non-unique identifier types (or it can have zero non-unique types and values).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_identifier_types(async_req=True)
>>> result = thread.get()

:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfInstrumentIdTypeDescriptor"""
        return self.__client.get_instrument_identifier_types(**kwargs)

   def get_instrument_identifier_types_with_http_info(self, **kwargs) -> 'Any':
        """GetInstrumentIdentifierTypes: Get instrument identifier types  # noqa: E501

Retrieve a list of all valid instrument identifier types and whether they are unique or not.                An instrument must have a value for at least one unique identifier type (it can have more than one unique type and value).  In addition, a value is automatically generated for a LUSID Instrument ID (LUID) unique type by the system.                An instrument can have values for multiple non-unique identifier types (or it can have zero non-unique types and values).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_identifier_types_with_http_info(async_req=True)
>>> result = thread.get()

:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfInstrumentIdTypeDescriptor, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_identifier_types_with_http_info(**kwargs)

   def get_instrument_payment_diary(self, identifier_type: Any, identifier: Any, recipe_scope: Any, recipe_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetInstrumentPaymentDiary: Get instrument payment diary  # noqa: E501

Get the payment diary of a single instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_payment_diary(identifier_type, identifier, recipe_scope, recipe_code, async_req=True)
>>> result = thread.get()

:param identifier_type: The identifier being supplied e.g. "Figi". (required)
:type identifier_type: str
:param identifier: The value of the identifier for the requested instrument. (required)
:type identifier: str
:param recipe_scope: The scope of the valuation recipe being used to generate the payment diary (required)
:type recipe_scope: str
:param recipe_code: The code of the valuation recipe being used to generate the payment diary (required)
:type recipe_code: str
:param effective_at: The effective datetime or cut label at which to list the instrument's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the instrument's properties. Defaults to return the latest version of each property if not specified.
:type as_at: datetime
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: InstrumentPaymentDiary"""
        return self.__client.get_instrument_payment_diary(identifier_type, identifier, recipe_scope, recipe_code, **kwargs)

   def get_instrument_payment_diary_with_http_info(self, identifier_type: Any, identifier: Any, recipe_scope: Any, recipe_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetInstrumentPaymentDiary: Get instrument payment diary  # noqa: E501

Get the payment diary of a single instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_payment_diary_with_http_info(identifier_type, identifier, recipe_scope, recipe_code, async_req=True)
>>> result = thread.get()

:param identifier_type: The identifier being supplied e.g. "Figi". (required)
:type identifier_type: str
:param identifier: The value of the identifier for the requested instrument. (required)
:type identifier: str
:param recipe_scope: The scope of the valuation recipe being used to generate the payment diary (required)
:type recipe_scope: str
:param recipe_code: The code of the valuation recipe being used to generate the payment diary (required)
:type recipe_code: str
:param effective_at: The effective datetime or cut label at which to list the instrument's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the instrument's properties. Defaults to return the latest version of each property if not specified.
:type as_at: datetime
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (InstrumentPaymentDiary, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_payment_diary_with_http_info(identifier_type, identifier, recipe_scope, recipe_code, **kwargs)

   def get_instrument_properties(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentProperties: Get instrument properties  # noqa: E501

List all the properties of a particular instrument, as identified by a particular unique identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_properties(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to list the instrument's properties.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the instrument's properties. Defaults to returning              the latest version of each property if not specified.
:type as_at: datetime
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: InstrumentProperties"""
        return self.__client.get_instrument_properties(identifier_type, identifier, **kwargs)

   def get_instrument_properties_with_http_info(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentProperties: Get instrument properties  # noqa: E501

List all the properties of a particular instrument, as identified by a particular unique identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_properties_with_http_info(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to list the instrument's properties.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the instrument's properties. Defaults to returning              the latest version of each property if not specified.
:type as_at: datetime
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (InstrumentProperties, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_properties_with_http_info(identifier_type, identifier, **kwargs)

   def get_instrument_property_time_series(self, identifier_type: Any, identifier: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentPropertyTimeSeries: Get instrument property time series  # noqa: E501

Retrieve the complete time series (history) for a particular property of an instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_property_time_series(identifier_type, identifier, property_key, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param property_key: The property key of a property from the 'Instrument' domain whose history to retrieve.              This must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'. (required)
:type property_key: str
:param identifier_effective_at: The effective datetime used to resolve the instrument from the identifier.              Defaults to the current LUSID system datetime if not specified.
:type identifier_effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument's property history. Defaults to              returning the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the results. For more information about filtering,              see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing properties; this value is returned from              the previous call. If a pagination token is provided, the <i>filter</i>, <i>effectiveAt</i> and              <i>asAt</i> fields must not have changed since the original request. For more information, see              https://support.lusid.com/knowledgebase/article/KA-01915.
:type page: str
:param limit: When paginating, limit the results to this number.
:type limit: int
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyInterval"""
        return self.__client.get_instrument_property_time_series(identifier_type, identifier, property_key, **kwargs)

   def get_instrument_property_time_series_with_http_info(self, identifier_type: Any, identifier: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentPropertyTimeSeries: Get instrument property time series  # noqa: E501

Retrieve the complete time series (history) for a particular property of an instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_property_time_series_with_http_info(identifier_type, identifier, property_key, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param property_key: The property key of a property from the 'Instrument' domain whose history to retrieve.              This must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'. (required)
:type property_key: str
:param identifier_effective_at: The effective datetime used to resolve the instrument from the identifier.              Defaults to the current LUSID system datetime if not specified.
:type identifier_effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument's property history. Defaults to              returning the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the results. For more information about filtering,              see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing properties; this value is returned from              the previous call. If a pagination token is provided, the <i>filter</i>, <i>effectiveAt</i> and              <i>asAt</i> fields must not have changed since the original request. For more information, see              https://support.lusid.com/knowledgebase/article/KA-01915.
:type page: str
:param limit: When paginating, limit the results to this number.
:type limit: int
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyInterval, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_property_time_series_with_http_info(identifier_type, identifier, property_key, **kwargs)

   def get_instrument_relationships(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentRelationships: Get Instrument relationships  # noqa: E501

Get relationships for a particular Instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_relationships(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: An identifier type attached to the Instrument. (required)
:type identifier_type: str
:param identifier: The identifier value. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param scope: The entity scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelationship"""
        return self.__client.get_instrument_relationships(identifier_type, identifier, **kwargs)

   def get_instrument_relationships_with_http_info(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetInstrumentRelationships: Get Instrument relationships  # noqa: E501

Get relationships for a particular Instrument.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_relationships_with_http_info(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: An identifier type attached to the Instrument. (required)
:type identifier_type: str
:param identifier: The identifier value. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param scope: The entity scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelationship, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_relationships_with_http_info(identifier_type, identifier, **kwargs)

   def get_instrument_with_http_info(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """GetInstrument: Get instrument  # noqa: E501

Retrieve the definition of a particular instrument, as identified by a particular unique identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instrument_with_http_info(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to use, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to retrieve the instrument.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Instrument' domain to decorate onto              the instrument, or from any domain that supports relationships to decorate onto related entities.              These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.
:type property_keys: list[str]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the instrument in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Instrument, int, HTTPHeaderDict)"""
        return self.__client.get_instrument_with_http_info(identifier_type, identifier, **kwargs)

   def get_instruments(self, identifier_type: Any, request_body: Any, **kwargs) -> 'Any':
        """GetInstruments: Get instruments  # noqa: E501

Retrieve the definition of one or more instruments, as identified by a collection of unique identifiers.                Note that to retrieve all the instruments in the instrument master, use the List instruments endpoint instead.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instruments(identifier_type, request_body, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to use, for example 'Figi'. (required)
:type identifier_type: str
:param request_body: A list of one or more <i>identifierType</i> values to use to identify instruments. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to retrieve the instrument definitions.               Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument definitions.               Defaults to returning the latest version of each instrument definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Instrument' domain to decorate onto               each instrument, or from any domain that supports relationships to decorate onto related entities.               These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.
:type property_keys: list[str]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities               onto each instrument in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetInstrumentsResponse"""
        return self.__client.get_instruments(identifier_type, request_body, **kwargs)

   def get_instruments_with_http_info(self, identifier_type: Any, request_body: Any, **kwargs) -> 'Any':
        """GetInstruments: Get instruments  # noqa: E501

Retrieve the definition of one or more instruments, as identified by a collection of unique identifiers.                Note that to retrieve all the instruments in the instrument master, use the List instruments endpoint instead.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_instruments_with_http_info(identifier_type, request_body, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to use, for example 'Figi'. (required)
:type identifier_type: str
:param request_body: A list of one or more <i>identifierType</i> values to use to identify instruments. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to retrieve the instrument definitions.               Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument definitions.               Defaults to returning the latest version of each instrument definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Instrument' domain to decorate onto               each instrument, or from any domain that supports relationships to decorate onto related entities.               These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.
:type property_keys: list[str]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities               onto each instrument in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetInstrumentsResponse, int, HTTPHeaderDict)"""
        return self.__client.get_instruments_with_http_info(identifier_type, request_body, **kwargs)

   def list_instrument_properties(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListInstrumentProperties: Get instrument properties (with Pagination)  # noqa: E501

List all the properties of a particular instrument, as identified by a particular unique identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_instrument_properties(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to list the instrument's properties.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the instrument's properties. Defaults to returning              the latest version of each property if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing commands; this value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the results per page to this number.
:type limit: int
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfProperty"""
        return self.__client.list_instrument_properties(identifier_type, identifier, **kwargs)

   def list_instrument_properties_with_http_info(self, identifier_type: Any, identifier: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListInstrumentProperties: Get instrument properties (with Pagination)  # noqa: E501

List all the properties of a particular instrument, as identified by a particular unique identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_instrument_properties_with_http_info(identifier_type, identifier, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param effective_at: The effective datetime or cut label at which to list the instrument's properties.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the instrument's properties. Defaults to returning              the latest version of each property if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing commands; this value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the results per page to this number.
:type limit: int
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfProperty, int, HTTPHeaderDict)"""
        return self.__client.list_instrument_properties_with_http_info(identifier_type, identifier, **kwargs)

   def list_instruments(self, **kwargs) -> 'Any':
        """ListInstruments: List instruments  # noqa: E501

List all the instruments in the instrument master.                To retrieve a particular set of instruments instead, use the Get instruments endpoint.  The maximum number of instruments that this method can list per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_instruments(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list instruments. Defaults to returning the latest               version of each instrument if not specified.
:type as_at: datetime
:param effective_at: The effective datetime or cut label at which to list instruments.               Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param page: The pagination token to use to continue listing instruments; this value is returned from               the previous call. If a pagination token is provided, the <i>sortBy</i>, <i>filter</i>, <i>effectiveAt</i> and               <i>asAt</i> fields must not have changed since the original request.               For more information, see https://support.lusid.com/knowledgebase/article/KA-01915.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the results to this number.
:type limit: int
:param filter: Expression to filter the result set. Defaults to filtering out inactive instruments               (that is, those that have been deleted). For more information about filtering results,               see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param instrument_property_keys: A list of property keys from the 'Instrument' domain to decorate onto               instruments, or from any domain that supports relationships to decorate onto related entities.               These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.
:type instrument_property_keys: list[str]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities               onto each instrument in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfInstrument"""
        return self.__client.list_instruments(**kwargs)

   def list_instruments_with_http_info(self, **kwargs) -> 'Any':
        """ListInstruments: List instruments  # noqa: E501

List all the instruments in the instrument master.                To retrieve a particular set of instruments instead, use the Get instruments endpoint.  The maximum number of instruments that this method can list per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_instruments_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list instruments. Defaults to returning the latest               version of each instrument if not specified.
:type as_at: datetime
:param effective_at: The effective datetime or cut label at which to list instruments.               Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param page: The pagination token to use to continue listing instruments; this value is returned from               the previous call. If a pagination token is provided, the <i>sortBy</i>, <i>filter</i>, <i>effectiveAt</i> and               <i>asAt</i> fields must not have changed since the original request.               For more information, see https://support.lusid.com/knowledgebase/article/KA-01915.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the results to this number.
:type limit: int
:param filter: Expression to filter the result set. Defaults to filtering out inactive instruments               (that is, those that have been deleted). For more information about filtering results,               see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param instrument_property_keys: A list of property keys from the 'Instrument' domain to decorate onto               instruments, or from any domain that supports relationships to decorate onto related entities.               These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.
:type instrument_property_keys: list[str]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities               onto each instrument in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfInstrument, int, HTTPHeaderDict)"""
        return self.__client.list_instruments_with_http_info(**kwargs)

   def query_instrument_capabilities(self, lusid_instrument: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryInstrumentCapabilities: Query capabilities of a particular instrument in advance of creating it. These include instrument features, and if model is provided it also includes supported address keys and economic dependencies.  # noqa: E501

Returns instrument capabilities containing useful information about the instrument and the model. This includes  - features corresponding to the instrument e.g. Optionality:American, Other:InflationLinked  - supported addresses (if model provided) e.g. Valuation/Pv, Valuation/DirtyPriceKey, Valuation/Accrued  - economic dependencies (if model provided) e.g. Cash:USD, Fx:GBP.USD, Rates:GBP.GBPOIS  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_instrument_capabilities(lusid_instrument, async_req=True)
>>> result = thread.get()

:param lusid_instrument: The definition of the instrument. (required)
:type lusid_instrument: LusidInstrument
:param model: A pricing model for the instrument. Defaults to Unknown if not specified. If not specified the SupportedAddresses and EconomicDependencies are not provided.
:type model: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: InstrumentCapabilities"""
        return self.__client.query_instrument_capabilities(lusid_instrument, **kwargs)

   def query_instrument_capabilities_with_http_info(self, lusid_instrument: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] QueryInstrumentCapabilities: Query capabilities of a particular instrument in advance of creating it. These include instrument features, and if model is provided it also includes supported address keys and economic dependencies.  # noqa: E501

Returns instrument capabilities containing useful information about the instrument and the model. This includes  - features corresponding to the instrument e.g. Optionality:American, Other:InflationLinked  - supported addresses (if model provided) e.g. Valuation/Pv, Valuation/DirtyPriceKey, Valuation/Accrued  - economic dependencies (if model provided) e.g. Cash:USD, Fx:GBP.USD, Rates:GBP.GBPOIS  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.query_instrument_capabilities_with_http_info(lusid_instrument, async_req=True)
>>> result = thread.get()

:param lusid_instrument: The definition of the instrument. (required)
:type lusid_instrument: LusidInstrument
:param model: A pricing model for the instrument. Defaults to Unknown if not specified. If not specified the SupportedAddresses and EconomicDependencies are not provided.
:type model: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (InstrumentCapabilities, int, HTTPHeaderDict)"""
        return self.__client.query_instrument_capabilities_with_http_info(lusid_instrument, **kwargs)

   def update_instrument_identifier(self, identifier_type: Any, identifier: Any, update_instrument_identifier_request: Any, **kwargs) -> 'Any':
        """UpdateInstrumentIdentifier: Update instrument identifier  # noqa: E501

Create, update or delete a particular instrument identifier for an instrument.                To delete the identifier, leave the value unspecified in the request. If not being deleted, the  identifier is updated if it exists and created if it does not.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_instrument_identifier(identifier_type, identifier, update_instrument_identifier_request, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param update_instrument_identifier_request: The identifier to update or delete. This need not be the same value as the               'identifier' parameter used to retrieve the instrument. (required)
:type update_instrument_identifier_request: UpdateInstrumentIdentifierRequest
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Instrument"""
        return self.__client.update_instrument_identifier(identifier_type, identifier, update_instrument_identifier_request, **kwargs)

   def update_instrument_identifier_with_http_info(self, identifier_type: Any, identifier: Any, update_instrument_identifier_request: Any, **kwargs) -> 'Any':
        """UpdateInstrumentIdentifier: Update instrument identifier  # noqa: E501

Create, update or delete a particular instrument identifier for an instrument.                To delete the identifier, leave the value unspecified in the request. If not being deleted, the  identifier is updated if it exists and created if it does not.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_instrument_identifier_with_http_info(identifier_type, identifier, update_instrument_identifier_request, async_req=True)
>>> result = thread.get()

:param identifier_type: The unique identifier type to search, for example 'Figi'. (required)
:type identifier_type: str
:param identifier: An <i>identifierType</i> value to use to identify the instrument, for example 'BBG000BLNNV0'. (required)
:type identifier: str
:param update_instrument_identifier_request: The identifier to update or delete. This need not be the same value as the               'identifier' parameter used to retrieve the instrument. (required)
:type update_instrument_identifier_request: UpdateInstrumentIdentifierRequest
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Instrument, int, HTTPHeaderDict)"""
        return self.__client.update_instrument_identifier_with_http_info(identifier_type, identifier, update_instrument_identifier_request, **kwargs)

   def upsert_instruments(self, request_body: Any, **kwargs) -> 'Any':
        """UpsertInstruments: Upsert instruments  # noqa: E501

Create or update one or more instruments in the instrument master. An instrument is updated  if it already exists and created if it does not.                In the request, each instrument definition should be keyed by a unique correlation ID. This ID is ephemeral  and not stored by LUSID. It serves only to easily identify each instrument in the response.                Note that an instrument must have at least one unique identifier, which is a combination of a type  (such as 'Figi') and a value (such as 'BBG000BS1N49'). In addition, a random value is automatically  generated for a LUSID Instrument ID (LUID) unique type by the system. For more information, see  https://support.lusid.com/knowledgebase/article/KA-01862.                The response returns both the collection of successfully created or updated instruments, as well as those  that failed. For each failure, a reason is provided. It is important to check the failed set for  unsuccessful results.  The maximum number of instruments that this method can upsert per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_instruments(request_body, async_req=True)
>>> result = thread.get()

:param request_body: The definitions of the instruments to create or update. (required)
:type request_body: dict(str, InstrumentDefinition)
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertInstrumentsResponse"""
        return self.__client.upsert_instruments(request_body, **kwargs)

   def upsert_instruments_properties(self, upsert_instrument_property_request: Any, **kwargs) -> 'Any':
        """UpsertInstrumentsProperties: Upsert instruments properties  # noqa: E501

Create or update one or more properties for particular instruments.                Each instrument property is updated if it exists and created if it does not. For any failures, a reason  is provided.                Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_instruments_properties(upsert_instrument_property_request, async_req=True)
>>> result = thread.get()

:param upsert_instrument_property_request: A list of instruments and associated instrument properties to create or update. (required)
:type upsert_instrument_property_request: list[UpsertInstrumentPropertyRequest]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertInstrumentPropertiesResponse"""
        return self.__client.upsert_instruments_properties(upsert_instrument_property_request, **kwargs)

   def upsert_instruments_properties_with_http_info(self, upsert_instrument_property_request: Any, **kwargs) -> 'Any':
        """UpsertInstrumentsProperties: Upsert instruments properties  # noqa: E501

Create or update one or more properties for particular instruments.                Each instrument property is updated if it exists and created if it does not. For any failures, a reason  is provided.                Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_instruments_properties_with_http_info(upsert_instrument_property_request, async_req=True)
>>> result = thread.get()

:param upsert_instrument_property_request: A list of instruments and associated instrument properties to create or update. (required)
:type upsert_instrument_property_request: list[UpsertInstrumentPropertyRequest]
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertInstrumentPropertiesResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_instruments_properties_with_http_info(upsert_instrument_property_request, **kwargs)

   def upsert_instruments_with_http_info(self, request_body: Any, **kwargs) -> 'Any':
        """UpsertInstruments: Upsert instruments  # noqa: E501

Create or update one or more instruments in the instrument master. An instrument is updated  if it already exists and created if it does not.                In the request, each instrument definition should be keyed by a unique correlation ID. This ID is ephemeral  and not stored by LUSID. It serves only to easily identify each instrument in the response.                Note that an instrument must have at least one unique identifier, which is a combination of a type  (such as 'Figi') and a value (such as 'BBG000BS1N49'). In addition, a random value is automatically  generated for a LUSID Instrument ID (LUID) unique type by the system. For more information, see  https://support.lusid.com/knowledgebase/article/KA-01862.                The response returns both the collection of successfully created or updated instruments, as well as those  that failed. For each failure, a reason is provided. It is important to check the failed set for  unsuccessful results.  The maximum number of instruments that this method can upsert per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_instruments_with_http_info(request_body, async_req=True)
>>> result = thread.get()

:param request_body: The definitions of the instruments to create or update. (required)
:type request_body: dict(str, InstrumentDefinition)
:param scope: The scope in which the instrument lies. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertInstrumentsResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_instruments_with_http_info(request_body, **kwargs)

instruments_api = __InstrumentsApiAuthedAndStubbed()

class __LegacyComplianceApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.LegacyComplianceApi)

   def delete_legacy_compliance_rule(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteLegacyComplianceRule: Deletes a compliance rule.  # noqa: E501

Deletes the rule for all effective time.                The rule will remain viewable at previous as at times, and as part of the results of compliance runs, but it  will no longer be considered in new compliance runs.                This cannot be undone.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legacy_compliance_rule(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule scope. (required)
:type scope: str
:param code: The compliance rule code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_legacy_compliance_rule(scope, code, **kwargs)

   def delete_legacy_compliance_rule_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteLegacyComplianceRule: Deletes a compliance rule.  # noqa: E501

Deletes the rule for all effective time.                The rule will remain viewable at previous as at times, and as part of the results of compliance runs, but it  will no longer be considered in new compliance runs.                This cannot be undone.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legacy_compliance_rule_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule scope. (required)
:type scope: str
:param code: The compliance rule code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_legacy_compliance_rule_with_http_info(scope, code, **kwargs)

   def get_legacy_breached_orders_info(self, run_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegacyBreachedOrdersInfo: Get the Ids of Breached orders in a given compliance run and the corresponding list of rules that could have caused it.  # noqa: E501

Use this endpoint to get a list or breached orders and the set of rules that may have caused the breach.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legacy_breached_orders_info(run_id, async_req=True)
>>> result = thread.get()

:param run_id: The RunId that the results should be checked for (required)
:type run_id: str
:param order_scope: Optional. Find rules related to a specific order by providing an Order Scope/Code combination
:type order_scope: str
:param order_code: Optional. Find rules related to a specific order by providing an Order Scope/Code combination
:type order_code: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfComplianceBreachedOrderInfo"""
        return self.__client.get_legacy_breached_orders_info(run_id, **kwargs)

   def get_legacy_breached_orders_info_with_http_info(self, run_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegacyBreachedOrdersInfo: Get the Ids of Breached orders in a given compliance run and the corresponding list of rules that could have caused it.  # noqa: E501

Use this endpoint to get a list or breached orders and the set of rules that may have caused the breach.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legacy_breached_orders_info_with_http_info(run_id, async_req=True)
>>> result = thread.get()

:param run_id: The RunId that the results should be checked for (required)
:type run_id: str
:param order_scope: Optional. Find rules related to a specific order by providing an Order Scope/Code combination
:type order_scope: str
:param order_code: Optional. Find rules related to a specific order by providing an Order Scope/Code combination
:type order_code: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfComplianceBreachedOrderInfo, int, HTTPHeaderDict)"""
        return self.__client.get_legacy_breached_orders_info_with_http_info(run_id, **kwargs)

   def get_legacy_compliance_rule(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegacyComplianceRule: Retrieve the definition of single compliance rule.  # noqa: E501

Retrieves the compliance rule definition at the given effective and as at times.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legacy_compliance_rule(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule scope. (required)
:type scope: str
:param code: The compliance rule code. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the rule definition. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definition. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRule"""
        return self.__client.get_legacy_compliance_rule(scope, code, **kwargs)

   def get_legacy_compliance_rule_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegacyComplianceRule: Retrieve the definition of single compliance rule.  # noqa: E501

Retrieves the compliance rule definition at the given effective and as at times.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legacy_compliance_rule_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The compliance rule scope. (required)
:type scope: str
:param code: The compliance rule code. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the rule definition. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definition. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRule, int, HTTPHeaderDict)"""
        return self.__client.get_legacy_compliance_rule_with_http_info(scope, code, **kwargs)

   def get_legacy_compliance_run_results(self, run_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegacyComplianceRunResults: Get the details of a single compliance run.  # noqa: E501

Use this endpoint to fetch the detail associated with a specific compliance run, including a breakdown  of the passing state of each rule, portfolio combination.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legacy_compliance_run_results(run_id, async_req=True)
>>> result = thread.get()

:param run_id: The unique identifier of the compliance run requested. (required)
:type run_id: str
:param page: The pagination token to use to continue listing compliance rule results from a previous call to list compliance rule result.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfComplianceRuleResult"""
        return self.__client.get_legacy_compliance_run_results(run_id, **kwargs)

   def get_legacy_compliance_run_results_with_http_info(self, run_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegacyComplianceRunResults: Get the details of a single compliance run.  # noqa: E501

Use this endpoint to fetch the detail associated with a specific compliance run, including a breakdown  of the passing state of each rule, portfolio combination.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legacy_compliance_run_results_with_http_info(run_id, async_req=True)
>>> result = thread.get()

:param run_id: The unique identifier of the compliance run requested. (required)
:type run_id: str
:param page: The pagination token to use to continue listing compliance rule results from a previous call to list compliance rule result.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfComplianceRuleResult, int, HTTPHeaderDict)"""
        return self.__client.get_legacy_compliance_run_results_with_http_info(run_id, **kwargs)

   def list_legacy_compliance_rules(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListLegacyComplianceRules: List compliance rules, with optional filtering.  # noqa: E501

For more information about filtering results,  see https://support.lusid.com/knowledgebase/article/KA-01914.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_legacy_compliance_rules(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to retrieve the rule definitions. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing entities; this value is returned from the previous call. If  a pagination token is provided, the filter, effectiveAt and asAt fields must not have changed since the  original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfComplianceRule"""
        return self.__client.list_legacy_compliance_rules(**kwargs)

   def list_legacy_compliance_rules_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListLegacyComplianceRules: List compliance rules, with optional filtering.  # noqa: E501

For more information about filtering results,  see https://support.lusid.com/knowledgebase/article/KA-01914.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_legacy_compliance_rules_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to retrieve the rule definitions. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing entities; this value is returned from the previous call. If  a pagination token is provided, the filter, effectiveAt and asAt fields must not have changed since the  original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfComplianceRule, int, HTTPHeaderDict)"""
        return self.__client.list_legacy_compliance_rules_with_http_info(**kwargs)

   def list_legacy_compliance_run_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListLegacyComplianceRunInfo: List historical compliance run ids.  # noqa: E501

Use this endpoint to fetch a list of all historical compliance runs.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_legacy_compliance_run_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param page: The pagination token to use to continue listing compliance runs from a previous call to list compliance runs.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfComplianceRunInfo"""
        return self.__client.list_legacy_compliance_run_info(**kwargs)

   def list_legacy_compliance_run_info_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListLegacyComplianceRunInfo: List historical compliance run ids.  # noqa: E501

Use this endpoint to fetch a list of all historical compliance runs.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_legacy_compliance_run_info_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: Optional. The time at which to get results from. Default : latest
:type as_at: datetime
:param page: The pagination token to use to continue listing compliance runs from a previous call to list compliance runs.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfComplianceRunInfo, int, HTTPHeaderDict)"""
        return self.__client.list_legacy_compliance_run_info_with_http_info(**kwargs)

   def run_legacy_compliance(self, is_pre_trade: Any, recipe_id_scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] RunLegacyCompliance: Kick off the compliance check process  # noqa: E501

Use this endpoint to fetch the start a compliance run, based on a pre-set mapping file.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.run_legacy_compliance(is_pre_trade, recipe_id_scope, async_req=True)
>>> result = thread.get()

:param is_pre_trade: Required: Boolean flag indicating if a run should be PreTrade (Including orders). For post-trade only, set to false (required)
:type is_pre_trade: bool
:param recipe_id_scope: Required: the scope of the recipe to be used (required)
:type recipe_id_scope: str
:param recipe_id_code: Optional: The code of the recipe to be used. If left blank, the default recipe will be used.
:type recipe_id_code: str
:param by_taxlots: Optional.
:type by_taxlots: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRunInfo"""
        return self.__client.run_legacy_compliance(is_pre_trade, recipe_id_scope, **kwargs)

   def run_legacy_compliance_with_http_info(self, is_pre_trade: Any, recipe_id_scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] RunLegacyCompliance: Kick off the compliance check process  # noqa: E501

Use this endpoint to fetch the start a compliance run, based on a pre-set mapping file.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.run_legacy_compliance_with_http_info(is_pre_trade, recipe_id_scope, async_req=True)
>>> result = thread.get()

:param is_pre_trade: Required: Boolean flag indicating if a run should be PreTrade (Including orders). For post-trade only, set to false (required)
:type is_pre_trade: bool
:param recipe_id_scope: Required: the scope of the recipe to be used (required)
:type recipe_id_scope: str
:param recipe_id_code: Optional: The code of the recipe to be used. If left blank, the default recipe will be used.
:type recipe_id_code: str
:param by_taxlots: Optional.
:type by_taxlots: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRunInfo, int, HTTPHeaderDict)"""
        return self.__client.run_legacy_compliance_with_http_info(is_pre_trade, recipe_id_scope, **kwargs)

   def upsert_legacy_compliance_rules(self, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertLegacyComplianceRules: Upsert compliance rules.  # noqa: E501

To upsert a new rule, the code field must be left empty, a code will then be assigned and returned as part  of the response. To update an existing rule, include the rule code. It is possible to both create and update  compliance rules in the same request.                The upsert is transactional - either all create/update operations will succeed or none of them will.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legacy_compliance_rules(request_body, async_req=True)
>>> result = thread.get()

:param request_body: A dictionary of upsert request identifiers to rule upsert requests. The request               identifiers are valid for the request only and can be used to link the upserted compliance rule to the code               of a created compliance rule. (required)
:type request_body: dict(str, ComplianceRuleUpsertRequest)
:param effective_at: The effective datetime or cut label at which the rule will take effect. Defaults to the current LUSID  system datetime if not specified. In the case of an update, the changes will take place from this effective  time until the next effective time that the rule as been upserted at. For example, consider a rule that  already exists, and has previously had an update applied so that the definition will change on the first day  of the coming month. An upsert effective from the current day will only change the definition until the  first day of the coming month. An additional upsert at the same time (first day of the month) is required  if the newly-updated definition is to supersede the future definition.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ComplianceRuleUpsertResponse"""
        return self.__client.upsert_legacy_compliance_rules(request_body, **kwargs)

   def upsert_legacy_compliance_rules_with_http_info(self, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertLegacyComplianceRules: Upsert compliance rules.  # noqa: E501

To upsert a new rule, the code field must be left empty, a code will then be assigned and returned as part  of the response. To update an existing rule, include the rule code. It is possible to both create and update  compliance rules in the same request.                The upsert is transactional - either all create/update operations will succeed or none of them will.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legacy_compliance_rules_with_http_info(request_body, async_req=True)
>>> result = thread.get()

:param request_body: A dictionary of upsert request identifiers to rule upsert requests. The request               identifiers are valid for the request only and can be used to link the upserted compliance rule to the code               of a created compliance rule. (required)
:type request_body: dict(str, ComplianceRuleUpsertRequest)
:param effective_at: The effective datetime or cut label at which the rule will take effect. Defaults to the current LUSID  system datetime if not specified. In the case of an update, the changes will take place from this effective  time until the next effective time that the rule as been upserted at. For example, consider a rule that  already exists, and has previously had an update applied so that the definition will change on the first day  of the coming month. An upsert effective from the current day will only change the definition until the  first day of the coming month. An additional upsert at the same time (first day of the month) is required  if the newly-updated definition is to supersede the future definition.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ComplianceRuleUpsertResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_legacy_compliance_rules_with_http_info(request_body, **kwargs)

legacy_compliance_api = __LegacyComplianceApiAuthedAndStubbed()

class __LegalEntitiesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.LegalEntitiesApi)

   def delete_legal_entity(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntity: Delete Legal Entity  # noqa: E501

Delete a legal entity. Deletion will be valid from the legal entity's creation datetime.  This means that the legal entity will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: The scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: The code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with defined              identifier type uniquely identifies the legal entity to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_legal_entity(id_type_scope, id_type_code, code, **kwargs)

   def delete_legal_entity_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntityAccessMetadata: Delete a Legal Entity Access Metadata entry  # noqa: E501

Deletes the Legal Entity Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_access_metadata(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_legal_entity_access_metadata(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def delete_legal_entity_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntityAccessMetadata: Delete a Legal Entity Access Metadata entry  # noqa: E501

Deletes the Legal Entity Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def delete_legal_entity_identifiers(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntityIdentifiers: Delete Legal Entity Identifiers  # noqa: E501

Delete identifiers that belong to the given property keys of the legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_identifiers(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param property_keys: The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. "LegalEntity/CreditAgency/Identifier". Each property must be from the "LegalEntity" domain. Identifiers or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime if identifiers are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_legal_entity_identifiers(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_legal_entity_identifiers_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntityIdentifiers: Delete Legal Entity Identifiers  # noqa: E501

Delete identifiers that belong to the given property keys of the legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_identifiers_with_http_info(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param property_keys: The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. "LegalEntity/CreditAgency/Identifier". Each property must be from the "LegalEntity" domain. Identifiers or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime if identifiers are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_legal_entity_identifiers_with_http_info(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_legal_entity_properties(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntityProperties: Delete Legal Entity Properties  # noqa: E501

Delete all properties that belong to the given property keys of the legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_properties(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param property_keys: The property keys of the legal entities properties to delete. These take the format              {domain}/{scope}/{code} e.g. "LegalEntity/CompanyDetails/Role". Each property must be from the "LegalEntity" domain. Properties or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_legal_entity_properties(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_legal_entity_properties_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntityProperties: Delete Legal Entity Properties  # noqa: E501

Delete all properties that belong to the given property keys of the legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_properties_with_http_info(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param property_keys: The property keys of the legal entities properties to delete. These take the format              {domain}/{scope}/{code} e.g. "LegalEntity/CompanyDetails/Role". Each property must be from the "LegalEntity" domain. Properties or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_legal_entity_properties_with_http_info(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_legal_entity_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteLegalEntity: Delete Legal Entity  # noqa: E501

Delete a legal entity. Deletion will be valid from the legal entity's creation datetime.  This means that the legal entity will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_legal_entity_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: The scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: The code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with defined              identifier type uniquely identifies the legal entity to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_legal_entity_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_all_legal_entity_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllLegalEntityAccessMetadata: Get Access Metadata rules for a Legal Entity  # noqa: E501

Pass the Scope and Code of the Legal Entity identifier along with the Legal Entity code parameter to retrieve the associated Access Metadata  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_legal_entity_access_metadata(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.get_all_legal_entity_access_metadata(id_type_scope, id_type_code, code, **kwargs)

   def get_all_legal_entity_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllLegalEntityAccessMetadata: Get Access Metadata rules for a Legal Entity  # noqa: E501

Pass the Scope and Code of the Legal Entity identifier along with the Legal Entity code parameter to retrieve the associated Access Metadata  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.get_all_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_legal_entity(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntity: Get Legal Entity  # noqa: E501

Retrieve the definition of a legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param property_keys: A list of property keys or identifier types (as property keys) from the "LegalEntity" domain              to include for found legal entity, or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to retrieve the legal entity. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the legal entity. Defaults to return the latest version of the legal entity if not specified.
:type as_at: datetime
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the legal entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: LegalEntity"""
        return self.__client.get_legal_entity(id_type_scope, id_type_code, code, **kwargs)

   def get_legal_entity_access_metadata_by_key(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Legal Entity  # noqa: E501

Get a specific Legal Entity Access Metadata by specifying the corresponding identifier parts and Legal Entity code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_access_metadata_by_key(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[AccessMetadataValue]"""
        return self.__client.get_legal_entity_access_metadata_by_key(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def get_legal_entity_access_metadata_by_key_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntityAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Legal Entity  # noqa: E501

Get a specific Legal Entity Access Metadata by specifying the corresponding identifier parts and Legal Entity code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_access_metadata_by_key_with_http_info(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[AccessMetadataValue], int, HTTPHeaderDict)"""
        return self.__client.get_legal_entity_access_metadata_by_key_with_http_info(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def get_legal_entity_property_time_series(self, id_type_scope: Any, id_type_code: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntityPropertyTimeSeries: Get Legal Entity Property Time Series  # noqa: E501

List the complete time series of a legal entity property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_property_time_series(id_type_scope, id_type_code, code, property_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely identifies the legal entity. (required)
:type code: str
:param property_key: The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".              Each property must be from the "LegalEntity" domain. (required)
:type property_key: str
:param as_at: The asAt datetime at which to list the person's property history. Defaults to return the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyInterval"""
        return self.__client.get_legal_entity_property_time_series(id_type_scope, id_type_code, code, property_key, **kwargs)

   def get_legal_entity_property_time_series_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntityPropertyTimeSeries: Get Legal Entity Property Time Series  # noqa: E501

List the complete time series of a legal entity property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_property_time_series_with_http_info(id_type_scope, id_type_code, code, property_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely identifies the legal entity. (required)
:type code: str
:param property_key: The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".              Each property must be from the "LegalEntity" domain. (required)
:type property_key: str
:param as_at: The asAt datetime at which to list the person's property history. Defaults to return the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyInterval, int, HTTPHeaderDict)"""
        return self.__client.get_legal_entity_property_time_series_with_http_info(id_type_scope, id_type_code, code, property_key, **kwargs)

   def get_legal_entity_relations(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegalEntityRelations: Get Relations for Legal Entity  # noqa: E501

Get relations for the specified Legal Entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_relations(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the legal entity's relations. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelation"""
        return self.__client.get_legal_entity_relations(id_type_scope, id_type_code, code, **kwargs)

   def get_legal_entity_relations_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetLegalEntityRelations: Get Relations for Legal Entity  # noqa: E501

Get relations for the specified Legal Entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_relations_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the legal entity's relations. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelation, int, HTTPHeaderDict)"""
        return self.__client.get_legal_entity_relations_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_legal_entity_relationships(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntityRelationships: Get Relationships for Legal Entity  # noqa: E501

Get Relationships for the specified Legal Entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_relationships(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity's identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity's identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelationship"""
        return self.__client.get_legal_entity_relationships(id_type_scope, id_type_code, code, **kwargs)

   def get_legal_entity_relationships_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntityRelationships: Get Relationships for Legal Entity  # noqa: E501

Get Relationships for the specified Legal Entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_relationships_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity's identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity's identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelationship, int, HTTPHeaderDict)"""
        return self.__client.get_legal_entity_relationships_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_legal_entity_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetLegalEntity: Get Legal Entity  # noqa: E501

Retrieve the definition of a legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_legal_entity_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param property_keys: A list of property keys or identifier types (as property keys) from the "LegalEntity" domain              to include for found legal entity, or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to retrieve the legal entity. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the legal entity. Defaults to return the latest version of the legal entity if not specified.
:type as_at: datetime
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the legal entity in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (LegalEntity, int, HTTPHeaderDict)"""
        return self.__client.get_legal_entity_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def list_all_legal_entities(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAllLegalEntities: List Legal Entities  # noqa: E501

List all legal entities which the user is entitled to see.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_all_legal_entities(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the legal entities. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the legal entities. Defaults to return the latest version              of each legal entities if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing legal entities from a previous call to list legal entities. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 5000 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys or identifier types (as property keys) from the "LegalEntity" domain              to include for each legal entity, or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto each portfolio in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfLegalEntity"""
        return self.__client.list_all_legal_entities(**kwargs)

   def list_all_legal_entities_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAllLegalEntities: List Legal Entities  # noqa: E501

List all legal entities which the user is entitled to see.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_all_legal_entities_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the legal entities. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the legal entities. Defaults to return the latest version              of each legal entities if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing legal entities from a previous call to list legal entities. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 5000 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys or identifier types (as property keys) from the "LegalEntity" domain              to include for each legal entity, or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto each portfolio in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfLegalEntity, int, HTTPHeaderDict)"""
        return self.__client.list_all_legal_entities_with_http_info(**kwargs)

   def list_legal_entities(self, id_type_scope: Any, id_type_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListLegalEntities: List Legal Entities  # noqa: E501

List legal entities which has identifier of specific identifier type's scope and code, and satisfies filter criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_legal_entities(id_type_scope, id_type_code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param effective_at: The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing legal entities from a previous call to list legal entities. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys or identifier types (as property keys) from the "LegalEntity" domain              to include for each legal entity, or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto each portfolio in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfLegalEntity"""
        return self.__client.list_legal_entities(id_type_scope, id_type_code, **kwargs)

   def list_legal_entities_with_http_info(self, id_type_scope: Any, id_type_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListLegalEntities: List Legal Entities  # noqa: E501

List legal entities which has identifier of specific identifier type's scope and code, and satisfies filter criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_legal_entities_with_http_info(id_type_scope, id_type_code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param effective_at: The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing legal entities from a previous call to list legal entities. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys or identifier types (as property keys) from the "LegalEntity" domain              to include for each legal entity, or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "LegalEntity/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto each portfolio in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfLegalEntity, int, HTTPHeaderDict)"""
        return self.__client.list_legal_entities_with_http_info(id_type_scope, id_type_code, **kwargs)

   def patch_legal_entity_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchLegalEntityAccessMetadata: Patch Access Metadata rules for a Legal Entity.  # noqa: E501

Patch Legal Entity Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document    Currently only valid metadata keys are supported paths on the patch document                The response will return any affected Legal Entity Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_legal_entity_access_metadata(id_type_scope, id_type_code, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.patch_legal_entity_access_metadata(id_type_scope, id_type_code, code, access_metadata_operation, **kwargs)

   def patch_legal_entity_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchLegalEntityAccessMetadata: Patch Access Metadata rules for a Legal Entity.  # noqa: E501

Patch Legal Entity Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document    Currently only valid metadata keys are supported paths on the patch document                The response will return any affected Legal Entity Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.patch_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, access_metadata_operation, **kwargs)

   def set_legal_entity_identifiers(self, id_type_scope: Any, id_type_code: Any, code: Any, set_legal_entity_identifiers_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetLegalEntityIdentifiers: Set Legal Entity Identifiers  # noqa: E501

Set identifiers of the Legal Entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_legal_entity_identifiers(id_type_scope, id_type_code, code, set_legal_entity_identifiers_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param set_legal_entity_identifiers_request: Request containing identifiers to set for the legal entity. Identifiers not specified in request will not be changed. (required)
:type set_legal_entity_identifiers_request: SetLegalEntityIdentifiersRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: LegalEntity"""
        return self.__client.set_legal_entity_identifiers(id_type_scope, id_type_code, code, set_legal_entity_identifiers_request, **kwargs)

   def set_legal_entity_identifiers_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, set_legal_entity_identifiers_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetLegalEntityIdentifiers: Set Legal Entity Identifiers  # noqa: E501

Set identifiers of the Legal Entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_legal_entity_identifiers_with_http_info(id_type_scope, id_type_code, code, set_legal_entity_identifiers_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param set_legal_entity_identifiers_request: Request containing identifiers to set for the legal entity. Identifiers not specified in request will not be changed. (required)
:type set_legal_entity_identifiers_request: SetLegalEntityIdentifiersRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (LegalEntity, int, HTTPHeaderDict)"""
        return self.__client.set_legal_entity_identifiers_with_http_info(id_type_scope, id_type_code, code, set_legal_entity_identifiers_request, **kwargs)

   def set_legal_entity_properties(self, id_type_scope: Any, id_type_code: Any, code: Any, set_legal_entity_properties_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetLegalEntityProperties: Set Legal Entity Properties  # noqa: E501

Set properties of the legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_legal_entity_properties(id_type_scope, id_type_code, code, set_legal_entity_properties_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param set_legal_entity_properties_request: Request containing properties to set for the legal entity. Properties not specified in request will not be changed. (required)
:type set_legal_entity_properties_request: SetLegalEntityPropertiesRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: LegalEntity"""
        return self.__client.set_legal_entity_properties(id_type_scope, id_type_code, code, set_legal_entity_properties_request, **kwargs)

   def set_legal_entity_properties_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, set_legal_entity_properties_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetLegalEntityProperties: Set Legal Entity Properties  # noqa: E501

Set properties of the legal entity.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_legal_entity_properties_with_http_info(id_type_scope, id_type_code, code, set_legal_entity_properties_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the legal entity identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the legal entity identifier type. (required)
:type id_type_code: str
:param code: Code of the legal entity under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the legal entity. (required)
:type code: str
:param set_legal_entity_properties_request: Request containing properties to set for the legal entity. Properties not specified in request will not be changed. (required)
:type set_legal_entity_properties_request: SetLegalEntityPropertiesRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (LegalEntity, int, HTTPHeaderDict)"""
        return self.__client.set_legal_entity_properties_with_http_info(id_type_scope, id_type_code, code, set_legal_entity_properties_request, **kwargs)

   def upsert_legal_entities(self, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertLegalEntities: Pluralised upsert of Legal Entities  # noqa: E501

Creates or updates a collection of Legal Entities  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legal_entities(success_mode, request_body, async_req=True)
>>> result = thread.get()

:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial (required)
:type success_mode: str
:param request_body: A collection of requests to create or update Legal Entities. (required)
:type request_body: dict(str, UpsertLegalEntityRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertLegalEntitiesResponse"""
        return self.__client.upsert_legal_entities(success_mode, request_body, **kwargs)

   def upsert_legal_entities_with_http_info(self, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertLegalEntities: Pluralised upsert of Legal Entities  # noqa: E501

Creates or updates a collection of Legal Entities  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legal_entities_with_http_info(success_mode, request_body, async_req=True)
>>> result = thread.get()

:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial (required)
:type success_mode: str
:param request_body: A collection of requests to create or update Legal Entities. (required)
:type request_body: dict(str, UpsertLegalEntityRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertLegalEntitiesResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_legal_entities_with_http_info(success_mode, request_body, **kwargs)

   def upsert_legal_entity(self, upsert_legal_entity_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertLegalEntity: Upsert Legal Entity  # noqa: E501

Create or update a legal entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legal_entity(upsert_legal_entity_request, async_req=True)
>>> result = thread.get()

:param upsert_legal_entity_request: Request to create or update a legal entity. (required)
:type upsert_legal_entity_request: UpsertLegalEntityRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: LegalEntity"""
        return self.__client.upsert_legal_entity(upsert_legal_entity_request, **kwargs)

   def upsert_legal_entity_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, upsert_legal_entity_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertLegalEntityAccessMetadata: Upsert a Legal Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Legal Entity Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Legal Entity Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legal_entity_access_metadata(id_type_scope, id_type_code, code, metadata_key, upsert_legal_entity_access_metadata_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param upsert_legal_entity_access_metadata_request: The Legal Entity Access Metadata entry to upsert (required)
:type upsert_legal_entity_access_metadata_request: UpsertLegalEntityAccessMetadataRequest
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAccessMetadataValueOf"""
        return self.__client.upsert_legal_entity_access_metadata(id_type_scope, id_type_code, code, metadata_key, upsert_legal_entity_access_metadata_request, **kwargs)

   def upsert_legal_entity_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, upsert_legal_entity_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertLegalEntityAccessMetadata: Upsert a Legal Entity Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Legal Entity Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Legal Entity Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, upsert_legal_entity_access_metadata_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the Legal Entity identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the Legal Entity identifier. (required)
:type id_type_code: str
:param code: Code of the Legal Entity under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param upsert_legal_entity_access_metadata_request: The Legal Entity Access Metadata entry to upsert (required)
:type upsert_legal_entity_access_metadata_request: UpsertLegalEntityAccessMetadataRequest
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAccessMetadataValueOf, int, HTTPHeaderDict)"""
        return self.__client.upsert_legal_entity_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, upsert_legal_entity_access_metadata_request, **kwargs)

   def upsert_legal_entity_with_http_info(self, upsert_legal_entity_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertLegalEntity: Upsert Legal Entity  # noqa: E501

Create or update a legal entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_legal_entity_with_http_info(upsert_legal_entity_request, async_req=True)
>>> result = thread.get()

:param upsert_legal_entity_request: Request to create or update a legal entity. (required)
:type upsert_legal_entity_request: UpsertLegalEntityRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (LegalEntity, int, HTTPHeaderDict)"""
        return self.__client.upsert_legal_entity_with_http_info(upsert_legal_entity_request, **kwargs)

legal_entities_api = __LegalEntitiesApiAuthedAndStubbed()

class __OrderGraphApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.OrderGraphApi)

   def list_order_graph_blocks(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrderGraphBlocks: Lists blocks that pass the filter provided, and builds a summary picture of the state of their associated order entities.  # noqa: E501

Lists all blocks of orders, subject to the filter, along with the IDs of orders, placements, allocations and  executions in the block, the total quantities of each, and a simple text field describing the overall state.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_graph_blocks(async_req=True)
>>> result = thread.get()

:param as_at: See https://support.lusid.com/knowledgebase/article/KA-01832/
:type as_at: datetime
:param pagination_token: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type pagination_token: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type limit: int
:param filter: See https://support.lusid.com/knowledgebase/article/KA-01914/
:type filter: str
:param property_keys: Must be block-level properties. See https://support.lusid.com/knowledgebase/article/KA-01855/
:type property_keys: list[str]
:param use_compliance_v2: Whether to use the V2 compliance engine when deriving compliance statuses for orders. (default: false)
:type use_compliance_v2: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfOrderGraphBlock"""
        return self.__client.list_order_graph_blocks(**kwargs)

   def list_order_graph_blocks_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrderGraphBlocks: Lists blocks that pass the filter provided, and builds a summary picture of the state of their associated order entities.  # noqa: E501

Lists all blocks of orders, subject to the filter, along with the IDs of orders, placements, allocations and  executions in the block, the total quantities of each, and a simple text field describing the overall state.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_graph_blocks_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: See https://support.lusid.com/knowledgebase/article/KA-01832/
:type as_at: datetime
:param pagination_token: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type pagination_token: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type limit: int
:param filter: See https://support.lusid.com/knowledgebase/article/KA-01914/
:type filter: str
:param property_keys: Must be block-level properties. See https://support.lusid.com/knowledgebase/article/KA-01855/
:type property_keys: list[str]
:param use_compliance_v2: Whether to use the V2 compliance engine when deriving compliance statuses for orders. (default: false)
:type use_compliance_v2: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfOrderGraphBlock, int, HTTPHeaderDict)"""
        return self.__client.list_order_graph_blocks_with_http_info(**kwargs)

   def list_order_graph_placement_children(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrderGraphPlacementChildren: Lists all placements for the parent placement specified by the scope and code, and builds a summary picture of the state of their associated order entities.  # noqa: E501

Lists all child order placements, for the specified parent placement, along with the IDs of the block and order that the  placement is for, each placement's quantity, the IDs of all allocations and executions in the placement  and the total quantities of those, and a simple text field describing the overall state of the placement.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_graph_placement_children(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The parent placement's scope (required)
:type scope: str
:param code: The parent placement's code (required)
:type code: str
:param as_at: See https://support.lusid.com/knowledgebase/article/KA-01832/
:type as_at: datetime
:param pagination_token: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type pagination_token: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName.
:type sort_by: list[str]
:param limit: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type limit: int
:param property_keys: Must be placement properties. See https://support.lusid.com/knowledgebase/article/KA-01855/
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfOrderGraphPlacement"""
        return self.__client.list_order_graph_placement_children(scope, code, **kwargs)

   def list_order_graph_placement_children_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrderGraphPlacementChildren: Lists all placements for the parent placement specified by the scope and code, and builds a summary picture of the state of their associated order entities.  # noqa: E501

Lists all child order placements, for the specified parent placement, along with the IDs of the block and order that the  placement is for, each placement's quantity, the IDs of all allocations and executions in the placement  and the total quantities of those, and a simple text field describing the overall state of the placement.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_graph_placement_children_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The parent placement's scope (required)
:type scope: str
:param code: The parent placement's code (required)
:type code: str
:param as_at: See https://support.lusid.com/knowledgebase/article/KA-01832/
:type as_at: datetime
:param pagination_token: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type pagination_token: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName.
:type sort_by: list[str]
:param limit: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type limit: int
:param property_keys: Must be placement properties. See https://support.lusid.com/knowledgebase/article/KA-01855/
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfOrderGraphPlacement, int, HTTPHeaderDict)"""
        return self.__client.list_order_graph_placement_children_with_http_info(scope, code, **kwargs)

   def list_order_graph_placements(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrderGraphPlacements: Lists placements that pass the filter provided, and builds a summary picture of the state of their associated order entities.  # noqa: E501

Lists all order placements, subject to the filter, along with the IDs of the block and order that the  placement is for, each placement's quantity, the IDs of all allocations and executions in the placement  and the total quantities of those, and a simple text field describing the overall state of the placement.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_graph_placements(async_req=True)
>>> result = thread.get()

:param as_at: See https://support.lusid.com/knowledgebase/article/KA-01832/
:type as_at: datetime
:param pagination_token: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type pagination_token: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type limit: int
:param filter: See https://support.lusid.com/knowledgebase/article/KA-01914/
:type filter: str
:param property_keys: Must be placement properties. See https://support.lusid.com/knowledgebase/article/KA-01855/
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfOrderGraphPlacement"""
        return self.__client.list_order_graph_placements(**kwargs)

   def list_order_graph_placements_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrderGraphPlacements: Lists placements that pass the filter provided, and builds a summary picture of the state of their associated order entities.  # noqa: E501

Lists all order placements, subject to the filter, along with the IDs of the block and order that the  placement is for, each placement's quantity, the IDs of all allocations and executions in the placement  and the total quantities of those, and a simple text field describing the overall state of the placement.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_graph_placements_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: See https://support.lusid.com/knowledgebase/article/KA-01832/
:type as_at: datetime
:param pagination_token: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type pagination_token: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: See https://support.lusid.com/knowledgebase/article/KA-01915/
:type limit: int
:param filter: See https://support.lusid.com/knowledgebase/article/KA-01914/
:type filter: str
:param property_keys: Must be placement properties. See https://support.lusid.com/knowledgebase/article/KA-01855/
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfOrderGraphPlacement, int, HTTPHeaderDict)"""
        return self.__client.list_order_graph_placements_with_http_info(**kwargs)

order_graph_api = __OrderGraphApiAuthedAndStubbed()

class __OrderInstructionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.OrderInstructionsApi)

   def delete_order_instruction(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteOrderInstruction: Delete orderInstruction  # noqa: E501

Delete an orderInstruction. Deletion will be valid from the orderInstruction's creation datetime.  This means that the orderInstruction will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_order_instruction(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The orderInstruction scope. (required)
:type scope: str
:param code: The orderInstruction's code. This, together with the scope uniquely identifies the orderInstruction to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_order_instruction(scope, code, **kwargs)

   def delete_order_instruction_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteOrderInstruction: Delete orderInstruction  # noqa: E501

Delete an orderInstruction. Deletion will be valid from the orderInstruction's creation datetime.  This means that the orderInstruction will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_order_instruction_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The orderInstruction scope. (required)
:type scope: str
:param code: The orderInstruction's code. This, together with the scope uniquely identifies the orderInstruction to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_order_instruction_with_http_info(scope, code, **kwargs)

   def get_order_instruction(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetOrderInstruction: Get OrderInstruction  # noqa: E501

Fetch a OrderInstruction that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_order_instruction(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the orderInstruction belongs. (required)
:type scope: str
:param code: The orderInstruction's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the orderInstruction. Defaults to return the latest version of the orderInstruction if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "OrderInstruction" domain to decorate onto the orderInstruction.              These take the format {domain}/{scope}/{code} e.g. "OrderInstruction/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: OrderInstruction"""
        return self.__client.get_order_instruction(scope, code, **kwargs)

   def get_order_instruction_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetOrderInstruction: Get OrderInstruction  # noqa: E501

Fetch a OrderInstruction that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_order_instruction_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the orderInstruction belongs. (required)
:type scope: str
:param code: The orderInstruction's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the orderInstruction. Defaults to return the latest version of the orderInstruction if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "OrderInstruction" domain to decorate onto the orderInstruction.              These take the format {domain}/{scope}/{code} e.g. "OrderInstruction/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (OrderInstruction, int, HTTPHeaderDict)"""
        return self.__client.get_order_instruction_with_http_info(scope, code, **kwargs)

   def list_order_instructions(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListOrderInstructions: List OrderInstructions  # noqa: E501

Fetch the last pre-AsAt date version of each orderInstruction in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_instructions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the orderInstruction. Defaults to return the latest version of the orderInstruction if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing orderInstructions from a previous call to list orderInstructions.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "OrderInstruction" domain to decorate onto each orderInstruction.                  These take the format {domain}/{scope}/{code} e.g. "OrderInstruction/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfOrderInstruction"""
        return self.__client.list_order_instructions(**kwargs)

   def list_order_instructions_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListOrderInstructions: List OrderInstructions  # noqa: E501

Fetch the last pre-AsAt date version of each orderInstruction in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_order_instructions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the orderInstruction. Defaults to return the latest version of the orderInstruction if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing orderInstructions from a previous call to list orderInstructions.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "OrderInstruction" domain to decorate onto each orderInstruction.                  These take the format {domain}/{scope}/{code} e.g. "OrderInstruction/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfOrderInstruction, int, HTTPHeaderDict)"""
        return self.__client.list_order_instructions_with_http_info(**kwargs)

   def upsert_order_instructions(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertOrderInstructions: Upsert OrderInstruction  # noqa: E501

Upsert; update existing orderInstructions with given ids, or create new orderInstructions otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_order_instructions(async_req=True)
>>> result = thread.get()

:param order_instruction_set_request: The collection of orderInstruction requests.
:type order_instruction_set_request: OrderInstructionSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfOrderInstruction"""
        return self.__client.upsert_order_instructions(**kwargs)

   def upsert_order_instructions_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertOrderInstructions: Upsert OrderInstruction  # noqa: E501

Upsert; update existing orderInstructions with given ids, or create new orderInstructions otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_order_instructions_with_http_info(async_req=True)
>>> result = thread.get()

:param order_instruction_set_request: The collection of orderInstruction requests.
:type order_instruction_set_request: OrderInstructionSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfOrderInstruction, int, HTTPHeaderDict)"""
        return self.__client.upsert_order_instructions_with_http_info(**kwargs)

order_instructions_api = __OrderInstructionsApiAuthedAndStubbed()

class __OrderManagementApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.OrderManagementApi)

   def book_transactions(self, book_transactions_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] BookTransactions: Books transactions using specific allocations as a source.  # noqa: E501

Takes a collection of allocation IDs, and maps fields from those allocations and related orders onto new transactions.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.book_transactions(book_transactions_request, async_req=True)
>>> result = thread.get()

:param book_transactions_request: The allocations to create transactions for (required)
:type book_transactions_request: BookTransactionsRequest
:param apply_fees_and_commission: Whether to apply fees and commissions to transactions (default: true)
:type apply_fees_and_commission: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BookTransactionsResponse"""
        return self.__client.book_transactions(book_transactions_request, **kwargs)

   def book_transactions_with_http_info(self, book_transactions_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] BookTransactions: Books transactions using specific allocations as a source.  # noqa: E501

Takes a collection of allocation IDs, and maps fields from those allocations and related orders onto new transactions.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.book_transactions_with_http_info(book_transactions_request, async_req=True)
>>> result = thread.get()

:param book_transactions_request: The allocations to create transactions for (required)
:type book_transactions_request: BookTransactionsRequest
:param apply_fees_and_commission: Whether to apply fees and commissions to transactions (default: true)
:type apply_fees_and_commission: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BookTransactionsResponse, int, HTTPHeaderDict)"""
        return self.__client.book_transactions_with_http_info(book_transactions_request, **kwargs)

   def create_orders(self, block_and_orders_create_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateOrders: Upsert a Block and associated orders  # noqa: E501

Upsert a Block and create associated orders.  This will fail if the block exists and already references orders with differing fields to the upsert request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_orders(block_and_orders_create_request, async_req=True)
>>> result = thread.get()

:param block_and_orders_create_request: The collection of block and orders requests. (required)
:type block_and_orders_create_request: BlockAndOrdersCreateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfBlockAndOrders"""
        return self.__client.create_orders(block_and_orders_create_request, **kwargs)

   def create_orders_with_http_info(self, block_and_orders_create_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateOrders: Upsert a Block and associated orders  # noqa: E501

Upsert a Block and create associated orders.  This will fail if the block exists and already references orders with differing fields to the upsert request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_orders_with_http_info(block_and_orders_create_request, async_req=True)
>>> result = thread.get()

:param block_and_orders_create_request: The collection of block and orders requests. (required)
:type block_and_orders_create_request: BlockAndOrdersCreateRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfBlockAndOrders, int, HTTPHeaderDict)"""
        return self.__client.create_orders_with_http_info(block_and_orders_create_request, **kwargs)

   def move_orders(self, move_orders_to_different_blocks_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] MoveOrders: Move orders to new or existing block  # noqa: E501

Move an order to a block, creating the block if it does not already exist.   This will fail if the block exists and already references orders with differing fields to the upsert request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.move_orders(move_orders_to_different_blocks_request, async_req=True)
>>> result = thread.get()

:param move_orders_to_different_blocks_request: The collection of order and destination block ids. (required)
:type move_orders_to_different_blocks_request: MoveOrdersToDifferentBlocksRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfMovedOrderToDifferentBlockResponse"""
        return self.__client.move_orders(move_orders_to_different_blocks_request, **kwargs)

   def move_orders_with_http_info(self, move_orders_to_different_blocks_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] MoveOrders: Move orders to new or existing block  # noqa: E501

Move an order to a block, creating the block if it does not already exist.   This will fail if the block exists and already references orders with differing fields to the upsert request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.move_orders_with_http_info(move_orders_to_different_blocks_request, async_req=True)
>>> result = thread.get()

:param move_orders_to_different_blocks_request: The collection of order and destination block ids. (required)
:type move_orders_to_different_blocks_request: MoveOrdersToDifferentBlocksRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfMovedOrderToDifferentBlockResponse, int, HTTPHeaderDict)"""
        return self.__client.move_orders_with_http_info(move_orders_to_different_blocks_request, **kwargs)

   def place_blocks(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] PlaceBlocks: Places blocks for a given list of placement requests.  # noqa: E501

The referenced block's existence will be verified.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.place_blocks(async_req=True)
>>> result = thread.get()

:param place_blocks_request: The request containing the blocks to the placed.
:type place_blocks_request: PlaceBlocksRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPlacement"""
        return self.__client.place_blocks(**kwargs)

   def place_blocks_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] PlaceBlocks: Places blocks for a given list of placement requests.  # noqa: E501

The referenced block's existence will be verified.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.place_blocks_with_http_info(async_req=True)
>>> result = thread.get()

:param place_blocks_request: The request containing the blocks to the placed.
:type place_blocks_request: PlaceBlocksRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPlacement, int, HTTPHeaderDict)"""
        return self.__client.place_blocks_with_http_info(**kwargs)

   def run_allocation_service(self, resource_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] RunAllocationService: Runs the Allocation Service  # noqa: E501

This will allocate executions for a given list of placements back to their originating orders.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.run_allocation_service(resource_id, async_req=True)
>>> result = thread.get()

:param resource_id: The List of Placement IDs for which you wish to allocate executions. (required)
:type resource_id: list[ResourceId]
:param allocation_algorithm: A string representation of the allocation algorithm you would like to use to allocate shares from executions e.g. "PR-FIFO".  This defaults to "PR-FIFO".
:type allocation_algorithm: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AllocationServiceRunResponse"""
        return self.__client.run_allocation_service(resource_id, **kwargs)

   def run_allocation_service_with_http_info(self, resource_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] RunAllocationService: Runs the Allocation Service  # noqa: E501

This will allocate executions for a given list of placements back to their originating orders.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.run_allocation_service_with_http_info(resource_id, async_req=True)
>>> result = thread.get()

:param resource_id: The List of Placement IDs for which you wish to allocate executions. (required)
:type resource_id: list[ResourceId]
:param allocation_algorithm: A string representation of the allocation algorithm you would like to use to allocate shares from executions e.g. "PR-FIFO".  This defaults to "PR-FIFO".
:type allocation_algorithm: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AllocationServiceRunResponse, int, HTTPHeaderDict)"""
        return self.__client.run_allocation_service_with_http_info(resource_id, **kwargs)

order_management_api = __OrderManagementApiAuthedAndStubbed()

class __OrdersApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.OrdersApi)

   def delete_order(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteOrder: Delete order  # noqa: E501

Delete an order. Deletion will be valid from the order's creation datetime.  This means that the order will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_order(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The order scope. (required)
:type scope: str
:param code: The order's code. This, together with the scope uniquely identifies the order to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_order(scope, code, **kwargs)

   def delete_order_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteOrder: Delete order  # noqa: E501

Delete an order. Deletion will be valid from the order's creation datetime.  This means that the order will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_order_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The order scope. (required)
:type scope: str
:param code: The order's code. This, together with the scope uniquely identifies the order to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_order_with_http_info(scope, code, **kwargs)

   def get_order(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetOrder: Get Order  # noqa: E501

Fetch an Order that matches the specified identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_order(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the order belongs. (required)
:type scope: str
:param code: The order's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the order. Defaults to return the latest version of the order if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Orders" domain to decorate onto the order.              These take the format {domain}/{scope}/{code} e.g. "Orders/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Order"""
        return self.__client.get_order(scope, code, **kwargs)

   def get_order_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetOrder: Get Order  # noqa: E501

Fetch an Order that matches the specified identifier.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_order_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the order belongs. (required)
:type scope: str
:param code: The order's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the order. Defaults to return the latest version of the order if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Orders" domain to decorate onto the order.              These take the format {domain}/{scope}/{code} e.g. "Orders/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Order, int, HTTPHeaderDict)"""
        return self.__client.get_order_with_http_info(scope, code, **kwargs)

   def list_orders(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrders: List Orders  # noqa: E501

Fetch the last pre-AsAt date version of each order with optional filtering (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_orders(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the order. Defaults to return the latest version of the order if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing orders from a previous call to list orders.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Orders" domain to decorate onto each order.                  These take the format {domain}/{scope}/{code} e.g. "Orders/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfOrder"""
        return self.__client.list_orders(**kwargs)

   def list_orders_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListOrders: List Orders  # noqa: E501

Fetch the last pre-AsAt date version of each order with optional filtering (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_orders_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the order. Defaults to return the latest version of the order if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing orders from a previous call to list orders.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Orders" domain to decorate onto each order.                  These take the format {domain}/{scope}/{code} e.g. "Orders/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfOrder, int, HTTPHeaderDict)"""
        return self.__client.list_orders_with_http_info(**kwargs)

   def upsert_orders(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertOrders: Upsert Order  # noqa: E501

Upsert; update existing orders with given ids, or create new orders otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_orders(async_req=True)
>>> result = thread.get()

:param order_set_request: The collection of order requests.
:type order_set_request: OrderSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfOrder"""
        return self.__client.upsert_orders(**kwargs)

   def upsert_orders_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertOrders: Upsert Order  # noqa: E501

Upsert; update existing orders with given ids, or create new orders otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_orders_with_http_info(async_req=True)
>>> result = thread.get()

:param order_set_request: The collection of order requests.
:type order_set_request: OrderSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfOrder, int, HTTPHeaderDict)"""
        return self.__client.upsert_orders_with_http_info(**kwargs)

orders_api = __OrdersApiAuthedAndStubbed()

class __PackagesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.PackagesApi)

   def delete_package(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeletePackage: Delete package  # noqa: E501

Delete an package. Deletion will be valid from the package's creation datetime.  This means that the package will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_package(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The package scope. (required)
:type scope: str
:param code: The package's code. This, together with the scope uniquely identifies the package to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_package(scope, code, **kwargs)

   def delete_package_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeletePackage: Delete package  # noqa: E501

Delete an package. Deletion will be valid from the package's creation datetime.  This means that the package will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_package_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The package scope. (required)
:type scope: str
:param code: The package's code. This, together with the scope uniquely identifies the package to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_package_with_http_info(scope, code, **kwargs)

   def get_package(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPackage: Get Package  # noqa: E501

Fetch a Package that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_package(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the package belongs. (required)
:type scope: str
:param code: The package's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the package. Defaults to return the latest version of the package if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Package" domain to decorate onto the package.              These take the format {domain}/{scope}/{code} e.g. "Package/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Package"""
        return self.__client.get_package(scope, code, **kwargs)

   def get_package_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPackage: Get Package  # noqa: E501

Fetch a Package that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_package_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the package belongs. (required)
:type scope: str
:param code: The package's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the package. Defaults to return the latest version of the package if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Package" domain to decorate onto the package.              These take the format {domain}/{scope}/{code} e.g. "Package/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Package, int, HTTPHeaderDict)"""
        return self.__client.get_package_with_http_info(scope, code, **kwargs)

   def list_packages(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListPackages: List Packages  # noqa: E501

Fetch the last pre-AsAt date version of each package in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_packages(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the package. Defaults to return the latest version of the package if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing packages from a previous call to list packages.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Package" domain to decorate onto each package.                  These take the format {domain}/{scope}/{code} e.g. "Package/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPackage"""
        return self.__client.list_packages(**kwargs)

   def list_packages_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListPackages: List Packages  # noqa: E501

Fetch the last pre-AsAt date version of each package in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_packages_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the package. Defaults to return the latest version of the package if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing packages from a previous call to list packages.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Package" domain to decorate onto each package.                  These take the format {domain}/{scope}/{code} e.g. "Package/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPackage, int, HTTPHeaderDict)"""
        return self.__client.list_packages_with_http_info(**kwargs)

   def upsert_packages(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertPackages: Upsert Package  # noqa: E501

Upsert; update existing packages with given ids, or create new packages otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_packages(async_req=True)
>>> result = thread.get()

:param package_set_request: The collection of package requests.
:type package_set_request: PackageSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPackage"""
        return self.__client.upsert_packages(**kwargs)

   def upsert_packages_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertPackages: Upsert Package  # noqa: E501

Upsert; update existing packages with given ids, or create new packages otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_packages_with_http_info(async_req=True)
>>> result = thread.get()

:param package_set_request: The collection of package requests.
:type package_set_request: PackageSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPackage, int, HTTPHeaderDict)"""
        return self.__client.upsert_packages_with_http_info(**kwargs)

packages_api = __PackagesApiAuthedAndStubbed()

class __ParticipationsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ParticipationsApi)

   def delete_participation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteParticipation: Delete participation  # noqa: E501

Delete an participation. Deletion will be valid from the participation's creation datetime.  This means that the participation will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_participation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The participation scope. (required)
:type scope: str
:param code: The participation's code. This, together with the scope uniquely identifies the participation to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_participation(scope, code, **kwargs)

   def delete_participation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteParticipation: Delete participation  # noqa: E501

Delete an participation. Deletion will be valid from the participation's creation datetime.  This means that the participation will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_participation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The participation scope. (required)
:type scope: str
:param code: The participation's code. This, together with the scope uniquely identifies the participation to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_participation_with_http_info(scope, code, **kwargs)

   def get_participation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetParticipation: Get Participation  # noqa: E501

Fetch a Participation that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_participation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the participation belongs. (required)
:type scope: str
:param code: The participation's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the participation. Defaults to return the latest version of the participation if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Participation" domain to decorate onto the participation.              These take the format {domain}/{scope}/{code} e.g. "Participation/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Participation"""
        return self.__client.get_participation(scope, code, **kwargs)

   def get_participation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetParticipation: Get Participation  # noqa: E501

Fetch a Participation that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_participation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the participation belongs. (required)
:type scope: str
:param code: The participation's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the participation. Defaults to return the latest version of the participation if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Participation" domain to decorate onto the participation.              These take the format {domain}/{scope}/{code} e.g. "Participation/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Participation, int, HTTPHeaderDict)"""
        return self.__client.get_participation_with_http_info(scope, code, **kwargs)

   def list_participations(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListParticipations: List Participations  # noqa: E501

Fetch the last pre-AsAt date version of each Participation in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_participations(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the participation. Defaults to return the latest version of the participation if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing participations from a previous call to list participations.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Participation" domain to decorate onto each participation.                  These take the format {domain}/{scope}/{code} e.g. "Participation/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfParticipation"""
        return self.__client.list_participations(**kwargs)

   def list_participations_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListParticipations: List Participations  # noqa: E501

Fetch the last pre-AsAt date version of each Participation in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_participations_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the participation. Defaults to return the latest version of the participation if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing participations from a previous call to list participations.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Participation" domain to decorate onto each participation.                  These take the format {domain}/{scope}/{code} e.g. "Participation/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfParticipation, int, HTTPHeaderDict)"""
        return self.__client.list_participations_with_http_info(**kwargs)

   def upsert_participations(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertParticipations: Upsert Participation  # noqa: E501

Upsert; update existing participations with given ids, or create new participations otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_participations(async_req=True)
>>> result = thread.get()

:param participation_set_request: The collection of participation requests.
:type participation_set_request: ParticipationSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfParticipation"""
        return self.__client.upsert_participations(**kwargs)

   def upsert_participations_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertParticipations: Upsert Participation  # noqa: E501

Upsert; update existing participations with given ids, or create new participations otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_participations_with_http_info(async_req=True)
>>> result = thread.get()

:param participation_set_request: The collection of participation requests.
:type participation_set_request: ParticipationSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfParticipation, int, HTTPHeaderDict)"""
        return self.__client.upsert_participations_with_http_info(**kwargs)

participations_api = __ParticipationsApiAuthedAndStubbed()

class __PersonsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.PersonsApi)

   def delete_person(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePerson: Delete person  # noqa: E501

Delete a person. Deletion will be valid from the person's creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: The scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: The code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_person(id_type_scope, id_type_code, code, **kwargs)

   def delete_person_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePersonAccessMetadata: Delete a Person Access Metadata entry  # noqa: E501

Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_access_metadata(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_person_access_metadata(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def delete_person_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePersonAccessMetadata: Delete a Person Access Metadata entry  # noqa: E501

Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def delete_person_identifiers(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePersonIdentifiers: Delete Person Identifiers  # noqa: E501

Delete identifiers that belong to the given property keys of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_identifiers(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param property_keys: The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". Each property must be from the "Person" domain. Identifiers or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime if identifiers are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_person_identifiers(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_person_identifiers_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePersonIdentifiers: Delete Person Identifiers  # noqa: E501

Delete identifiers that belong to the given property keys of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_identifiers_with_http_info(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param property_keys: The property keys of the identifiers to delete. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". Each property must be from the "Person" domain. Identifiers or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete the identifiers. Defaults to the current LUSID system datetime if not specified.              Must not include an effective datetime if identifiers are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_person_identifiers_with_http_info(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_person_properties(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePersonProperties: Delete Person Properties  # noqa: E501

Delete all properties that belong to the given property keys of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_properties(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param property_keys: The property keys of the person's properties to delete. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". Each property must be from the "Person" domain. Properties or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_person_properties(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_person_properties_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePersonProperties: Delete Person Properties  # noqa: E501

Delete all properties that belong to the given property keys of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_properties_with_http_info(id_type_scope, id_type_code, code, property_keys, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param property_keys: The property keys of the person's properties to delete. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". Each property must be from the "Person" domain. Properties or identifiers not specified in request will not be changed. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_person_properties_with_http_info(id_type_scope, id_type_code, code, property_keys, **kwargs)

   def delete_person_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePerson: Delete person  # noqa: E501

Delete a person. Deletion will be valid from the person's creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_person_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: The scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: The code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type scope and code. This together with defined              identifier type uniquely identifies the person to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_person_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_all_person_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllPersonAccessMetadata: Get Access Metadata rules for a Person  # noqa: E501

Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_person_access_metadata(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.get_all_person_access_metadata(id_type_scope, id_type_code, code, **kwargs)

   def get_all_person_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAllPersonAccessMetadata: Get Access Metadata rules for a Person  # noqa: E501

Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_all_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.get_all_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_person(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPerson: Get Person  # noqa: E501

Retrieve the definition of a person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param property_keys: A list of property keys from the "Person" domain to decorate onto the person,               or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "Person/ContactDetails/Address".
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified.
:type as_at: datetime
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the person in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Person"""
        return self.__client.get_person(id_type_scope, id_type_code, code, **kwargs)

   def get_person_access_metadata_by_key(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Person  # noqa: E501

Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_access_metadata_by_key(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[AccessMetadataValue]"""
        return self.__client.get_person_access_metadata_by_key(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def get_person_access_metadata_by_key_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Person  # noqa: E501

Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_access_metadata_by_key_with_http_info(id_type_scope, id_type_code, code, metadata_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[AccessMetadataValue], int, HTTPHeaderDict)"""
        return self.__client.get_person_access_metadata_by_key_with_http_info(id_type_scope, id_type_code, code, metadata_key, **kwargs)

   def get_person_property_time_series(self, id_type_scope: Any, id_type_code: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonPropertyTimeSeries: Get Person Property Time Series  # noqa: E501

List the complete time series of a person property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_property_time_series(id_type_scope, id_type_code, code, property_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely identifies the person. (required)
:type code: str
:param property_key: The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role".              Each property must be from the "Person" domain. (required)
:type property_key: str
:param as_at: The asAt datetime at which to list the person's property history. Defaults to return the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyInterval"""
        return self.__client.get_person_property_time_series(id_type_scope, id_type_code, code, property_key, **kwargs)

   def get_person_property_time_series_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonPropertyTimeSeries: Get Person Property Time Series  # noqa: E501

List the complete time series of a person property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_property_time_series_with_http_info(id_type_scope, id_type_code, code, property_key, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely identifies the person. (required)
:type code: str
:param property_key: The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role".              Each property must be from the "Person" domain. (required)
:type property_key: str
:param as_at: The asAt datetime at which to list the person's property history. Defaults to return the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyInterval, int, HTTPHeaderDict)"""
        return self.__client.get_person_property_time_series_with_http_info(id_type_scope, id_type_code, code, property_key, **kwargs)

   def get_person_relations(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonRelations: Get Relations for Person  # noqa: E501

Get relations for the specified person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_relations(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the person's relations. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelation"""
        return self.__client.get_person_relations(id_type_scope, id_type_code, code, **kwargs)

   def get_person_relations_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonRelations: Get Relations for Person  # noqa: E501

Get relations for the specified person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_relations_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the person's relations. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelation, int, HTTPHeaderDict)"""
        return self.__client.get_person_relations_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_person_relationships(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonRelationships: Get Relationships for Person  # noqa: E501

Get relationships for the specified person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_relationships(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person's identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person's identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelationship"""
        return self.__client.get_person_relationships(id_type_scope, id_type_code, code, **kwargs)

   def get_person_relationships_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPersonRelationships: Get Relationships for Person  # noqa: E501

Get relationships for the specified person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_relationships_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person's identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person's identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to get relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelationship, int, HTTPHeaderDict)"""
        return self.__client.get_person_relationships_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def get_person_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPerson: Get Person  # noqa: E501

Retrieve the definition of a person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_person_with_http_info(id_type_scope, id_type_code, code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param property_keys: A list of property keys from the "Person" domain to decorate onto the person,               or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "Person/ContactDetails/Address".
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to retrieve the person. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the person. Defaults to return the latest version of the person if not specified.
:type as_at: datetime
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the person in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Person, int, HTTPHeaderDict)"""
        return self.__client.get_person_with_http_info(id_type_scope, id_type_code, code, **kwargs)

   def list_all_persons(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAllPersons: List All Persons  # noqa: E501

List all persons which the user is entitled to see.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_all_persons(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing persons from a previous call to list persons. This              value is returned from the previous call. If a pagination token is provided the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 5000 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               For example, to filter on the display name, use "displayName eq 'John'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Person" domain to decorate onto each person,               or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "Person/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the persons in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPerson"""
        return self.__client.list_all_persons(**kwargs)

   def list_all_persons_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListAllPersons: List All Persons  # noqa: E501

List all persons which the user is entitled to see.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_all_persons_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing persons from a previous call to list persons. This              value is returned from the previous call. If a pagination token is provided the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 5000 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               For example, to filter on the display name, use "displayName eq 'John'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Person" domain to decorate onto each person,               or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "Person/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the persons in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPerson, int, HTTPHeaderDict)"""
        return self.__client.list_all_persons_with_http_info(**kwargs)

   def list_persons(self, id_type_scope: Any, id_type_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPersons: List Persons  # noqa: E501

List persons which have identifiers of a specific identifier type's scope and code, and satisfies filter criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_persons(id_type_scope, id_type_code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param effective_at: The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing persons from a previous call to list persons. This              value is returned from the previous call. If a pagination token is provided the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               For example, to filter on the LUPID, use "lusidPersonId eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Person" domain to decorate onto each person,               or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "Person/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the persons in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPerson"""
        return self.__client.list_persons(id_type_scope, id_type_code, **kwargs)

   def list_persons_with_http_info(self, id_type_scope: Any, id_type_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPersons: List Persons  # noqa: E501

List persons which have identifiers of a specific identifier type's scope and code, and satisfies filter criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_persons_with_http_info(id_type_scope, id_type_code, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param effective_at: The effective datetime or cut label at which to list the people. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the people. Defaults to return the latest version              of each people if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing persons from a previous call to list persons. This              value is returned from the previous call. If a pagination token is provided the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               For example, to filter on the LUPID, use "lusidPersonId eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Person" domain to decorate onto each person,               or from any domain that supports relationships to decorate onto related entities.              These take the format {domain}/{scope}/{code} e.g. "Person/ContactDetails/Address".
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the persons in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPerson, int, HTTPHeaderDict)"""
        return self.__client.list_persons_with_http_info(id_type_scope, id_type_code, **kwargs)

   def patch_person_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPersonAccessMetadata: Patch Access Metadata rules for a Person.  # noqa: E501

Patch Person Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document.    Currently only valid metadata keys are supported paths on the patch document.                The response will return any affected Person Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_person_access_metadata(id_type_scope, id_type_code, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.patch_person_access_metadata(id_type_scope, id_type_code, code, access_metadata_operation, **kwargs)

   def patch_person_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPersonAccessMetadata: Patch Access Metadata rules for a Person.  # noqa: E501

Patch Person Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document.    Currently only valid metadata keys are supported paths on the patch document.                The response will return any affected Person Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.patch_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, access_metadata_operation, **kwargs)

   def set_person_identifiers(self, id_type_scope: Any, id_type_code: Any, code: Any, set_person_identifiers_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetPersonIdentifiers: Set Person Identifiers  # noqa: E501

Set identifiers of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_person_identifiers(id_type_scope, id_type_code, code, set_person_identifiers_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param set_person_identifiers_request: Request containing identifiers to set for the person. Identifiers not specified in request will not be changed. (required)
:type set_person_identifiers_request: SetPersonIdentifiersRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Person"""
        return self.__client.set_person_identifiers(id_type_scope, id_type_code, code, set_person_identifiers_request, **kwargs)

   def set_person_identifiers_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, set_person_identifiers_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetPersonIdentifiers: Set Person Identifiers  # noqa: E501

Set identifiers of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_person_identifiers_with_http_info(id_type_scope, id_type_code, code, set_person_identifiers_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param set_person_identifiers_request: Request containing identifiers to set for the person. Identifiers not specified in request will not be changed. (required)
:type set_person_identifiers_request: SetPersonIdentifiersRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Person, int, HTTPHeaderDict)"""
        return self.__client.set_person_identifiers_with_http_info(id_type_scope, id_type_code, code, set_person_identifiers_request, **kwargs)

   def set_person_properties(self, id_type_scope: Any, id_type_code: Any, code: Any, set_person_properties_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetPersonProperties: Set Person Properties  # noqa: E501

Set properties of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_person_properties(id_type_scope, id_type_code, code, set_person_properties_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param set_person_properties_request: Request containing properties to set for the person. Properties not specified in request will not be changed. (required)
:type set_person_properties_request: SetPersonPropertiesRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Person"""
        return self.__client.set_person_properties(id_type_scope, id_type_code, code, set_person_properties_request, **kwargs)

   def set_person_properties_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, set_person_properties_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] SetPersonProperties: Set Person Properties  # noqa: E501

Set properties of the person.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_person_properties_with_http_info(id_type_scope, id_type_code, code, set_person_properties_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier type. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier type. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. This together with stated identifier type uniquely              identifies the person. (required)
:type code: str
:param set_person_properties_request: Request containing properties to set for the person. Properties not specified in request will not be changed. (required)
:type set_person_properties_request: SetPersonPropertiesRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Person, int, HTTPHeaderDict)"""
        return self.__client.set_person_properties_with_http_info(id_type_scope, id_type_code, code, set_person_properties_request, **kwargs)

   def upsert_person(self, upsert_person_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPerson: Upsert Person  # noqa: E501

Create or update a new person under the specified scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_person(upsert_person_request, async_req=True)
>>> result = thread.get()

:param upsert_person_request: Request to create or update a person. (required)
:type upsert_person_request: UpsertPersonRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Person"""
        return self.__client.upsert_person(upsert_person_request, **kwargs)

   def upsert_person_access_metadata(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, upsert_person_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPersonAccessMetadata: Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_person_access_metadata(id_type_scope, id_type_code, code, metadata_key, upsert_person_access_metadata_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param upsert_person_access_metadata_request: The Person Access Metadata entry to upsert (required)
:type upsert_person_access_metadata_request: UpsertPersonAccessMetadataRequest
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAccessMetadataValueOf"""
        return self.__client.upsert_person_access_metadata(id_type_scope, id_type_code, code, metadata_key, upsert_person_access_metadata_request, **kwargs)

   def upsert_person_access_metadata_with_http_info(self, id_type_scope: Any, id_type_code: Any, code: Any, metadata_key: Any, upsert_person_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPersonAccessMetadata: Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, upsert_person_access_metadata_request, async_req=True)
>>> result = thread.get()

:param id_type_scope: Scope of the person identifier. (required)
:type id_type_scope: str
:param id_type_code: Code of the person identifier. (required)
:type id_type_code: str
:param code: Code of the person under specified identifier type's scope and code. (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param upsert_person_access_metadata_request: The Person Access Metadata entry to upsert (required)
:type upsert_person_access_metadata_request: UpsertPersonAccessMetadataRequest
:param effective_at: The effectiveAt datetime at which to upsert the Access Metadata
:type effective_at: str
:param effective_until: The effective datetime until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' datetime of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAccessMetadataValueOf, int, HTTPHeaderDict)"""
        return self.__client.upsert_person_access_metadata_with_http_info(id_type_scope, id_type_code, code, metadata_key, upsert_person_access_metadata_request, **kwargs)

   def upsert_person_with_http_info(self, upsert_person_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPerson: Upsert Person  # noqa: E501

Create or update a new person under the specified scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_person_with_http_info(upsert_person_request, async_req=True)
>>> result = thread.get()

:param upsert_person_request: Request to create or update a person. (required)
:type upsert_person_request: UpsertPersonRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Person, int, HTTPHeaderDict)"""
        return self.__client.upsert_person_with_http_info(upsert_person_request, **kwargs)

persons_api = __PersonsApiAuthedAndStubbed()

class __PlacementsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.PlacementsApi)

   def delete_placement(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePlacement: Delete placement  # noqa: E501

Delete an placement. Deletion will be valid from the placement's creation datetime.  This means that the placement will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_placement(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The placement scope. (required)
:type scope: str
:param code: The placement's code. This, together with the scope uniquely identifies the placement to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_placement(scope, code, **kwargs)

   def delete_placement_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePlacement: Delete placement  # noqa: E501

Delete an placement. Deletion will be valid from the placement's creation datetime.  This means that the placement will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_placement_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The placement scope. (required)
:type scope: str
:param code: The placement's code. This, together with the scope uniquely identifies the placement to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_placement_with_http_info(scope, code, **kwargs)

   def get_placement(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPlacement: Get Placement  # noqa: E501

Fetch a Placement that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_placement(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the placement belongs. (required)
:type scope: str
:param code: The placement's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the placement. Defaults to return the latest version of the placement if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Placement" domain to decorate onto the placement.  If none are given, all applied properties are returned.              These take the format {domain}/{scope}/{code} e.g. "Placement/system/Name". Property keys from the instrument domain can also be decorated              onto the placement, e.g. "Instrument/default/Isin". These are only decorated if requested.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Placement"""
        return self.__client.get_placement(scope, code, **kwargs)

   def get_placement_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPlacement: Get Placement  # noqa: E501

Fetch a Placement that matches the specified identifier  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_placement_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the placement belongs. (required)
:type scope: str
:param code: The placement's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the placement. Defaults to return the latest version of the placement if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the "Placement" domain to decorate onto the placement.  If none are given, all applied properties are returned.              These take the format {domain}/{scope}/{code} e.g. "Placement/system/Name". Property keys from the instrument domain can also be decorated              onto the placement, e.g. "Instrument/default/Isin". These are only decorated if requested.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Placement, int, HTTPHeaderDict)"""
        return self.__client.get_placement_with_http_info(scope, code, **kwargs)

   def list_placements(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPlacements: List Placements  # noqa: E501

Fetch the last pre-AsAt date version of each placement in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_placements(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the placement. Defaults to return the latest version of the placement if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing placements from a previous call to list placements.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Placement" domain to decorate onto each placement.                  These take the format {domain}/{scope}/{code} e.g. "Placement/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPlacement"""
        return self.__client.list_placements(**kwargs)

   def list_placements_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPlacements: List Placements  # noqa: E501

Fetch the last pre-AsAt date version of each placement in scope (does not fetch the entire history).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_placements_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the placement. Defaults to return the latest version of the placement if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing placements from a previous call to list placements.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Placement" domain to decorate onto each placement.                  These take the format {domain}/{scope}/{code} e.g. "Placement/system/Name".
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPlacement, int, HTTPHeaderDict)"""
        return self.__client.list_placements_with_http_info(**kwargs)

   def upsert_placements(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPlacements: Upsert Placement  # noqa: E501

Upsert; update existing placements with given ids, or create new placements otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_placements(async_req=True)
>>> result = thread.get()

:param placement_set_request: The collection of placement requests.
:type placement_set_request: PlacementSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPlacement"""
        return self.__client.upsert_placements(**kwargs)

   def upsert_placements_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPlacements: Upsert Placement  # noqa: E501

Upsert; update existing placements with given ids, or create new placements otherwise.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_placements_with_http_info(async_req=True)
>>> result = thread.get()

:param placement_set_request: The collection of placement requests.
:type placement_set_request: PlacementSetRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPlacement, int, HTTPHeaderDict)"""
        return self.__client.upsert_placements_with_http_info(**kwargs)

placements_api = __PlacementsApiAuthedAndStubbed()

class __PortfolioGroupsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.PortfolioGroupsApi)

   def add_portfolio_to_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddPortfolioToGroup: Add portfolio to group  # noqa: E501

Add a single portfolio to a portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_portfolio_to_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to add a portfolio to. (required)
:type scope: str
:param code: The code of the portfolio group to add a portfolio to. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label from which the portfolio will be added to the group.
:type effective_at: str
:param resource_id: The resource identifier of the portfolio to add to the portfolio group.
:type resource_id: ResourceId
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.add_portfolio_to_group(scope, code, **kwargs)

   def add_portfolio_to_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddPortfolioToGroup: Add portfolio to group  # noqa: E501

Add a single portfolio to a portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_portfolio_to_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to add a portfolio to. (required)
:type scope: str
:param code: The code of the portfolio group to add a portfolio to. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label from which the portfolio will be added to the group.
:type effective_at: str
:param resource_id: The resource identifier of the portfolio to add to the portfolio group.
:type resource_id: ResourceId
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.add_portfolio_to_group_with_http_info(scope, code, **kwargs)

   def add_sub_group_to_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddSubGroupToGroup: Add sub group to group  # noqa: E501

Add a portfolio group to a portfolio group as a sub group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_sub_group_to_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to add a portfolio group to. (required)
:type scope: str
:param code: The code of the portfolio group to add a portfolio group to. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label from which the sub group will be added to the group.
:type effective_at: str
:param resource_id: The resource identifier of the portfolio group to add to the portfolio group as a sub group.
:type resource_id: ResourceId
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.add_sub_group_to_group(scope, code, **kwargs)

   def add_sub_group_to_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] AddSubGroupToGroup: Add sub group to group  # noqa: E501

Add a portfolio group to a portfolio group as a sub group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.add_sub_group_to_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to add a portfolio group to. (required)
:type scope: str
:param code: The code of the portfolio group to add a portfolio group to. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label from which the sub group will be added to the group.
:type effective_at: str
:param resource_id: The resource identifier of the portfolio group to add to the portfolio group as a sub group.
:type resource_id: ResourceId
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.add_sub_group_to_group_with_http_info(scope, code, **kwargs)

   def build_transactions_for_portfolio_group(self, scope: Any, code: Any, transaction_query_parameters: Any, **kwargs) -> 'Any':
        """BuildTransactionsForPortfolioGroup: Build transactions for transaction portfolios in a portfolio group  # noqa: E501

Build transactions for transaction portfolios in a portfolio group over a given interval of effective time.                When the specified portfolio in a portfolio group is a derived transaction portfolio, the returned set of transactions is the  union set of all transactions of the parent (and any grandparents etc.) and the specified derived transaction portfolio itself.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.build_transactions_for_portfolio_group(scope, code, transaction_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies               the portfolio group. (required)
:type code: str
:param transaction_query_parameters: The query queryParameters which control how the output transactions are built. (required)
:type transaction_query_parameters: TransactionQueryParameters
:param as_at: The asAt datetime at which to build the transactions. Defaults to return the latest               version of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the Transaction Type, use "type eq 'Buy'"               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Instrument" or "Transaction" domain to decorate onto               the transactions. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or               "Transaction/strategy/quantsignal".
:type property_keys: list[str]
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing transactions from a previous call to BuildTransactions.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfOutputTransaction"""
        return self.__client.build_transactions_for_portfolio_group(scope, code, transaction_query_parameters, **kwargs)

   def build_transactions_for_portfolio_group_with_http_info(self, scope: Any, code: Any, transaction_query_parameters: Any, **kwargs) -> 'Any':
        """BuildTransactionsForPortfolioGroup: Build transactions for transaction portfolios in a portfolio group  # noqa: E501

Build transactions for transaction portfolios in a portfolio group over a given interval of effective time.                When the specified portfolio in a portfolio group is a derived transaction portfolio, the returned set of transactions is the  union set of all transactions of the parent (and any grandparents etc.) and the specified derived transaction portfolio itself.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.build_transactions_for_portfolio_group_with_http_info(scope, code, transaction_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies               the portfolio group. (required)
:type code: str
:param transaction_query_parameters: The query queryParameters which control how the output transactions are built. (required)
:type transaction_query_parameters: TransactionQueryParameters
:param as_at: The asAt datetime at which to build the transactions. Defaults to return the latest               version of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the Transaction Type, use "type eq 'Buy'"               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Instrument" or "Transaction" domain to decorate onto               the transactions. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or               "Transaction/strategy/quantsignal".
:type property_keys: list[str]
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing transactions from a previous call to BuildTransactions.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfOutputTransaction, int, HTTPHeaderDict)"""
        return self.__client.build_transactions_for_portfolio_group_with_http_info(scope, code, transaction_query_parameters, **kwargs)

   def create_portfolio_group(self, scope: Any, **kwargs) -> 'Any':
        """CreatePortfolioGroup: Create portfolio group  # noqa: E501

Create a portfolio group in a specific scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_portfolio_group(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope that the portfolio group will be created in. (required)
:type scope: str
:param create_portfolio_group_request: The definition and details of the portfolio group.
:type create_portfolio_group_request: CreatePortfolioGroupRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.create_portfolio_group(scope, **kwargs)

   def create_portfolio_group_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """CreatePortfolioGroup: Create portfolio group  # noqa: E501

Create a portfolio group in a specific scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_portfolio_group_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope that the portfolio group will be created in. (required)
:type scope: str
:param create_portfolio_group_request: The definition and details of the portfolio group.
:type create_portfolio_group_request: CreatePortfolioGroupRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.create_portfolio_group_with_http_info(scope, **kwargs)

   def delete_group_properties(self, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteGroupProperties: Delete group properties  # noqa: E501

Delete one or more properties from a single portfolio group. If the properties are time variant then an effective date time from which the properties  will be deleted must be specified. If the properties are perpetual then it is invalid to specify an effective date time for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_group_properties(scope, code, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to delete properties from. (required)
:type scope: str
:param code: The code of the group to delete properties from. Together with the scope this uniquely identifies the group. (required)
:type code: str
:param request_body: The property keys of the properties to delete. These take the format              {domain}/{scope}/{code} e.g. "PortfolioGroup/Manager/Id". Each property must be from the "PortfolioGroup" domain. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_group_properties(scope, code, request_body, **kwargs)

   def delete_group_properties_with_http_info(self, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteGroupProperties: Delete group properties  # noqa: E501

Delete one or more properties from a single portfolio group. If the properties are time variant then an effective date time from which the properties  will be deleted must be specified. If the properties are perpetual then it is invalid to specify an effective date time for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_group_properties_with_http_info(scope, code, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to delete properties from. (required)
:type scope: str
:param code: The code of the group to delete properties from. Together with the scope this uniquely identifies the group. (required)
:type code: str
:param request_body: The property keys of the properties to delete. These take the format              {domain}/{scope}/{code} e.g. "PortfolioGroup/Manager/Id". Each property must be from the "PortfolioGroup" domain. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_group_properties_with_http_info(scope, code, request_body, **kwargs)

   def delete_key_from_portfolio_group_access_metadata(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteKeyFromPortfolioGroupAccessMetadata: Delete a Portfolio Group Access Metadata entry  # noqa: E501

Deletes the Portfolio Group Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_key_from_portfolio_group_access_metadata(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param metadata_key: Key of the Access Metadata entry to delete (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_key_from_portfolio_group_access_metadata(scope, code, metadata_key, **kwargs)

   def delete_key_from_portfolio_group_access_metadata_with_http_info(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteKeyFromPortfolioGroupAccessMetadata: Delete a Portfolio Group Access Metadata entry  # noqa: E501

Deletes the Portfolio Group Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_key_from_portfolio_group_access_metadata_with_http_info(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param metadata_key: Key of the Access Metadata entry to delete (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_key_from_portfolio_group_access_metadata_with_http_info(scope, code, metadata_key, **kwargs)

   def delete_portfolio_from_group(self, scope: Any, code: Any, portfolio_scope: Any, portfolio_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePortfolioFromGroup: Delete portfolio from group  # noqa: E501

Remove a single portfolio from a portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_from_group(scope, code, portfolio_scope, portfolio_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to remove the portfolio from. (required)
:type scope: str
:param code: The code of the portfolio group to remove the portfolio from. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param portfolio_scope: The scope of the portfolio being removed from the portfolio group. (required)
:type portfolio_scope: str
:param portfolio_code: The code of the portfolio being removed from the portfolio group. Together with the scope this uniquely identifies the portfolio to remove. (required)
:type portfolio_code: str
:param effective_at: The effective datetime or cut label from which the portfolio will be removed from the portfolio group.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.delete_portfolio_from_group(scope, code, portfolio_scope, portfolio_code, **kwargs)

   def delete_portfolio_from_group_with_http_info(self, scope: Any, code: Any, portfolio_scope: Any, portfolio_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePortfolioFromGroup: Delete portfolio from group  # noqa: E501

Remove a single portfolio from a portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_from_group_with_http_info(scope, code, portfolio_scope, portfolio_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to remove the portfolio from. (required)
:type scope: str
:param code: The code of the portfolio group to remove the portfolio from. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param portfolio_scope: The scope of the portfolio being removed from the portfolio group. (required)
:type portfolio_scope: str
:param portfolio_code: The code of the portfolio being removed from the portfolio group. Together with the scope this uniquely identifies the portfolio to remove. (required)
:type portfolio_code: str
:param effective_at: The effective datetime or cut label from which the portfolio will be removed from the portfolio group.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.delete_portfolio_from_group_with_http_info(scope, code, portfolio_scope, portfolio_code, **kwargs)

   def delete_portfolio_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePortfolioGroup: Delete portfolio group  # noqa: E501

Delete a single portfolio group. A portfolio group can be deleted while it still contains portfolios or sub groups.  In this case any portfolios or sub groups contained in this group will not be deleted, however they will no longer be grouped together by this portfolio group.  The deletion will be valid from the portfolio group's creation datetime, ie. the portfolio group will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to delete. (required)
:type scope: str
:param code: The code of the portfolio group to delete. Together with the scope this uniquely identifies the portfolio group to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_portfolio_group(scope, code, **kwargs)

   def delete_portfolio_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePortfolioGroup: Delete portfolio group  # noqa: E501

Delete a single portfolio group. A portfolio group can be deleted while it still contains portfolios or sub groups.  In this case any portfolios or sub groups contained in this group will not be deleted, however they will no longer be grouped together by this portfolio group.  The deletion will be valid from the portfolio group's creation datetime, ie. the portfolio group will no longer exist at any effective datetime from the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to delete. (required)
:type scope: str
:param code: The code of the portfolio group to delete. Together with the scope this uniquely identifies the portfolio group to delete. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_portfolio_group_with_http_info(scope, code, **kwargs)

   def delete_sub_group_from_group(self, scope: Any, code: Any, subgroup_scope: Any, subgroup_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteSubGroupFromGroup: Delete sub group from group  # noqa: E501

Remove a single portfolio group (sub group) from a portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_sub_group_from_group(scope, code, subgroup_scope, subgroup_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to remove the sub group from. (required)
:type scope: str
:param code: The code of the portfolio group to remove the sub group from. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param subgroup_scope: The scope of the sub group to remove from the portfolio group. (required)
:type subgroup_scope: str
:param subgroup_code: The code of the sub group to remove from the portfolio group. Together with the scope this uniquely identifies the sub group. (required)
:type subgroup_code: str
:param effective_at: The effective datetime or cut label from which the sub group will be removed from the portfolio group.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.delete_sub_group_from_group(scope, code, subgroup_scope, subgroup_code, **kwargs)

   def delete_sub_group_from_group_with_http_info(self, scope: Any, code: Any, subgroup_scope: Any, subgroup_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteSubGroupFromGroup: Delete sub group from group  # noqa: E501

Remove a single portfolio group (sub group) from a portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_sub_group_from_group_with_http_info(scope, code, subgroup_scope, subgroup_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to remove the sub group from. (required)
:type scope: str
:param code: The code of the portfolio group to remove the sub group from. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param subgroup_scope: The scope of the sub group to remove from the portfolio group. (required)
:type subgroup_scope: str
:param subgroup_code: The code of the sub group to remove from the portfolio group. Together with the scope this uniquely identifies the sub group. (required)
:type subgroup_code: str
:param effective_at: The effective datetime or cut label from which the sub group will be removed from the portfolio group.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.delete_sub_group_from_group_with_http_info(scope, code, subgroup_scope, subgroup_code, **kwargs)

   def get_a2_b_data_for_portfolio_group(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetA2BDataForPortfolioGroup: Get A2B data for a Portfolio Group  # noqa: E501

Get an A2B report for all Transaction Portfolios within the given portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_a2_b_data_for_portfolio_group(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to retrieve the A2B report for. (required)
:type scope: str
:param code: The code of the group to retrieve the A2B report for. Together with the scope this              uniquely identifies the portfolio group. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version              of each transaction if not specified.
:type as_at: datetime
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param property_keys: A list of property keys from the "Instrument" domain to decorate onto              the results. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfA2BDataRecord"""
        return self.__client.get_a2_b_data_for_portfolio_group(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_a2_b_data_for_portfolio_group_with_http_info(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetA2BDataForPortfolioGroup: Get A2B data for a Portfolio Group  # noqa: E501

Get an A2B report for all Transaction Portfolios within the given portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_a2_b_data_for_portfolio_group_with_http_info(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to retrieve the A2B report for. (required)
:type scope: str
:param code: The code of the group to retrieve the A2B report for. Together with the scope this              uniquely identifies the portfolio group. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version              of each transaction if not specified.
:type as_at: datetime
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param property_keys: A list of property keys from the "Instrument" domain to decorate onto              the results. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfA2BDataRecord, int, HTTPHeaderDict)"""
        return self.__client.get_a2_b_data_for_portfolio_group_with_http_info(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_group_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetGroupProperties: Get group properties  # noqa: E501

List all the properties of a single portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_group_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to list the properties for. (required)
:type scope: str
:param code: The code of the group to list the properties for. Together with the scope this uniquely identifies the group. (required)
:type code: str
:param effective_at: The effective date time or cut label at which to list the group's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt date time at which to list the group's properties. Defaults to return the latest version of each property if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroupProperties"""
        return self.__client.get_group_properties(scope, code, **kwargs)

   def get_group_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetGroupProperties: Get group properties  # noqa: E501

List all the properties of a single portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_group_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to list the properties for. (required)
:type scope: str
:param code: The code of the group to list the properties for. Together with the scope this uniquely identifies the group. (required)
:type code: str
:param effective_at: The effective date time or cut label at which to list the group's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt date time at which to list the group's properties. Defaults to return the latest version of each property if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroupProperties, int, HTTPHeaderDict)"""
        return self.__client.get_group_properties_with_http_info(scope, code, **kwargs)

   def get_holdings_for_portfolio_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetHoldingsForPortfolioGroup: Get holdings for transaction portfolios in portfolio group  # noqa: E501

Get the holdings of transaction portfolios in specified portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_for_portfolio_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the holdings of transaction              portfolios in the portfolio group. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings of transaction portfolios in the portfolio group. Defaults              to return the latest version of the holdings if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Holding" or "Portfolio" domain to decorate onto              the holdings. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or "Holding/system/Cost".
:type property_keys: list[str]
:param by_taxlots: Whether or not to expand the holdings to return the underlying tax-lots. Defaults to              False.
:type by_taxlots: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfPortfolioHolding"""
        return self.__client.get_holdings_for_portfolio_group(scope, code, **kwargs)

   def get_holdings_for_portfolio_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetHoldingsForPortfolioGroup: Get holdings for transaction portfolios in portfolio group  # noqa: E501

Get the holdings of transaction portfolios in specified portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_for_portfolio_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the holdings of transaction              portfolios in the portfolio group. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings of transaction portfolios in the portfolio group. Defaults              to return the latest version of the holdings if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Holding" or "Portfolio" domain to decorate onto              the holdings. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or "Holding/system/Cost".
:type property_keys: list[str]
:param by_taxlots: Whether or not to expand the holdings to return the underlying tax-lots. Defaults to              False.
:type by_taxlots: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfPortfolioHolding, int, HTTPHeaderDict)"""
        return self.__client.get_holdings_for_portfolio_group_with_http_info(scope, code, **kwargs)

   def get_portfolio_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioGroup: Get portfolio group  # noqa: E501

Retrieve the definition of a single portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to retrieve the definition for. (required)
:type scope: str
:param code: The code of the portfolio group to retrieve the definition for. Together with the scope              this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the portfolio group definition. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio group definition. Defaults to return              the latest version of the portfolio group definition if not specified.
:type as_at: datetime
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolio group in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.get_portfolio_group(scope, code, **kwargs)

   def get_portfolio_group_access_metadata_by_key(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Portfolio Group  # noqa: E501

Get a specific Portfolio Group access metadata by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_access_metadata_by_key(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effectiveAt datetime at which to retrieve the access metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the access metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[AccessMetadataValue]"""
        return self.__client.get_portfolio_group_access_metadata_by_key(scope, code, metadata_key, **kwargs)

   def get_portfolio_group_access_metadata_by_key_with_http_info(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupAccessMetadataByKey: Get an entry identified by a metadataKey in the Access Metadata of a Portfolio Group  # noqa: E501

Get a specific Portfolio Group access metadata by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_access_metadata_by_key_with_http_info(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param metadata_key: Key of the metadata entry to retrieve (required)
:type metadata_key: str
:param effective_at: The effectiveAt datetime at which to retrieve the access metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the access metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[AccessMetadataValue], int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_access_metadata_by_key_with_http_info(scope, code, metadata_key, **kwargs)

   def get_portfolio_group_commands(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioGroupCommands: Get portfolio group commands  # noqa: E501

Gets all the commands that modified a single portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_commands(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to retrieve the commands for. (required)
:type scope: str
:param code: The code of the portfolio group to retrieve the commands for. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param from_as_at: The lower bound asAt datetime (inclusive) from which to retrieve commands. There is no lower bound if this is not specified.
:type from_as_at: datetime
:param to_as_at: The upper bound asAt datetime (inclusive) from which to retrieve commands. There is no upper bound if this is not specified.
:type to_as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the User ID, use "userId.id eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfProcessedCommand"""
        return self.__client.get_portfolio_group_commands(scope, code, **kwargs)

   def get_portfolio_group_commands_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioGroupCommands: Get portfolio group commands  # noqa: E501

Gets all the commands that modified a single portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_commands_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to retrieve the commands for. (required)
:type scope: str
:param code: The code of the portfolio group to retrieve the commands for. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param from_as_at: The lower bound asAt datetime (inclusive) from which to retrieve commands. There is no lower bound if this is not specified.
:type from_as_at: datetime
:param to_as_at: The upper bound asAt datetime (inclusive) from which to retrieve commands. There is no upper bound if this is not specified.
:type to_as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the User ID, use "userId.id eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfProcessedCommand, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_commands_with_http_info(scope, code, **kwargs)

   def get_portfolio_group_expansion(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupExpansion: Get portfolio group expansion  # noqa: E501

List all the portfolios in a group, including all portfolios within sub groups in the group. Each portfolio will be decorated with all of its properties unless a property filter is specified.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_expansion(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to expand. (required)
:type scope: str
:param code: The code of the portfolio group to expand. Together with the scope this uniquely identifies the portfolio              group to expand. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to expand the portfolio group. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to expand the portfolio group. Defaults to return the latest version of each portfolio in the group if not specified.
:type as_at: datetime
:param property_filter: The restricted list of property keys from the "Portfolio" domain which will be decorated onto each portfolio. These take the format {domain}/{scope}/{code} e.g. "Portfolio/Manager/Id".
:type property_filter: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ExpandedGroup"""
        return self.__client.get_portfolio_group_expansion(scope, code, **kwargs)

   def get_portfolio_group_expansion_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupExpansion: Get portfolio group expansion  # noqa: E501

List all the portfolios in a group, including all portfolios within sub groups in the group. Each portfolio will be decorated with all of its properties unless a property filter is specified.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_expansion_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to expand. (required)
:type scope: str
:param code: The code of the portfolio group to expand. Together with the scope this uniquely identifies the portfolio              group to expand. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to expand the portfolio group. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to expand the portfolio group. Defaults to return the latest version of each portfolio in the group if not specified.
:type as_at: datetime
:param property_filter: The restricted list of property keys from the "Portfolio" domain which will be decorated onto each portfolio. These take the format {domain}/{scope}/{code} e.g. "Portfolio/Manager/Id".
:type property_filter: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ExpandedGroup, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_expansion_with_http_info(scope, code, **kwargs)

   def get_portfolio_group_metadata(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupMetadata: Get Access Metadata rules for Portfolio Group  # noqa: E501

Pass the scope and Portfolio Group code parameters to retrieve the associated Access Metadata  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_metadata(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.get_portfolio_group_metadata(scope, code, **kwargs)

   def get_portfolio_group_metadata_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupMetadata: Get Access Metadata rules for Portfolio Group  # noqa: E501

Pass the scope and Portfolio Group code parameters to retrieve the associated Access Metadata  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_metadata_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the Access Metadata
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Access Metadata
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_metadata_with_http_info(scope, code, **kwargs)

   def get_portfolio_group_property_time_series(self, scope: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupPropertyTimeSeries: Get the time series of a portfolio group property  # noqa: E501

List the complete time series of a portfolio group property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_property_time_series(scope, code, property_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group. (required)
:type scope: str
:param code: The code of the group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param property_key: The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. "PortfolioGroup/Manager/Id".              Each property must be from the "PortfolioGroup" domain. (required)
:type property_key: str
:param portfolio_group_effective_at: The effective datetime used to resolve the portfolio group. Defaults to the current LUSID system datetime if not specified.
:type portfolio_group_effective_at: str
:param as_at: The asAt datetime at which to list the portfolio group's property history. Defaults to return the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyInterval"""
        return self.__client.get_portfolio_group_property_time_series(scope, code, property_key, **kwargs)

   def get_portfolio_group_property_time_series_with_http_info(self, scope: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupPropertyTimeSeries: Get the time series of a portfolio group property  # noqa: E501

List the complete time series of a portfolio group property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_property_time_series_with_http_info(scope, code, property_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group. (required)
:type scope: str
:param code: The code of the group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param property_key: The property key of the property that will have its history shown. These must be in the format {domain}/{scope}/{code} e.g. "PortfolioGroup/Manager/Id".              Each property must be from the "PortfolioGroup" domain. (required)
:type property_key: str
:param portfolio_group_effective_at: The effective datetime used to resolve the portfolio group. Defaults to the current LUSID system datetime if not specified.
:type portfolio_group_effective_at: str
:param as_at: The asAt datetime at which to list the portfolio group's property history. Defaults to return the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyInterval, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_property_time_series_with_http_info(scope, code, property_key, **kwargs)

   def get_portfolio_group_relations(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPortfolioGroupRelations: Get Relations for Portfolio Group  # noqa: E501

Get relations for the specified Portfolio Group  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_relations(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relations. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelation"""
        return self.__client.get_portfolio_group_relations(scope, code, **kwargs)

   def get_portfolio_group_relations_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPortfolioGroupRelations: Get Relations for Portfolio Group  # noqa: E501

Get relations for the specified Portfolio Group  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_relations_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relations. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifiers types (as property keys) used for referencing Persons or Legal Entities. These take the format              {domain}/{scope}/{code} e.g. "Person/CompanyDetails/Role". They must be from the "Person" or "LegalEntity" domain.              Only identifier types stated will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelation, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_relations_with_http_info(scope, code, **kwargs)

   def get_portfolio_group_relationships(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupRelationships: Get Relationships for Portfolio Group  # noqa: E501

Get relationships for the specified Portfolio Group  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_relationships(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relationship. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelationship"""
        return self.__client.get_portfolio_group_relationships(scope, code, **kwargs)

   def get_portfolio_group_relationships_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioGroupRelationships: Get Relationships for Portfolio Group  # noqa: E501

Get relationships for the specified Portfolio Group  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_relationships_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies              the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relationship. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to return the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter relationships. Users should provide null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelationship, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_relationships_with_http_info(scope, code, **kwargs)

   def get_portfolio_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioGroup: Get portfolio group  # noqa: E501

Retrieve the definition of a single portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to retrieve the definition for. (required)
:type scope: str
:param code: The code of the portfolio group to retrieve the definition for. Together with the scope              this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the portfolio group definition. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio group definition. Defaults to return              the latest version of the portfolio group definition if not specified.
:type as_at: datetime
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolio group in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_group_with_http_info(scope, code, **kwargs)

   def get_transactions_for_portfolio_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetTransactionsForPortfolioGroup: Get transactions for transaction portfolios in a portfolio group  # noqa: E501

Get transactions for transaction portfolios in a portfolio group over a given interval of effective time.                When the specified portfolio in a portfolio group is a derived transaction portfolio, the returned set of transactions is the  union set of all transactions of the parent (and any grandparents etc.) and the specified derived transaction portfolio itself.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transactions_for_portfolio_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies               the portfolio group. (required)
:type code: str
:param from_transaction_date: The lower bound effective datetime or cut label (inclusive) from which to retrieve the transactions.               There is no lower bound if this is not specified.
:type from_transaction_date: str
:param to_transaction_date: The upper bound effective datetime or cut label (inclusive) from which to retrieve transactions.               There is no upper bound if this is not specified.
:type to_transaction_date: str
:param as_at: The asAt datetime at which to retrieve the transactions. Defaults to return the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the Transaction Type, use "type eq 'Buy'"               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Transaction", "LegalEntity" or "CustodianAccount" domain to decorate onto               the transactions. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or               "Transaction/strategy/quantsignal".
:type property_keys: list[str]
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing transactions from a previous call to GetTransactions.
:type page: str
:param show_cancelled_transactions: Option to specify whether or not to include cancelled transactions,               including previous versions of transactions which have since been amended.               Defaults to False if not specified.
:type show_cancelled_transactions: bool
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfTransaction"""
        return self.__client.get_transactions_for_portfolio_group(scope, code, **kwargs)

   def get_transactions_for_portfolio_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetTransactionsForPortfolioGroup: Get transactions for transaction portfolios in a portfolio group  # noqa: E501

Get transactions for transaction portfolios in a portfolio group over a given interval of effective time.                When the specified portfolio in a portfolio group is a derived transaction portfolio, the returned set of transactions is the  union set of all transactions of the parent (and any grandparents etc.) and the specified derived transaction portfolio itself.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transactions_for_portfolio_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group. (required)
:type scope: str
:param code: The code of the portfolio group. Together with the scope this uniquely identifies               the portfolio group. (required)
:type code: str
:param from_transaction_date: The lower bound effective datetime or cut label (inclusive) from which to retrieve the transactions.               There is no lower bound if this is not specified.
:type from_transaction_date: str
:param to_transaction_date: The upper bound effective datetime or cut label (inclusive) from which to retrieve transactions.               There is no upper bound if this is not specified.
:type to_transaction_date: str
:param as_at: The asAt datetime at which to retrieve the transactions. Defaults to return the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the Transaction Type, use "type eq 'Buy'"               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Transaction", "LegalEntity" or "CustodianAccount" domain to decorate onto               the transactions. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or               "Transaction/strategy/quantsignal".
:type property_keys: list[str]
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing transactions from a previous call to GetTransactions.
:type page: str
:param show_cancelled_transactions: Option to specify whether or not to include cancelled transactions,               including previous versions of transactions which have since been amended.               Defaults to False if not specified.
:type show_cancelled_transactions: bool
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfTransaction, int, HTTPHeaderDict)"""
        return self.__client.get_transactions_for_portfolio_group_with_http_info(scope, code, **kwargs)

   def list_portfolio_groups(self, scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPortfolioGroups: List portfolio groups  # noqa: E501

List all the portfolio groups in a single scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolio_groups(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope to list the portfolio groups in. (required)
:type scope: str
:param effective_at: The effective datetime or cut label at which to list the portfolio groups. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolio groups. Defaults to return the latest version of each portfolio group if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing portfolio groups from a previous call to list portfolio groups. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to no limit if not specified.
:type limit: int
:param filter: Expression to filter the result set.              For example, to filter on the Display Name, use "displayName eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolio groups in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPortfolioGroup"""
        return self.__client.list_portfolio_groups(scope, **kwargs)

   def list_portfolio_groups_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPortfolioGroups: List portfolio groups  # noqa: E501

List all the portfolio groups in a single scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolio_groups_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope to list the portfolio groups in. (required)
:type scope: str
:param effective_at: The effective datetime or cut label at which to list the portfolio groups. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolio groups. Defaults to return the latest version of each portfolio group if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing portfolio groups from a previous call to list portfolio groups. This  value is returned from the previous call. If a pagination token is provided the filter, effectiveAt, sortBy  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to no limit if not specified.
:type limit: int
:param filter: Expression to filter the result set.              For example, to filter on the Display Name, use "displayName eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param related_entity_property_keys: A list of property keys from any domain that supports relationships              to decorate onto related entities. These must take the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type related_entity_property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolio groups in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.list_portfolio_groups_with_http_info(scope, **kwargs)

   def patch_portfolio_group_access_metadata(self, scope: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolioGroupAccessMetadata: Patch Access Metadata rules for a Portfolio Group.  # noqa: E501

Patch Portfolio Group Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document.    Currently only valid metadata keys are supported paths on the patch document.                The response will return any affected Portfolio Group Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_group_access_metadata(scope, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param access_metadata_operation: The Json patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The date this rule will be effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.patch_portfolio_group_access_metadata(scope, code, access_metadata_operation, **kwargs)

   def patch_portfolio_group_access_metadata_with_http_info(self, scope: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolioGroupAccessMetadata: Patch Access Metadata rules for a Portfolio Group.  # noqa: E501

Patch Portfolio Group Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document.    Currently only valid metadata keys are supported paths on the patch document.                The response will return any affected Portfolio Group Access Metadata rules or a failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_group_access_metadata_with_http_info(scope, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param access_metadata_operation: The Json patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The date this rule will be effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.patch_portfolio_group_access_metadata_with_http_info(scope, code, access_metadata_operation, **kwargs)

   def update_portfolio_group(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdatePortfolioGroup: Update portfolio group  # noqa: E501

Update the definition of a single portfolio group. Not all elements within a portfolio group definition are modifiable  due to the potential implications for data already stored against the portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_portfolio_group(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to update the definition for. (required)
:type scope: str
:param code: The code of the portfolio group to update the definition for. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to update the definition.
:type effective_at: str
:param update_portfolio_group_request: The updated portfolio group definition.
:type update_portfolio_group_request: UpdatePortfolioGroupRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroup"""
        return self.__client.update_portfolio_group(scope, code, **kwargs)

   def update_portfolio_group_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdatePortfolioGroup: Update portfolio group  # noqa: E501

Update the definition of a single portfolio group. Not all elements within a portfolio group definition are modifiable  due to the potential implications for data already stored against the portfolio group.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_portfolio_group_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio group to update the definition for. (required)
:type scope: str
:param code: The code of the portfolio group to update the definition for. Together with the scope this uniquely identifies the portfolio group. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to update the definition.
:type effective_at: str
:param update_portfolio_group_request: The updated portfolio group definition.
:type update_portfolio_group_request: UpdatePortfolioGroupRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroup, int, HTTPHeaderDict)"""
        return self.__client.update_portfolio_group_with_http_info(scope, code, **kwargs)

   def upsert_group_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertGroupProperties: Upsert group properties  # noqa: E501

Update or insert one or more properties onto a single group. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'PortfolioGroup'.                Upserting a property that exists for a group, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_group_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the group to update or insert the properties onto. Together with the scope this uniquely identifies the group. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the group. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "PortfolioGroup/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioGroupProperties"""
        return self.__client.upsert_group_properties(scope, code, **kwargs)

   def upsert_group_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertGroupProperties: Upsert group properties  # noqa: E501

Update or insert one or more properties onto a single group. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'PortfolioGroup'.                Upserting a property that exists for a group, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_group_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the group to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the group to update or insert the properties onto. Together with the scope this uniquely identifies the group. (required)
:type code: str
:param request_body: The properties to be updated or inserted onto the group. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "PortfolioGroup/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioGroupProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_group_properties_with_http_info(scope, code, **kwargs)

   def upsert_portfolio_group_access_metadata(self, scope: Any, code: Any, metadata_key: Any, upsert_portfolio_group_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPortfolioGroupAccessMetadata: Upsert a Portfolio Group Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Portfolio Group Access Metadata Entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Portfolio Group Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_group_access_metadata(scope, code, metadata_key, upsert_portfolio_group_access_metadata_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param metadata_key: Key of the access metadata entry to upsert (required)
:type metadata_key: str
:param upsert_portfolio_group_access_metadata_request: The Portfolio Group Access Metadata rule to upsert (required)
:type upsert_portfolio_group_access_metadata_request: UpsertPortfolioGroupAccessMetadataRequest
:param effective_at: The date this rule will be effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAccessMetadataValueOf"""
        return self.__client.upsert_portfolio_group_access_metadata(scope, code, metadata_key, upsert_portfolio_group_access_metadata_request, **kwargs)

   def upsert_portfolio_group_access_metadata_with_http_info(self, scope: Any, code: Any, metadata_key: Any, upsert_portfolio_group_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPortfolioGroupAccessMetadata: Upsert a Portfolio Group Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Portfolio Group Access Metadata Entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Portfolio Group Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_group_access_metadata_with_http_info(scope, code, metadata_key, upsert_portfolio_group_access_metadata_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Group (required)
:type scope: str
:param code: The Portfolio Group code (required)
:type code: str
:param metadata_key: Key of the access metadata entry to upsert (required)
:type metadata_key: str
:param upsert_portfolio_group_access_metadata_request: The Portfolio Group Access Metadata rule to upsert (required)
:type upsert_portfolio_group_access_metadata_request: UpsertPortfolioGroupAccessMetadataRequest
:param effective_at: The date this rule will be effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAccessMetadataValueOf, int, HTTPHeaderDict)"""
        return self.__client.upsert_portfolio_group_access_metadata_with_http_info(scope, code, metadata_key, upsert_portfolio_group_access_metadata_request, **kwargs)

portfolio_groups_api = __PortfolioGroupsApiAuthedAndStubbed()

class __PortfoliosApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.PortfoliosApi)

   def delete_key_from_portfolio_access_metadata(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteKeyFromPortfolioAccessMetadata: Delete a Portfolio Access Metadata Rule  # noqa: E501

Delete the Portfolio Access Metadata Rule that exactly matches the provided identifier parts  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_key_from_portfolio_access_metadata(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param metadata_key: The metadataKey identifying the access metadata entry to delete (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_key_from_portfolio_access_metadata(scope, code, metadata_key, **kwargs)

   def delete_key_from_portfolio_access_metadata_with_http_info(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteKeyFromPortfolioAccessMetadata: Delete a Portfolio Access Metadata Rule  # noqa: E501

Delete the Portfolio Access Metadata Rule that exactly matches the provided identifier parts  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_key_from_portfolio_access_metadata_with_http_info(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param metadata_key: The metadataKey identifying the access metadata entry to delete (required)
:type metadata_key: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param effective_until: The effective date until which the delete is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_key_from_portfolio_access_metadata_with_http_info(scope, code, metadata_key, **kwargs)

   def delete_portfolio(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """DeletePortfolio: Delete portfolio  # noqa: E501

Delete a particular portfolio.                The deletion will take effect from the portfolio's creation datetime. This means that the portfolio will no longer exist at any effective datetime, as per the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_portfolio(scope, code, **kwargs)

   def delete_portfolio_properties(self, scope: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """DeletePortfolioProperties: Delete portfolio properties  # noqa: E501

Delete one or more properties from a particular portfolio. If the properties are time-variant then an effective datetime from which  to delete properties must be specified. If the properties are perpetual then it is invalid to specify an effective datetime for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_properties(scope, code, property_keys, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param property_keys: The property keys of the properties to delete. These must take the format              {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'. Each property must be from the 'Portfolio' domain. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_portfolio_properties(scope, code, property_keys, **kwargs)

   def delete_portfolio_properties_with_http_info(self, scope: Any, code: Any, property_keys: Any, **kwargs) -> 'Any':
        """DeletePortfolioProperties: Delete portfolio properties  # noqa: E501

Delete one or more properties from a particular portfolio. If the properties are time-variant then an effective datetime from which  to delete properties must be specified. If the properties are perpetual then it is invalid to specify an effective datetime for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_properties_with_http_info(scope, code, property_keys, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param property_keys: The property keys of the properties to delete. These must take the format              {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'. Each property must be from the 'Portfolio' domain. (required)
:type property_keys: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is              before the time-variant property exists then a failure is returned. Do not specify this parameter if any of              the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_portfolio_properties_with_http_info(scope, code, property_keys, **kwargs)

   def delete_portfolio_returns(self, scope: Any, code: Any, return_scope: Any, return_code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePortfolioReturns: Delete Returns  # noqa: E501

Cancel one or more Returns which exist into the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_returns(scope, code, return_scope, return_code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param from_effective_at: The start date from which to delete the Returns. (required)
:type from_effective_at: str
:param to_effective_at: The end date from which to delete the Returns. (required)
:type to_effective_at: str
:param period: The Period (Daily or Monthly) of the Returns to be deleted. Defaults to Daily.
:type period: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_portfolio_returns(scope, code, return_scope, return_code, from_effective_at, to_effective_at, **kwargs)

   def delete_portfolio_returns_with_http_info(self, scope: Any, code: Any, return_scope: Any, return_code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePortfolioReturns: Delete Returns  # noqa: E501

Cancel one or more Returns which exist into the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_returns_with_http_info(scope, code, return_scope, return_code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param from_effective_at: The start date from which to delete the Returns. (required)
:type from_effective_at: str
:param to_effective_at: The end date from which to delete the Returns. (required)
:type to_effective_at: str
:param period: The Period (Daily or Monthly) of the Returns to be deleted. Defaults to Daily.
:type period: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_portfolio_returns_with_http_info(scope, code, return_scope, return_code, from_effective_at, to_effective_at, **kwargs)

   def delete_portfolio_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """DeletePortfolio: Delete portfolio  # noqa: E501

Delete a particular portfolio.                The deletion will take effect from the portfolio's creation datetime. This means that the portfolio will no longer exist at any effective datetime, as per the asAt datetime of deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_portfolio_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_portfolio_with_http_info(scope, code, **kwargs)

   def get_aggregated_returns_dispersion_metrics(self, scope: Any, code: Any, aggregated_returns_dispersion_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAggregatedReturnsDispersionMetrics: Get the Aggregated Returns Dispersion metric  # noqa: E501

Calculate the dispersion metric with the Aggregate Returns which are on the specified portfolio.             This works only for composites which have at least 6 constituents for a full year in.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_aggregated_returns_dispersion_metrics(scope, code, aggregated_returns_dispersion_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param aggregated_returns_dispersion_request: The request used in the AggregatedReturnsDispersionMetric. (required)
:type aggregated_returns_dispersion_request: AggregatedReturnsDispersionRequest
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CompositeDispersionResponse"""
        return self.__client.get_aggregated_returns_dispersion_metrics(scope, code, aggregated_returns_dispersion_request, **kwargs)

   def get_aggregated_returns_dispersion_metrics_with_http_info(self, scope: Any, code: Any, aggregated_returns_dispersion_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAggregatedReturnsDispersionMetrics: Get the Aggregated Returns Dispersion metric  # noqa: E501

Calculate the dispersion metric with the Aggregate Returns which are on the specified portfolio.             This works only for composites which have at least 6 constituents for a full year in.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_aggregated_returns_dispersion_metrics_with_http_info(scope, code, aggregated_returns_dispersion_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param aggregated_returns_dispersion_request: The request used in the AggregatedReturnsDispersionMetric. (required)
:type aggregated_returns_dispersion_request: AggregatedReturnsDispersionRequest
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CompositeDispersionResponse, int, HTTPHeaderDict)"""
        return self.__client.get_aggregated_returns_dispersion_metrics_with_http_info(scope, code, aggregated_returns_dispersion_request, **kwargs)

   def get_composite_breakdown(self, scope: Any, code: Any, composite_breakdown_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCompositeBreakdown: Get the Composite Breakdown on how the composite Returns are calculated  # noqa: E501

Calculate the Composite Returns and return this with the constituents which are included in this calculation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_composite_breakdown(scope, code, composite_breakdown_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param composite_breakdown_request: The request used in the GetCompositeBreakdown. (required)
:type composite_breakdown_request: CompositeBreakdownRequest
:param from_effective_at: The start date from which to calculate the Returns.
:type from_effective_at: str
:param to_effective_at: The end date for which to calculate the Returns.
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CompositeBreakdownResponse"""
        return self.__client.get_composite_breakdown(scope, code, composite_breakdown_request, **kwargs)

   def get_composite_breakdown_with_http_info(self, scope: Any, code: Any, composite_breakdown_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetCompositeBreakdown: Get the Composite Breakdown on how the composite Returns are calculated  # noqa: E501

Calculate the Composite Returns and return this with the constituents which are included in this calculation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_composite_breakdown_with_http_info(scope, code, composite_breakdown_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param composite_breakdown_request: The request used in the GetCompositeBreakdown. (required)
:type composite_breakdown_request: CompositeBreakdownRequest
:param from_effective_at: The start date from which to calculate the Returns.
:type from_effective_at: str
:param to_effective_at: The end date for which to calculate the Returns.
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CompositeBreakdownResponse, int, HTTPHeaderDict)"""
        return self.__client.get_composite_breakdown_with_http_info(scope, code, composite_breakdown_request, **kwargs)

   def get_portfolio(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolio: Get portfolio  # noqa: E501

Retrieve the definition of a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the portfolio definition. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio definition. Defaults to returning the latest version of the portfolio definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Portfolio' domain to decorate onto the portfolio,              or from any domain that supports relationships to decorate onto related entities. These must take the format              {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolio in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Portfolio"""
        return self.__client.get_portfolio(scope, code, **kwargs)

   def get_portfolio_aggregate_returns(self, scope: Any, code: Any, return_scope: Any, return_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPortfolioAggregateReturns: Aggregate Returns (This is a deprecated endpoint).  # noqa: E501

Aggregate Returns which are on the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_aggregate_returns(scope, code, return_scope, return_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param recipe_id_scope: The Recipe Scope for getting the fx rates
:type recipe_id_scope: str
:param recipe_id_code: The Recipe Code for getting the fx rates
:type recipe_id_code: str
:param from_effective_at: The start date from which to calculate the Returns.
:type from_effective_at: str
:param to_effective_at: The end date for which to calculate the Returns.
:type to_effective_at: str
:param composite_method: The method used to calculate the Portfolio performance:              Equal/Asset.
:type composite_method: str
:param period: The type of the returns used to calculate the aggregation result: Daily/Monthly.
:type period: str
:param output_frequency: The type of calculated output: Daily/Weekly/Monthly/Quarterly/Half-Yearly/Yearly.
:type output_frequency: str
:param metrics: Determines what type of returns should be calculated, see https://support.lusid.com/knowledgebase/article/KA-01675/en-us for a list of available metrics.
:type metrics: list[str]
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param alternative_inc_date: The date from which to consider the Returns on the Portfolio, if this is different from the date when Returns begin. Can be a date string or Portfolio property.
:type alternative_inc_date: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAggregatedReturn"""
        return self.__client.get_portfolio_aggregate_returns(scope, code, return_scope, return_code, **kwargs)

   def get_portfolio_aggregate_returns_with_http_info(self, scope: Any, code: Any, return_scope: Any, return_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPortfolioAggregateReturns: Aggregate Returns (This is a deprecated endpoint).  # noqa: E501

Aggregate Returns which are on the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_aggregate_returns_with_http_info(scope, code, return_scope, return_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param recipe_id_scope: The Recipe Scope for getting the fx rates
:type recipe_id_scope: str
:param recipe_id_code: The Recipe Code for getting the fx rates
:type recipe_id_code: str
:param from_effective_at: The start date from which to calculate the Returns.
:type from_effective_at: str
:param to_effective_at: The end date for which to calculate the Returns.
:type to_effective_at: str
:param composite_method: The method used to calculate the Portfolio performance:              Equal/Asset.
:type composite_method: str
:param period: The type of the returns used to calculate the aggregation result: Daily/Monthly.
:type period: str
:param output_frequency: The type of calculated output: Daily/Weekly/Monthly/Quarterly/Half-Yearly/Yearly.
:type output_frequency: str
:param metrics: Determines what type of returns should be calculated, see https://support.lusid.com/knowledgebase/article/KA-01675/en-us for a list of available metrics.
:type metrics: list[str]
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param alternative_inc_date: The date from which to consider the Returns on the Portfolio, if this is different from the date when Returns begin. Can be a date string or Portfolio property.
:type alternative_inc_date: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAggregatedReturn, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_aggregate_returns_with_http_info(scope, code, return_scope, return_code, **kwargs)

   def get_portfolio_aggregated_returns(self, scope: Any, code: Any, aggregated_returns_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioAggregatedReturns: Aggregated Returns  # noqa: E501

Aggregate Returns which are on the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_aggregated_returns(scope, code, aggregated_returns_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param aggregated_returns_request: The request used in the AggregatedReturns. (required)
:type aggregated_returns_request: AggregatedReturnsRequest
:param from_effective_at: The start date from which to calculate the Returns.
:type from_effective_at: str
:param to_effective_at: The end date for which to calculate the Returns.
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AggregatedReturnsResponse"""
        return self.__client.get_portfolio_aggregated_returns(scope, code, aggregated_returns_request, **kwargs)

   def get_portfolio_aggregated_returns_with_http_info(self, scope: Any, code: Any, aggregated_returns_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioAggregatedReturns: Aggregated Returns  # noqa: E501

Aggregate Returns which are on the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_aggregated_returns_with_http_info(scope, code, aggregated_returns_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param aggregated_returns_request: The request used in the AggregatedReturns. (required)
:type aggregated_returns_request: AggregatedReturnsRequest
:param from_effective_at: The start date from which to calculate the Returns.
:type from_effective_at: str
:param to_effective_at: The end date for which to calculate the Returns.
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AggregatedReturnsResponse, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_aggregated_returns_with_http_info(scope, code, aggregated_returns_request, **kwargs)

   def get_portfolio_commands(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioCommands: Get portfolio commands  # noqa: E501

Get all the commands that modified a particular portfolio, including any input transactions.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_commands(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param from_as_at: The lower bound asAt datetime (inclusive) from which to retrieve commands. There is no lower bound if this is not specified.
:type from_as_at: datetime
:param to_as_at: The upper bound asAt datetime (inclusive) from which to retrieve commands. There is no upper bound if this is not specified.
:type to_as_at: datetime
:param filter: Expression to filter the results.              For example, to filter on the User ID, specify "userId.id eq 'string'".              For more information about filtering, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing commands; this value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 500 if not specified.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfProcessedCommand"""
        return self.__client.get_portfolio_commands(scope, code, **kwargs)

   def get_portfolio_commands_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioCommands: Get portfolio commands  # noqa: E501

Get all the commands that modified a particular portfolio, including any input transactions.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_commands_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param from_as_at: The lower bound asAt datetime (inclusive) from which to retrieve commands. There is no lower bound if this is not specified.
:type from_as_at: datetime
:param to_as_at: The upper bound asAt datetime (inclusive) from which to retrieve commands. There is no upper bound if this is not specified.
:type to_as_at: datetime
:param filter: Expression to filter the results.              For example, to filter on the User ID, specify "userId.id eq 'string'".              For more information about filtering, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing commands; this value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 500 if not specified.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfProcessedCommand, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_commands_with_http_info(scope, code, **kwargs)

   def get_portfolio_metadata(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioMetadata: Get access metadata rules for a portfolio  # noqa: E501

Pass the scope and portfolio code parameters to retrieve the AccessMetadata associated with a portfolio  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_metadata(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Access Metadata Rule to retrieve. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the access metadata rule.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio access metadata.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.get_portfolio_metadata(scope, code, **kwargs)

   def get_portfolio_metadata_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioMetadata: Get access metadata rules for a portfolio  # noqa: E501

Pass the scope and portfolio code parameters to retrieve the AccessMetadata associated with a portfolio  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_metadata_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Access Metadata Rule to retrieve. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param effective_at: The effectiveAt datetime at which to retrieve the access metadata rule.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio access metadata.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_metadata_with_http_info(scope, code, **kwargs)

   def get_portfolio_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioProperties: Get portfolio properties  # noqa: E501

List all the properties of a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the portfolio's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolio's properties. Defaults to returning the latest version of each property if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioProperties"""
        return self.__client.get_portfolio_properties(scope, code, **kwargs)

   def get_portfolio_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolioProperties: Get portfolio properties  # noqa: E501

List all the properties of a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the portfolio's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolio's properties. Defaults to returning the latest version of each property if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioProperties, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_properties_with_http_info(scope, code, **kwargs)

   def get_portfolio_property_time_series(self, scope: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioPropertyTimeSeries: Get portfolio property time series  # noqa: E501

Show the complete time series (history) for a particular portfolio property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_property_time_series(scope, code, property_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param property_key: The property key of the property whose history to show.              This must be from the 'Portfolio' domain and in the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'. (required)
:type property_key: str
:param portfolio_effective_at: The effective datetime used to resolve the portfolio. Defaults to the current LUSID system datetime if not specified.
:type portfolio_effective_at: str
:param as_at: The asAt datetime at which to show the history. Defaults to returning the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the results. For more information about filtering,              see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing properties; this value is returned from              the previous call. If a pagination token is provided, the filter, portfolioEffectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyInterval"""
        return self.__client.get_portfolio_property_time_series(scope, code, property_key, **kwargs)

   def get_portfolio_property_time_series_with_http_info(self, scope: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioPropertyTimeSeries: Get portfolio property time series  # noqa: E501

Show the complete time series (history) for a particular portfolio property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_property_time_series_with_http_info(scope, code, property_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param property_key: The property key of the property whose history to show.              This must be from the 'Portfolio' domain and in the format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'. (required)
:type property_key: str
:param portfolio_effective_at: The effective datetime used to resolve the portfolio. Defaults to the current LUSID system datetime if not specified.
:type portfolio_effective_at: str
:param as_at: The asAt datetime at which to show the history. Defaults to returning the current datetime if not supplied.
:type as_at: datetime
:param filter: Expression to filter the results. For more information about filtering,              see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param page: The pagination token to use to continue listing properties; this value is returned from              the previous call. If a pagination token is provided, the filter, portfolioEffectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyInterval, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_property_time_series_with_http_info(scope, code, property_key, **kwargs)

   def get_portfolio_relations(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPortfolioRelations: Get portfolio relations  # noqa: E501

Get relations for a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_relations(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relations. Defaults to returning the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Provide a null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These must be from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. Only identifier types provided will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelation"""
        return self.__client.get_portfolio_relations(scope, code, **kwargs)

   def get_portfolio_relations_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetPortfolioRelations: Get portfolio relations  # noqa: E501

Get relations for a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_relations_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relations. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relations. Defaults to returning the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relations. Provide a null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These must be from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. Only identifier types provided will be used to look up relevant entities in relations. If not applicable, provide an empty array.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelation, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_relations_with_http_info(scope, code, **kwargs)

   def get_portfolio_relationships(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioRelationships: Get portfolio relationships  # noqa: E501

Get relationships for a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_relationships(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to returning the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relationships. Provide a null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfRelationship"""
        return self.__client.get_portfolio_relationships(scope, code, **kwargs)

   def get_portfolio_relationships_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioRelationships: Get portfolio relationships  # noqa: E501

Get relationships for a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_relationships_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve relationships. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve relationships. Defaults to returning the latest LUSID AsAt time if not specified.
:type as_at: datetime
:param filter: Expression to filter the relationships. Provide a null or empty string for this field until further notice.
:type filter: str
:param identifier_types: Identifier types (as property keys) used for referencing Persons or Legal Entities.              These can be specified from the 'Person' or 'LegalEntity' domains and have the format {domain}/{scope}/{code}, for example              'Person/CompanyDetails/Role'. An Empty array may be used to return all related Entities.
:type identifier_types: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfRelationship, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_relationships_with_http_info(scope, code, **kwargs)

   def get_portfolio_returns(self, scope: Any, code: Any, return_scope: Any, return_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioReturns: Get Returns  # noqa: E501

Get Returns which are on the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_returns(scope, code, return_scope, return_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param from_effective_at: The start date from which to get the Returns.
:type from_effective_at: str
:param to_effective_at: The end date from which to get the Returns.
:type to_effective_at: str
:param period: Show the Returns on a Daily or Monthly period. Defaults to Daily.
:type period: str
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPerformanceReturn"""
        return self.__client.get_portfolio_returns(scope, code, return_scope, return_code, **kwargs)

   def get_portfolio_returns_with_http_info(self, scope: Any, code: Any, return_scope: Any, return_code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfolioReturns: Get Returns  # noqa: E501

Get Returns which are on the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_returns_with_http_info(scope, code, return_scope, return_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param from_effective_at: The start date from which to get the Returns.
:type from_effective_at: str
:param to_effective_at: The end date from which to get the Returns.
:type to_effective_at: str
:param period: Show the Returns on a Daily or Monthly period. Defaults to Daily.
:type period: str
:param as_at: The asAt datetime at which to retrieve the Returns. Defaults to the latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPerformanceReturn, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_returns_with_http_info(scope, code, return_scope, return_code, **kwargs)

   def get_portfolio_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPortfolio: Get portfolio  # noqa: E501

Retrieve the definition of a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the portfolio definition. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio definition. Defaults to returning the latest version of the portfolio definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Portfolio' domain to decorate onto the portfolio,              or from any domain that supports relationships to decorate onto related entities. These must take the format              {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolio in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Portfolio, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_with_http_info(scope, code, **kwargs)

   def get_portfolios_access_metadata_by_key(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfoliosAccessMetadataByKey: Get an entry identified by a metadataKey in the access metadata object  # noqa: E501

Get a specific portfolio access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolios_access_metadata_by_key(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Access Metadata Rule to retrieve. (required)
:type scope: str
:param code: The code of the portfolio (required)
:type code: str
:param metadata_key: Key of the metadata to retrieve (required)
:type metadata_key: str
:param effective_at: The effective date of the rule
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio access metadata.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[AccessMetadataValue]"""
        return self.__client.get_portfolios_access_metadata_by_key(scope, code, metadata_key, **kwargs)

   def get_portfolios_access_metadata_by_key_with_http_info(self, scope: Any, code: Any, metadata_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPortfoliosAccessMetadataByKey: Get an entry identified by a metadataKey in the access metadata object  # noqa: E501

Get a specific portfolio access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolios_access_metadata_by_key_with_http_info(scope, code, metadata_key, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Access Metadata Rule to retrieve. (required)
:type scope: str
:param code: The code of the portfolio (required)
:type code: str
:param metadata_key: Key of the metadata to retrieve (required)
:type metadata_key: str
:param effective_at: The effective date of the rule
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio access metadata.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[AccessMetadataValue], int, HTTPHeaderDict)"""
        return self.__client.get_portfolios_access_metadata_by_key_with_http_info(scope, code, metadata_key, **kwargs)

   def list_portfolio_properties(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPortfolioProperties: Get portfolio properties  # noqa: E501

List all the properties of a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolio_properties(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the portfolio's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolio's properties. Defaults to returning the latest version of each property if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing commands; this value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the results per page to this number.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfProperty"""
        return self.__client.list_portfolio_properties(scope, code, **kwargs)

   def list_portfolio_properties_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListPortfolioProperties: Get portfolio properties  # noqa: E501

List all the properties of a particular portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolio_properties_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the portfolio's properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolio's properties. Defaults to returning the latest version of each property if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing commands; this value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the results per page to this number.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfProperty, int, HTTPHeaderDict)"""
        return self.__client.list_portfolio_properties_with_http_info(scope, code, **kwargs)

   def list_portfolios(self, **kwargs) -> 'Any':
        """ListPortfolios: List portfolios  # noqa: E501

List all the portfolios matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolios(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the portfolios. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolios. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing portfolios; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the transaction type, specify "type eq 'Transaction'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param query: Expression specifying the criteria that the returned portfolios must meet. For example, to see which              portfolios have holdings in instruments with a LusidInstrumentId (LUID) of 'LUID_PPA8HI6M' or a Figi of 'BBG000BLNNH6',              specify "instrument.identifiers in (('LusidInstrumentId', 'LUID_PPA8HI6M'), ('Figi', 'BBG000BLNNH6'))".
:type query: str
:param property_keys: A list of property keys from the 'Portfolio' domain to decorate onto each portfolio,              or from any domain that supports relationships to decorate onto related entities. These must take the              format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolios in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPortfolio"""
        return self.__client.list_portfolios(**kwargs)

   def list_portfolios_for_scope(self, scope: Any, **kwargs) -> 'Any':
        """ListPortfoliosForScope: List portfolios for scope  # noqa: E501

List all the portfolios in a particular scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolios_for_scope(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope whose portfolios to list. (required)
:type scope: str
:param effective_at: The effective datetime or cut label at which to list the portfolios. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolios. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing portfolios. This  value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'Portfolio' domain to decorate onto each portfolio,              or from any domain that supports relationships to decorate onto related entities. These must take the              format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolios in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPortfolio"""
        return self.__client.list_portfolios_for_scope(scope, **kwargs)

   def list_portfolios_for_scope_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """ListPortfoliosForScope: List portfolios for scope  # noqa: E501

List all the portfolios in a particular scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolios_for_scope_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope whose portfolios to list. (required)
:type scope: str
:param effective_at: The effective datetime or cut label at which to list the portfolios. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolios. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing portfolios. This  value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt  and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param property_keys: A list of property keys from the 'Portfolio' domain to decorate onto each portfolio,              or from any domain that supports relationships to decorate onto related entities. These must take the              format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolios in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPortfolio, int, HTTPHeaderDict)"""
        return self.__client.list_portfolios_for_scope_with_http_info(scope, **kwargs)

   def list_portfolios_with_http_info(self, **kwargs) -> 'Any':
        """ListPortfolios: List portfolios  # noqa: E501

List all the portfolios matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_portfolios_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the portfolios. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the portfolios. Defaults to returning the latest version              of each portfolio if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing portfolios; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the transaction type, specify "type eq 'Transaction'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param query: Expression specifying the criteria that the returned portfolios must meet. For example, to see which              portfolios have holdings in instruments with a LusidInstrumentId (LUID) of 'LUID_PPA8HI6M' or a Figi of 'BBG000BLNNH6',              specify "instrument.identifiers in (('LusidInstrumentId', 'LUID_PPA8HI6M'), ('Figi', 'BBG000BLNNH6'))".
:type query: str
:param property_keys: A list of property keys from the 'Portfolio' domain to decorate onto each portfolio,              or from any domain that supports relationships to decorate onto related entities. These must take the              format {domain}/{scope}/{code}, for example 'Portfolio/Manager/Id'.
:type property_keys: list[str]
:param relationship_definition_ids: A list of relationship definitions that are used to decorate related entities              onto the portfolios in the response. These must take the form {relationshipDefinitionScope}/{relationshipDefinitionCode}.
:type relationship_definition_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPortfolio, int, HTTPHeaderDict)"""
        return self.__client.list_portfolios_with_http_info(**kwargs)

   def patch_portfolio(self, scope: Any, code: Any, operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolio: Patch portfolio.  # noqa: E501

Create or update certain fields for a particular  portfolio.  The behaviour is defined by the JSON Patch specification.                Currently supported are: CreationDate, InstrumentScopes.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio(scope, code, operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the               scope this uniquely identifies the portfolio. (required)
:type code: str
:param operation: The json patch document. For more check: https://datatracker.ietf.org/doc/html/rfc6902. (required)
:type operation: list[Operation]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ActionResultOfPortfolio"""
        return self.__client.patch_portfolio(scope, code, operation, **kwargs)

   def patch_portfolio_access_metadata(self, scope: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolioAccessMetadata: Patch Access Metadata rules for a Portfolio.  # noqa: E501

Patch Portfolio Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document.    Currently only valid metadata keys are supported paths on the patch document.    The response will return any affected Portfolio Access Metadata rules or a failure message if unsuccessful.    It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_access_metadata(scope, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Access Metadata Rule. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The date this rule will effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[AccessMetadataValue])"""
        return self.__client.patch_portfolio_access_metadata(scope, code, access_metadata_operation, **kwargs)

   def patch_portfolio_access_metadata_with_http_info(self, scope: Any, code: Any, access_metadata_operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolioAccessMetadata: Patch Access Metadata rules for a Portfolio.  # noqa: E501

Patch Portfolio Access Metadata Rules in a single scope.  The behaviour is defined by the JSON Patch specification.                Currently only 'add' is a supported operation on the patch document.    Currently only valid metadata keys are supported paths on the patch document.    The response will return any affected Portfolio Access Metadata rules or a failure message if unsuccessful.    It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_access_metadata_with_http_info(scope, code, access_metadata_operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio Access Metadata Rule. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param access_metadata_operation: The Json Patch document (required)
:type access_metadata_operation: list[AccessMetadataOperation]
:param effective_at: The date this rule will effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[AccessMetadataValue]), int, HTTPHeaderDict)"""
        return self.__client.patch_portfolio_access_metadata_with_http_info(scope, code, access_metadata_operation, **kwargs)

   def patch_portfolio_with_http_info(self, scope: Any, code: Any, operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolio: Patch portfolio.  # noqa: E501

Create or update certain fields for a particular  portfolio.  The behaviour is defined by the JSON Patch specification.                Currently supported are: CreationDate, InstrumentScopes.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_with_http_info(scope, code, operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the               scope this uniquely identifies the portfolio. (required)
:type code: str
:param operation: The json patch document. For more check: https://datatracker.ietf.org/doc/html/rfc6902. (required)
:type operation: list[Operation]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ActionResultOfPortfolio, int, HTTPHeaderDict)"""
        return self.__client.patch_portfolio_with_http_info(scope, code, operation, **kwargs)

   def update_portfolio(self, scope: Any, code: Any, update_portfolio_request: Any, **kwargs) -> 'Any':
        """UpdatePortfolio: Update portfolio  # noqa: E501

Update the definition of a particular portfolio.                Note that not all elements of a portfolio definition are  modifiable due to the potential implications for data already stored.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_portfolio(scope, code, update_portfolio_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param update_portfolio_request: The updated portfolio definition. (required)
:type update_portfolio_request: UpdatePortfolioRequest
:param effective_at: The effective datetime or cut label at which to update the definition. Defaults to the current               LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Portfolio"""
        return self.__client.update_portfolio(scope, code, update_portfolio_request, **kwargs)

   def update_portfolio_with_http_info(self, scope: Any, code: Any, update_portfolio_request: Any, **kwargs) -> 'Any':
        """UpdatePortfolio: Update portfolio  # noqa: E501

Update the definition of a particular portfolio.                Note that not all elements of a portfolio definition are  modifiable due to the potential implications for data already stored.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_portfolio_with_http_info(scope, code, update_portfolio_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param update_portfolio_request: The updated portfolio definition. (required)
:type update_portfolio_request: UpdatePortfolioRequest
:param effective_at: The effective datetime or cut label at which to update the definition. Defaults to the current               LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Portfolio, int, HTTPHeaderDict)"""
        return self.__client.update_portfolio_with_http_info(scope, code, update_portfolio_request, **kwargs)

   def upsert_portfolio_access_metadata(self, scope: Any, code: Any, metadata_key: Any, upsert_portfolio_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPortfolioAccessMetadata: Upsert a Portfolio Access Metadata Rule associated with specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Portfolio Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Portfolio Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_access_metadata(scope, code, metadata_key, upsert_portfolio_access_metadata_request, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the Portfolio Access Metadata Rule. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param metadata_key: Key of the access metadata to upsert (required)
:type metadata_key: str
:param upsert_portfolio_access_metadata_request: The Portfolio Access Metadata Rule to update or insert (required)
:type upsert_portfolio_access_metadata_request: UpsertPortfolioAccessMetadataRequest
:param effective_at: The date this rule will effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAccessMetadataValueOf"""
        return self.__client.upsert_portfolio_access_metadata(scope, code, metadata_key, upsert_portfolio_access_metadata_request, **kwargs)

   def upsert_portfolio_access_metadata_with_http_info(self, scope: Any, code: Any, metadata_key: Any, upsert_portfolio_access_metadata_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPortfolioAccessMetadata: Upsert a Portfolio Access Metadata Rule associated with specific metadataKey. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Portfolio Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Portfolio Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_access_metadata_with_http_info(scope, code, metadata_key, upsert_portfolio_access_metadata_request, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the Portfolio Access Metadata Rule. (required)
:type scope: str
:param code: Portfolio code (required)
:type code: str
:param metadata_key: Key of the access metadata to upsert (required)
:type metadata_key: str
:param upsert_portfolio_access_metadata_request: The Portfolio Access Metadata Rule to update or insert (required)
:type upsert_portfolio_access_metadata_request: UpsertPortfolioAccessMetadataRequest
:param effective_at: The date this rule will effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAccessMetadataValueOf, int, HTTPHeaderDict)"""
        return self.__client.upsert_portfolio_access_metadata_with_http_info(scope, code, metadata_key, upsert_portfolio_access_metadata_request, **kwargs)

   def upsert_portfolio_properties(self, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """UpsertPortfolioProperties: Upsert portfolio properties  # noqa: E501

Create or update one or more properties for a particular portfolio. A property is updated if it  already exists and created if it does not. All properties must be from the 'Portfolio' domain.                Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which it is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_properties(scope, code, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param request_body: The properties to be created or updated. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code}, for example               'Portfolio/Manager/Id'. (required)
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioProperties"""
        return self.__client.upsert_portfolio_properties(scope, code, request_body, **kwargs)

   def upsert_portfolio_properties_with_http_info(self, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """UpsertPortfolioProperties: Upsert portfolio properties  # noqa: E501

Create or update one or more properties for a particular portfolio. A property is updated if it  already exists and created if it does not. All properties must be from the 'Portfolio' domain.                Properties have an <i>effectiveFrom</i> datetime from which the property is valid, and an <i>effectiveUntil</i>  datetime until which it is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_properties_with_http_info(scope, code, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio. (required)
:type scope: str
:param code: The code of the portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param request_body: The properties to be created or updated. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code}, for example               'Portfolio/Manager/Id'. (required)
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_portfolio_properties_with_http_info(scope, code, request_body, **kwargs)

   def upsert_portfolio_returns(self, scope: Any, code: Any, return_scope: Any, return_code: Any, performance_return: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPortfolioReturns: Upsert Returns  # noqa: E501

Update or insert returns into the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_returns(scope, code, return_scope, return_code, performance_return, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param performance_return: This contains the Returns which need to be upsert. (required)
:type performance_return: list[PerformanceReturn]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertReturnsResponse"""
        return self.__client.upsert_portfolio_returns(scope, code, return_scope, return_code, performance_return, **kwargs)

   def upsert_portfolio_returns_with_http_info(self, scope: Any, code: Any, return_scope: Any, return_code: Any, performance_return: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPortfolioReturns: Upsert Returns  # noqa: E501

Update or insert returns into the specified portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_returns_with_http_info(scope, code, return_scope, return_code, performance_return, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Portfolio. (required)
:type scope: str
:param code: The code of the  Portfolio. (required)
:type code: str
:param return_scope: The scope of the Returns. (required)
:type return_scope: str
:param return_code: The code of the Returns. (required)
:type return_code: str
:param performance_return: This contains the Returns which need to be upsert. (required)
:type performance_return: list[PerformanceReturn]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertReturnsResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_portfolio_returns_with_http_info(scope, code, return_scope, return_code, performance_return, **kwargs)

portfolios_api = __PortfoliosApiAuthedAndStubbed()

class __PropertyDefinitionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.PropertyDefinitionsApi)

   def create_derived_property_definition(self, create_derived_property_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateDerivedPropertyDefinition: Create derived property definition  # noqa: E501

Define a new derived property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_derived_property_definition(create_derived_property_definition_request, async_req=True)
>>> result = thread.get()

:param create_derived_property_definition_request: The definition of the new derived property. (required)
:type create_derived_property_definition_request: CreateDerivedPropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PropertyDefinition"""
        return self.__client.create_derived_property_definition(create_derived_property_definition_request, **kwargs)

   def create_derived_property_definition_with_http_info(self, create_derived_property_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateDerivedPropertyDefinition: Create derived property definition  # noqa: E501

Define a new derived property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_derived_property_definition_with_http_info(create_derived_property_definition_request, async_req=True)
>>> result = thread.get()

:param create_derived_property_definition_request: The definition of the new derived property. (required)
:type create_derived_property_definition_request: CreateDerivedPropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_derived_property_definition_with_http_info(create_derived_property_definition_request, **kwargs)

   def create_property_definition(self, create_property_definition_request: Any, **kwargs) -> 'Any':
        """CreatePropertyDefinition: Create property definition  # noqa: E501

Define a new property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_property_definition(create_property_definition_request, async_req=True)
>>> result = thread.get()

:param create_property_definition_request: The definition of the new property. (required)
:type create_property_definition_request: CreatePropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PropertyDefinition"""
        return self.__client.create_property_definition(create_property_definition_request, **kwargs)

   def create_property_definition_with_http_info(self, create_property_definition_request: Any, **kwargs) -> 'Any':
        """CreatePropertyDefinition: Create property definition  # noqa: E501

Define a new property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_property_definition_with_http_info(create_property_definition_request, async_req=True)
>>> result = thread.get()

:param create_property_definition_request: The definition of the new property. (required)
:type create_property_definition_request: CreatePropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_property_definition_with_http_info(create_property_definition_request, **kwargs)

   def delete_property_definition(self, domain: Any, scope: Any, code: Any, **kwargs) -> 'Any':
        """DeletePropertyDefinition: Delete property definition  # noqa: E501

Delete the definition of the specified property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_property_definition(domain, scope, code, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property to be deleted. (required)
:type domain: str
:param scope: The scope of the property to be deleted. (required)
:type scope: str
:param code: The code of the property to be deleted. Together with the domain and scope this uniquely              identifies the property. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_property_definition(domain, scope, code, **kwargs)

   def delete_property_definition_properties(self, domain: Any, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePropertyDefinitionProperties: Delete property definition properties  # noqa: E501

Delete one or more properties from a single property definition. If the properties are time-variant then an effective date time from which the  properties will be deleted must be specified. If the properties are perpetual then it is invalid to specify an effective date time for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_property_definition_properties(domain, scope, code, request_body, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property definition to delete properties from. (required)
:type domain: str
:param scope: The scope of the property definition to delete properties from. (required)
:type scope: str
:param code: The code of the property definition to delete properties from. (required)
:type code: str
:param request_body: The property keys of the properties to delete. These must take the format              {domain}/{scope}/{code} e.g "PropertyDefinition/myScope/someAttributeKey". Each property must be from the "PropertyDefinition" domain. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is before              the time-variant property exists then a failure is returned. Do not specify this parameter if an of the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_property_definition_properties(domain, scope, code, request_body, **kwargs)

   def delete_property_definition_properties_with_http_info(self, domain: Any, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeletePropertyDefinitionProperties: Delete property definition properties  # noqa: E501

Delete one or more properties from a single property definition. If the properties are time-variant then an effective date time from which the  properties will be deleted must be specified. If the properties are perpetual then it is invalid to specify an effective date time for deletion.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_property_definition_properties_with_http_info(domain, scope, code, request_body, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property definition to delete properties from. (required)
:type domain: str
:param scope: The scope of the property definition to delete properties from. (required)
:type scope: str
:param code: The code of the property definition to delete properties from. (required)
:type code: str
:param request_body: The property keys of the properties to delete. These must take the format              {domain}/{scope}/{code} e.g "PropertyDefinition/myScope/someAttributeKey". Each property must be from the "PropertyDefinition" domain. (required)
:type request_body: list[str]
:param effective_at: The effective datetime or cut label at which to delete time-variant properties from.              The property must exist at the specified 'effectiveAt' datetime. If the 'effectiveAt' is not provided or is before              the time-variant property exists then a failure is returned. Do not specify this parameter if an of the properties to delete are perpetual.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_property_definition_properties_with_http_info(domain, scope, code, request_body, **kwargs)

   def delete_property_definition_with_http_info(self, domain: Any, scope: Any, code: Any, **kwargs) -> 'Any':
        """DeletePropertyDefinition: Delete property definition  # noqa: E501

Delete the definition of the specified property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_property_definition_with_http_info(domain, scope, code, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property to be deleted. (required)
:type domain: str
:param scope: The scope of the property to be deleted. (required)
:type scope: str
:param code: The code of the property to be deleted. Together with the domain and scope this uniquely              identifies the property. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_property_definition_with_http_info(domain, scope, code, **kwargs)

   def get_multiple_property_definitions(self, property_keys: Any, **kwargs) -> 'Any':
        """GetMultiplePropertyDefinitions: Get multiple property definitions  # noqa: E501

Retrieve the definition of one or more specified properties.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_multiple_property_definitions(property_keys, async_req=True)
>>> result = thread.get()

:param property_keys: One or more property keys which identify each property that a definition should              be retrieved for. The format for each property key is {domain}/{scope}/{code}, e.g. 'Portfolio/Manager/Id'. (required)
:type property_keys: list[str]
:param as_at: The asAt datetime at which to retrieve the property definitions. Defaults to return              the latest version of each definition if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the Lifetime, use "lifeTime eq 'Perpetual'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param effective_at: The effective datetime or cut label at which to list properties attached to the Property Definition.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyDefinition"""
        return self.__client.get_multiple_property_definitions(property_keys, **kwargs)

   def get_multiple_property_definitions_with_http_info(self, property_keys: Any, **kwargs) -> 'Any':
        """GetMultiplePropertyDefinitions: Get multiple property definitions  # noqa: E501

Retrieve the definition of one or more specified properties.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_multiple_property_definitions_with_http_info(property_keys, async_req=True)
>>> result = thread.get()

:param property_keys: One or more property keys which identify each property that a definition should              be retrieved for. The format for each property key is {domain}/{scope}/{code}, e.g. 'Portfolio/Manager/Id'. (required)
:type property_keys: list[str]
:param as_at: The asAt datetime at which to retrieve the property definitions. Defaults to return              the latest version of each definition if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to filter on the Lifetime, use "lifeTime eq 'Perpetual'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param effective_at: The effective datetime or cut label at which to list properties attached to the Property Definition.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_multiple_property_definitions_with_http_info(property_keys, **kwargs)

   def get_property_definition(self, domain: Any, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPropertyDefinition: Get property definition  # noqa: E501

Retrieve the definition of a specified property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_property_definition(domain, scope, code, async_req=True)
>>> result = thread.get()

:param domain: The domain of the specified property. (required)
:type domain: str
:param scope: The scope of the specified property. (required)
:type scope: str
:param code: The code of the specified property. Together with the domain and scope this uniquely              identifies the property. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the property definition. Defaults to return              the latest version of the definition if not specified.
:type as_at: datetime
:param effective_at: The effective datetime or cut label at which to list properties attached to the Property Definition.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PropertyDefinition"""
        return self.__client.get_property_definition(domain, scope, code, **kwargs)

   def get_property_definition_property_time_series(self, domain: Any, scope: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPropertyDefinitionPropertyTimeSeries: Get Property Definition Property Time Series  # noqa: E501

List the complete time series of a property definition property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_property_definition_property_time_series(domain, scope, code, property_key, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property definition to which the property is attached (required)
:type domain: str
:param scope: The scope of the property definition to which the property is attached (required)
:type scope: str
:param code: The code of the property definition to which the property is attached (required)
:type code: str
:param property_key: The property key of the property whose history to show. This must be from the "Property Definition" domain and in the format              {domain}/{scope}/{code}, for example "PropertyDefinition/myScope/someAttributeKey". (required)
:type property_key: str
:param as_at: The asAt datetime at which to show the history. Defaults to the current datetime if not specified.
:type as_at: datetime
:param filter: Expression to filter the results. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPropertyInterval"""
        return self.__client.get_property_definition_property_time_series(domain, scope, code, property_key, **kwargs)

   def get_property_definition_property_time_series_with_http_info(self, domain: Any, scope: Any, code: Any, property_key: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPropertyDefinitionPropertyTimeSeries: Get Property Definition Property Time Series  # noqa: E501

List the complete time series of a property definition property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_property_definition_property_time_series_with_http_info(domain, scope, code, property_key, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property definition to which the property is attached (required)
:type domain: str
:param scope: The scope of the property definition to which the property is attached (required)
:type scope: str
:param code: The code of the property definition to which the property is attached (required)
:type code: str
:param property_key: The property key of the property whose history to show. This must be from the "Property Definition" domain and in the format              {domain}/{scope}/{code}, for example "PropertyDefinition/myScope/someAttributeKey". (required)
:type property_key: str
:param as_at: The asAt datetime at which to show the history. Defaults to the current datetime if not specified.
:type as_at: datetime
:param filter: Expression to filter the results. Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param page: The pagination token to use to continue listing properties from a previous call to get property time series.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPropertyInterval, int, HTTPHeaderDict)"""
        return self.__client.get_property_definition_property_time_series_with_http_info(domain, scope, code, property_key, **kwargs)

   def get_property_definition_with_http_info(self, domain: Any, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetPropertyDefinition: Get property definition  # noqa: E501

Retrieve the definition of a specified property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_property_definition_with_http_info(domain, scope, code, async_req=True)
>>> result = thread.get()

:param domain: The domain of the specified property. (required)
:type domain: str
:param scope: The scope of the specified property. (required)
:type scope: str
:param code: The code of the specified property. Together with the domain and scope this uniquely              identifies the property. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the property definition. Defaults to return              the latest version of the definition if not specified.
:type as_at: datetime
:param effective_at: The effective datetime or cut label at which to list properties attached to the Property Definition.              Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_property_definition_with_http_info(domain, scope, code, **kwargs)

   def list_property_definitions(self, **kwargs) -> 'Any':
        """ListPropertyDefinitions: List property definitions  # noqa: E501

List all the property definitions matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_property_definitions(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the property definitions. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the property definitions. Defaults to returning the latest version              of each property definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Property Definition' domain to decorate onto              property definitions. These must take the format              {domain}/{scope}/{code} e.g "PropertyDefinition/myScope/someAttributeKey". Each property must be from the "PropertyDefinition" domain.
:type property_keys: list[str]
:param page: The pagination token to use to continue listing property definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the display name, specify "DisplayName eq 'DisplayName'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPropertyDefinition"""
        return self.__client.list_property_definitions(**kwargs)

   def list_property_definitions_with_http_info(self, **kwargs) -> 'Any':
        """ListPropertyDefinitions: List property definitions  # noqa: E501

List all the property definitions matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_property_definitions_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the property definitions. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the property definitions. Defaults to returning the latest version              of each property definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Property Definition' domain to decorate onto              property definitions. These must take the format              {domain}/{scope}/{code} e.g "PropertyDefinition/myScope/someAttributeKey". Each property must be from the "PropertyDefinition" domain.
:type property_keys: list[str]
:param page: The pagination token to use to continue listing property definitions; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the display name, specify "DisplayName eq 'DisplayName'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_property_definitions_with_http_info(**kwargs)

   def update_derived_property_definition(self, domain: Any, scope: Any, code: Any, update_derived_property_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateDerivedPropertyDefinition: Update a pre-existing derived property definition  # noqa: E501

This will fail if the property definition does not exist  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_derived_property_definition(domain, scope, code, update_derived_property_definition_request, async_req=True)
>>> result = thread.get()

:param domain: Domain of the property definition (required)
:type domain: str
:param scope: Scope of the property definition (required)
:type scope: str
:param code: Code of the property definition (required)
:type code: str
:param update_derived_property_definition_request: Information about the derived property definition being updated (required)
:type update_derived_property_definition_request: UpdateDerivedPropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PropertyDefinition"""
        return self.__client.update_derived_property_definition(domain, scope, code, update_derived_property_definition_request, **kwargs)

   def update_derived_property_definition_with_http_info(self, domain: Any, scope: Any, code: Any, update_derived_property_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateDerivedPropertyDefinition: Update a pre-existing derived property definition  # noqa: E501

This will fail if the property definition does not exist  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_derived_property_definition_with_http_info(domain, scope, code, update_derived_property_definition_request, async_req=True)
>>> result = thread.get()

:param domain: Domain of the property definition (required)
:type domain: str
:param scope: Scope of the property definition (required)
:type scope: str
:param code: Code of the property definition (required)
:type code: str
:param update_derived_property_definition_request: Information about the derived property definition being updated (required)
:type update_derived_property_definition_request: UpdateDerivedPropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.update_derived_property_definition_with_http_info(domain, scope, code, update_derived_property_definition_request, **kwargs)

   def update_property_definition(self, domain: Any, scope: Any, code: Any, update_property_definition_request: Any, **kwargs) -> 'Any':
        """UpdatePropertyDefinition: Update property definition  # noqa: E501

Update the definition of a specified existing property. Not all elements within a property definition  are modifiable due to the potential implications for values already stored against the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_property_definition(domain, scope, code, update_property_definition_request, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property being updated. (required)
:type domain: str
:param scope: The scope of the property being updated. (required)
:type scope: str
:param code: The code of the property being updated. Together with the domain and scope this uniquely              identifies the property. (required)
:type code: str
:param update_property_definition_request: The updated definition of the property. (required)
:type update_property_definition_request: UpdatePropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PropertyDefinition"""
        return self.__client.update_property_definition(domain, scope, code, update_property_definition_request, **kwargs)

   def update_property_definition_with_http_info(self, domain: Any, scope: Any, code: Any, update_property_definition_request: Any, **kwargs) -> 'Any':
        """UpdatePropertyDefinition: Update property definition  # noqa: E501

Update the definition of a specified existing property. Not all elements within a property definition  are modifiable due to the potential implications for values already stored against the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_property_definition_with_http_info(domain, scope, code, update_property_definition_request, async_req=True)
>>> result = thread.get()

:param domain: The domain of the property being updated. (required)
:type domain: str
:param scope: The scope of the property being updated. (required)
:type scope: str
:param code: The code of the property being updated. Together with the domain and scope this uniquely              identifies the property. (required)
:type code: str
:param update_property_definition_request: The updated definition of the property. (required)
:type update_property_definition_request: UpdatePropertyDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PropertyDefinition, int, HTTPHeaderDict)"""
        return self.__client.update_property_definition_with_http_info(domain, scope, code, update_property_definition_request, **kwargs)

   def upsert_property_definition_properties(self, domain: Any, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPropertyDefinitionProperties: Upsert properties to a property definition  # noqa: E501

Create or update properties for a particular property definition  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_property_definition_properties(domain, scope, code, request_body, async_req=True)
>>> result = thread.get()

:param domain: The domain of the specified property. (required)
:type domain: str
:param scope: The scope of the specified property. (required)
:type scope: str
:param code: The code of the specified property. Together with the domain and scope this uniquely (required)
:type code: str
:param request_body: The properties to be created or updated. Each property in              the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code}, for example              'PropertyDefinition/Manager/Id'. (required)
:type request_body: dict(str, ModelProperty)
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial.
:type success_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BatchUpsertPropertyDefinitionPropertiesResponse"""
        return self.__client.upsert_property_definition_properties(domain, scope, code, request_body, **kwargs)

   def upsert_property_definition_properties_with_http_info(self, domain: Any, scope: Any, code: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertPropertyDefinitionProperties: Upsert properties to a property definition  # noqa: E501

Create or update properties for a particular property definition  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_property_definition_properties_with_http_info(domain, scope, code, request_body, async_req=True)
>>> result = thread.get()

:param domain: The domain of the specified property. (required)
:type domain: str
:param scope: The scope of the specified property. (required)
:type scope: str
:param code: The code of the specified property. Together with the domain and scope this uniquely (required)
:type code: str
:param request_body: The properties to be created or updated. Each property in              the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code}, for example              'PropertyDefinition/Manager/Id'. (required)
:type request_body: dict(str, ModelProperty)
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial.
:type success_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BatchUpsertPropertyDefinitionPropertiesResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_property_definition_properties_with_http_info(domain, scope, code, request_body, **kwargs)

property_definitions_api = __PropertyDefinitionsApiAuthedAndStubbed()

class __QuotesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.QuotesApi)

   def delete_quote_access_metadata_rule(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteQuoteAccessMetadataRule: Delete a Quote Access Metadata Rule  # noqa: E501

Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_quote_access_metadata_rule(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param provider: The Provider of the rule
:type provider: str
:param price_source: The PriceSource of the rule
:type price_source: str
:param instrument_id_type: The InstrumentIdType of the rule
:type instrument_id_type: str
:param instrument_id: The InstrumentId of the rule
:type instrument_id: str
:param quote_type: The QuoteType of the rule
:type quote_type: str
:param field: The Field of the rule
:type field: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: QuoteAccessMetadataRule"""
        return self.__client.delete_quote_access_metadata_rule(scope, **kwargs)

   def delete_quote_access_metadata_rule_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteQuoteAccessMetadataRule: Delete a Quote Access Metadata Rule  # noqa: E501

Delete the Quote Access Metadata Rule that exactly matches the provided identifier parts  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_quote_access_metadata_rule_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param provider: The Provider of the rule
:type provider: str
:param price_source: The PriceSource of the rule
:type price_source: str
:param instrument_id_type: The InstrumentIdType of the rule
:type instrument_id_type: str
:param instrument_id: The InstrumentId of the rule
:type instrument_id: str
:param quote_type: The QuoteType of the rule
:type quote_type: str
:param field: The Field of the rule
:type field: str
:param effective_at: The effective date to delete at, if this is not supplied, it will delete all data found
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (QuoteAccessMetadataRule, int, HTTPHeaderDict)"""
        return self.__client.delete_quote_access_metadata_rule_with_http_info(scope, **kwargs)

   def delete_quotes(self, scope: Any, **kwargs) -> 'Any':
        """DeleteQuotes: Delete quotes  # noqa: E501

Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_quotes(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to delete. (required)
:type scope: str
:param request_body: The quotes to delete keyed by a unique correlation id.
:type request_body: dict(str, QuoteId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulQuotesResponse"""
        return self.__client.delete_quotes(scope, **kwargs)

   def delete_quotes_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """DeleteQuotes: Delete quotes  # noqa: E501

Delete one or more specified quotes from a single scope. A quote is identified by its unique id which includes information about  the type of quote as well as the exact effective datetime (to the microsecond) from which it became valid.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully deleted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be deleted.                It is important to always check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_quotes_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to delete. (required)
:type scope: str
:param request_body: The quotes to delete keyed by a unique correlation id.
:type request_body: dict(str, QuoteId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulQuotesResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_quotes_with_http_info(scope, **kwargs)

   def get_quotes(self, scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetQuotes: Get quotes  # noqa: E501

Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_quotes(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to retrieve. (required)
:type scope: str
:param effective_at: The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified.
:type as_at: datetime
:param max_age: The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved.
:type max_age: str
:param request_body: The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response.
:type request_body: dict(str, QuoteSeriesId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetQuotesResponse"""
        return self.__client.get_quotes(scope, **kwargs)

   def get_quotes_access_metadata_rule(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetQuotesAccessMetadataRule: Get a quote access metadata rule  # noqa: E501

Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_quotes_access_metadata_rule(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param provider: The Provider of the rule
:type provider: str
:param price_source: The PriceSource of the rule
:type price_source: str
:param instrument_id_type: The InstrumentIdType of the rule
:type instrument_id_type: str
:param instrument_id: The InstrumentId of the rule
:type instrument_id: str
:param quote_type: The QuoteType of the rule
:type quote_type: str
:param field: The Field of the rule
:type field: str
:param effective_at: The effective date of the rule
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: QuoteAccessMetadataRule"""
        return self.__client.get_quotes_access_metadata_rule(scope, **kwargs)

   def get_quotes_access_metadata_rule_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetQuotesAccessMetadataRule: Get a quote access metadata rule  # noqa: E501

Get a specific quote access metadata rule by specifying the corresponding identifier parts                No matching will be performed through this endpoint. To retrieve a rule, it is necessary to specify, exactly, the identifier of the rule  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_quotes_access_metadata_rule_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param provider: The Provider of the rule
:type provider: str
:param price_source: The PriceSource of the rule
:type price_source: str
:param instrument_id_type: The InstrumentIdType of the rule
:type instrument_id_type: str
:param instrument_id: The InstrumentId of the rule
:type instrument_id: str
:param quote_type: The QuoteType of the rule
:type quote_type: str
:param field: The Field of the rule
:type field: str
:param effective_at: The effective date of the rule
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (QuoteAccessMetadataRule, int, HTTPHeaderDict)"""
        return self.__client.get_quotes_access_metadata_rule_with_http_info(scope, **kwargs)

   def get_quotes_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetQuotes: Get quotes  # noqa: E501

Get one or more quotes from a single scope.                Each quote can be identified by its time invariant quote series id.                For each quote series id LUSID will return the most recent quote with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified which defines how far back to look back for a quote from the specified effective datetime.  LUSID will return the most recent quote within this window.                In the request each quote series id must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return three collections. One, the successfully retrieved quotes. Two, those that had a  valid quote series id but could not be found. Three, those that failed because LUSID could not construct a valid quote series id from the request.    For the quotes that failed or could not be found a reason will be provided explaining why the quote could not be retrieved.                It is important to always check the failed and not found sets for any unsuccessful results.  The maximum number of quotes that this method can get per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_quotes_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to retrieve. (required)
:type scope: str
:param effective_at: The effective datetime or cut label at which to retrieve the quotes. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the quotes. Defaults to return the latest version of each quote if not specified.
:type as_at: datetime
:param max_age: The duration of the look back window in an ISO8601 time interval format e.g. P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime or cut label to generate a effective datetime window inside which a quote must exist to be retrieved.
:type max_age: str
:param request_body: The time invariant quote series ids of the quotes to retrieve. These need to be               keyed by a unique correlation id allowing the retrieved quote to be identified in the response.
:type request_body: dict(str, QuoteSeriesId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetQuotesResponse, int, HTTPHeaderDict)"""
        return self.__client.get_quotes_with_http_info(scope, **kwargs)

   def list_quotes(self, scope: Any, **kwargs) -> 'Any':
        """[DEPRECATED] ListQuotes: List quotes  # noqa: E501

List all the quotes from a single scope at the specified date/time  Please use M:Finbourne.WebApi.Controllers.QuotesController.ListQuotesForScope(System.String,System.Nullable{System.DateTimeOffset},System.String,System.Nullable{System.Int32},System.String) - the signature and behaviour of this endpoint will be changing to omit scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_quotes(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to list. (required)
:type scope: str
:param as_at: The asAt datetime at which to list the quotes. Defaults to latest if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfQuote"""
        return self.__client.list_quotes(scope, **kwargs)

   def list_quotes_access_metadata_rules(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListQuotesAccessMetadataRules: List all quote access metadata rules in a scope  # noqa: E501

Get all the quote access metadata rules in the specified scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_quotes_access_metadata_rules(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param as_at: The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfQuoteAccessMetadataRule"""
        return self.__client.list_quotes_access_metadata_rules(scope, **kwargs)

   def list_quotes_access_metadata_rules_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListQuotesAccessMetadataRules: List all quote access metadata rules in a scope  # noqa: E501

Get all the quote access metadata rules in the specified scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_quotes_access_metadata_rules_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Quote Access Metadata Rule to retrieve. (required)
:type scope: str
:param as_at: The asAt datetime at which to retrieve the access metadata rule. Defaults to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfQuoteAccessMetadataRule, int, HTTPHeaderDict)"""
        return self.__client.list_quotes_access_metadata_rules_with_http_info(scope, **kwargs)

   def list_quotes_for_scope(self, scope: Any, **kwargs) -> 'Any':
        """ListQuotesForScope: List quotes for scope  # noqa: E501

List all the quotes from a single scope at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_quotes_for_scope(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to list. (required)
:type scope: str
:param as_at: The asAt datetime at which to list the quotes. Defaults to latest if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfQuote"""
        return self.__client.list_quotes_for_scope(scope, **kwargs)

   def list_quotes_for_scope_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """ListQuotesForScope: List quotes for scope  # noqa: E501

List all the quotes from a single scope at the specified date/time  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_quotes_for_scope_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to list. (required)
:type scope: str
:param as_at: The asAt datetime at which to list the quotes. Defaults to latest if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfQuote, int, HTTPHeaderDict)"""
        return self.__client.list_quotes_for_scope_with_http_info(scope, **kwargs)

   def list_quotes_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[DEPRECATED] ListQuotes: List quotes  # noqa: E501

List all the quotes from a single scope at the specified date/time  Please use M:Finbourne.WebApi.Controllers.QuotesController.ListQuotesForScope(System.String,System.Nullable{System.DateTimeOffset},System.String,System.Nullable{System.Int32},System.String) - the signature and behaviour of this endpoint will be changing to omit scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_quotes_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the quotes to list. (required)
:type scope: str
:param as_at: The asAt datetime at which to list the quotes. Defaults to latest if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing quotes from a previous call to list quotes.              This value is returned from the previous call. If a pagination token is provided the sortBy, filter, effectiveAt, and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfQuote, int, HTTPHeaderDict)"""
        return self.__client.list_quotes_with_http_info(scope, **kwargs)

   def upsert_quote_access_metadata_rule(self, scope: Any, upsert_quote_access_metadata_rule_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertQuoteAccessMetadataRule: Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_quote_access_metadata_rule(scope, upsert_quote_access_metadata_rule_request, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the Quote Access Metadata Rule. (required)
:type scope: str
:param upsert_quote_access_metadata_rule_request: The Quote Access Metadata Rule to update or insert (required)
:type upsert_quote_access_metadata_rule_request: UpsertQuoteAccessMetadataRuleRequest
:param effective_at: The date this rule will effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: QuoteAccessMetadataRule"""
        return self.__client.upsert_quote_access_metadata_rule(scope, upsert_quote_access_metadata_rule_request, **kwargs)

   def upsert_quote_access_metadata_rule_with_http_info(self, scope: Any, upsert_quote_access_metadata_rule_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertQuoteAccessMetadataRule: Upsert a Quote Access Metadata Rule. This creates or updates the data in LUSID.  # noqa: E501

Update or insert one Quote Access Metadata Rule in a single scope. An item will be updated if it already exists  and inserted if it does not.    The response will return the successfully updated or inserted Quote Access Metadata Rule or failure message if unsuccessful    It is important to always check to verify success (or failure).                Multiple rules for a key can exists with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_quote_access_metadata_rule_with_http_info(scope, upsert_quote_access_metadata_rule_request, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the Quote Access Metadata Rule. (required)
:type scope: str
:param upsert_quote_access_metadata_rule_request: The Quote Access Metadata Rule to update or insert (required)
:type upsert_quote_access_metadata_rule_request: UpsertQuoteAccessMetadataRuleRequest
:param effective_at: The date this rule will effective from
:type effective_at: str
:param effective_until: The effective date until which the Access Metadata is valid. If not supplied this will be valid indefinitely, or until the next 'effectiveAt' date of the Access Metadata
:type effective_until: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (QuoteAccessMetadataRule, int, HTTPHeaderDict)"""
        return self.__client.upsert_quote_access_metadata_rule_with_http_info(scope, upsert_quote_access_metadata_rule_request, **kwargs)

   def upsert_quotes(self, scope: Any, **kwargs) -> 'Any':
        """UpsertQuotes: Upsert quotes  # noqa: E501

Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_quotes(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the quotes. (required)
:type scope: str
:param request_body: The quotes to update or insert keyed by a unique correlation id.
:type request_body: dict(str, UpsertQuoteRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertQuotesResponse"""
        return self.__client.upsert_quotes(scope, **kwargs)

   def upsert_quotes_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """UpsertQuotes: Upsert quotes  # noqa: E501

Update or insert one or more quotes in a single scope. A quote will be updated if it already exists  and inserted if it does not.                In the request each quote must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each quote in the response.                The response will return both the collection of successfully updated or inserted quotes, as well as those that failed.  For the failures a reason will be provided explaining why the quote could not be updated or inserted.                It is important to always check the failed set for any unsuccessful results.  The maximum number of quotes that this method can upsert per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_quotes_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope to use when updating or inserting the quotes. (required)
:type scope: str
:param request_body: The quotes to update or insert keyed by a unique correlation id.
:type request_body: dict(str, UpsertQuoteRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertQuotesResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_quotes_with_http_info(scope, **kwargs)

quotes_api = __QuotesApiAuthedAndStubbed()

class __ReconciliationsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ReconciliationsApi)

   def create_scheduled_reconciliation(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation  # noqa: E501

Create a scheduled reconciliation for the given request  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_scheduled_reconciliation(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reconciliation (required)
:type scope: str
:param create_reconciliation_request: The definition of the reconciliation
:type create_reconciliation_request: CreateReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Reconciliation"""
        return self.__client.create_scheduled_reconciliation(scope, **kwargs)

   def create_scheduled_reconciliation_with_http_info(self, scope: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateScheduledReconciliation: Create a scheduled reconciliation  # noqa: E501

Create a scheduled reconciliation for the given request  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_scheduled_reconciliation_with_http_info(scope, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reconciliation (required)
:type scope: str
:param create_reconciliation_request: The definition of the reconciliation
:type create_reconciliation_request: CreateReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Reconciliation, int, HTTPHeaderDict)"""
        return self.__client.create_scheduled_reconciliation_with_http_info(scope, **kwargs)

   def delete_reconciliation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation  # noqa: E501

Delete the given scheduled reconciliation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_reconciliation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the scheduled reconciliation (required)
:type scope: str
:param code: The code of the scheduled reconciliation (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_reconciliation(scope, code, **kwargs)

   def delete_reconciliation_mapping(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping  # noqa: E501

Deletes the mapping identified by the scope and code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_reconciliation_mapping(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the mapping. (required)
:type scope: str
:param code: The code fof the mapping. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: str"""
        return self.__client.delete_reconciliation_mapping(scope, code, **kwargs)

   def delete_reconciliation_mapping_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteReconciliationMapping: Delete a mapping  # noqa: E501

Deletes the mapping identified by the scope and code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_reconciliation_mapping_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the mapping. (required)
:type scope: str
:param code: The code fof the mapping. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (str, int, HTTPHeaderDict)"""
        return self.__client.delete_reconciliation_mapping_with_http_info(scope, code, **kwargs)

   def delete_reconciliation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteReconciliation: Delete scheduled reconciliation  # noqa: E501

Delete the given scheduled reconciliation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_reconciliation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the scheduled reconciliation (required)
:type scope: str
:param code: The code of the scheduled reconciliation (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_reconciliation_with_http_info(scope, code, **kwargs)

   def get_reconciliation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation  # noqa: E501

Get the requested scheduled reconciliation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reconciliation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the scheduled reconciliation (required)
:type scope: str
:param code: The code of the scheduled reconciliation (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Reconciliation' property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example 'Reconciliation/Broker/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Reconciliation"""
        return self.__client.get_reconciliation(scope, code, **kwargs)

   def get_reconciliation_mapping(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetReconciliationMapping: Get a mapping  # noqa: E501

Gets a mapping identified by the given scope and code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reconciliation_mapping(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the mapping. (required)
:type scope: str
:param code: The code of the mapping. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Mapping"""
        return self.__client.get_reconciliation_mapping(scope, code, **kwargs)

   def get_reconciliation_mapping_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetReconciliationMapping: Get a mapping  # noqa: E501

Gets a mapping identified by the given scope and code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reconciliation_mapping_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the mapping. (required)
:type scope: str
:param code: The code of the mapping. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Mapping, int, HTTPHeaderDict)"""
        return self.__client.get_reconciliation_mapping_with_http_info(scope, code, **kwargs)

   def get_reconciliation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetReconciliation: Get scheduled reconciliation  # noqa: E501

Get the requested scheduled reconciliation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reconciliation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the scheduled reconciliation (required)
:type scope: str
:param code: The code of the scheduled reconciliation (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the scheduled reconciliation. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the scheduled reconciliation. Defaults to returning the latest version of the reconciliation if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Reconciliation' property domain to decorate onto the reconciliation.              These must take the form {domain}/{scope}/{code}, for example 'Reconciliation/Broker/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Reconciliation, int, HTTPHeaderDict)"""
        return self.__client.get_reconciliation_with_http_info(scope, code, **kwargs)

   def list_reconciliation_mappings(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings  # noqa: E501

Lists all mappings this user is entitled to see  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_reconciliation_mappings(async_req=True)
>>> result = thread.get()

:param reconciliation_type: Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided.
:type reconciliation_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfMapping"""
        return self.__client.list_reconciliation_mappings(**kwargs)

   def list_reconciliation_mappings_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListReconciliationMappings: List the reconciliation mappings  # noqa: E501

Lists all mappings this user is entitled to see  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_reconciliation_mappings_with_http_info(async_req=True)
>>> result = thread.get()

:param reconciliation_type: Optional parameter to specify which type of mappings should be returned.  Defaults to Transaction if not provided.
:type reconciliation_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfMapping, int, HTTPHeaderDict)"""
        return self.__client.list_reconciliation_mappings_with_http_info(**kwargs)

   def list_reconciliations(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListReconciliations: List scheduled reconciliations  # noqa: E501

List all the scheduled reconciliations matching particular criteria  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_reconciliations(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the reconciliation type, specify "id.Code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'Reconciliation' domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example 'Reconciliation/Broker/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfReconciliation"""
        return self.__client.list_reconciliations(**kwargs)

   def list_reconciliations_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListReconciliations: List scheduled reconciliations  # noqa: E501

List all the scheduled reconciliations matching particular criteria  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_reconciliations_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties for the reconciliation. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to list the reconciliation. Defaults to returning the latest version              of each reconciliation if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing reconciliations; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the reconciliation type, specify "id.Code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'Reconciliation' domain to decorate onto each reconciliation.              These must take the format {domain}/{scope}/{code}, for example 'Reconciliation/Broker/Id'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfReconciliation, int, HTTPHeaderDict)"""
        return self.__client.list_reconciliations_with_http_info(**kwargs)

   def reconcile_generic(self, **kwargs) -> 'Any':
        """ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are 'empty' or null or zero.  # noqa: E501

Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_generic(async_req=True)
>>> result = thread.get()

:param reconciliation_request: The specifications of the inputs to the reconciliation
:type reconciliation_request: ReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ReconciliationResponse"""
        return self.__client.reconcile_generic(**kwargs)

   def reconcile_generic_with_http_info(self, **kwargs) -> 'Any':
        """ReconcileGeneric: Reconcile either holdings or valuations performed on one or two sets of holdings using one or two configuration recipes.                The output is configurable for various types of comparisons, to allow tolerances on numerical and date-time data or case-insensitivity on strings,  and elision of resulting differences where they are 'empty' or null or zero.  # noqa: E501

Perform evaluation of one or two set of holdings (a portfolio of instruments) using one or two (potentially different) configuration recipes.  Produce a breakdown of the resulting differences in evaluation that can be iterated through.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_generic_with_http_info(async_req=True)
>>> result = thread.get()

:param reconciliation_request: The specifications of the inputs to the reconciliation
:type reconciliation_request: ReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ReconciliationResponse, int, HTTPHeaderDict)"""
        return self.__client.reconcile_generic_with_http_info(**kwargs)

   def reconcile_holdings(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings  # noqa: E501

Reconcile the holdings of two portfolios.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_holdings(async_req=True)
>>> result = thread.get()

:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use "left.portfolioId.code eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param portfolios_reconciliation_request: The specifications of the inputs to the reconciliation
:type portfolios_reconciliation_request: PortfoliosReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfReconciliationBreak"""
        return self.__client.reconcile_holdings(**kwargs)

   def reconcile_holdings_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ReconcileHoldings: Reconcile portfolio holdings  # noqa: E501

Reconcile the holdings of two portfolios.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_holdings_with_http_info(async_req=True)
>>> result = thread.get()

:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Optional. Expression to filter the result set.              For example, to filter on the left portfolio Code, use "left.portfolioId.code eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param portfolios_reconciliation_request: The specifications of the inputs to the reconciliation
:type portfolios_reconciliation_request: PortfoliosReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfReconciliationBreak, int, HTTPHeaderDict)"""
        return self.__client.reconcile_holdings_with_http_info(**kwargs)

   def reconcile_inline(self, **kwargs) -> 'Any':
        """ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes.  # noqa: E501

Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_inline(async_req=True)
>>> result = thread.get()

:param inline_valuations_reconciliation_request: The specifications of the inputs to the reconciliation
:type inline_valuations_reconciliation_request: InlineValuationsReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ListAggregationReconciliation"""
        return self.__client.reconcile_inline(**kwargs)

   def reconcile_inline_with_http_info(self, **kwargs) -> 'Any':
        """ReconcileInline: Reconcile valuations performed on one or two sets of inline instruments using one or two configuration recipes.  # noqa: E501

Perform valuation of one or two set of inline instruments using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_inline_with_http_info(async_req=True)
>>> result = thread.get()

:param inline_valuations_reconciliation_request: The specifications of the inputs to the reconciliation
:type inline_valuations_reconciliation_request: InlineValuationsReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ListAggregationReconciliation, int, HTTPHeaderDict)"""
        return self.__client.reconcile_inline_with_http_info(**kwargs)

   def reconcile_transactions(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation.  # noqa: E501

Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_transactions(async_req=True)
>>> result = thread.get()

:param transaction_reconciliation_request:
:type transaction_reconciliation_request: TransactionReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionsReconciliationsResponse"""
        return self.__client.reconcile_transactions(**kwargs)

   def reconcile_transactions_v2(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ReconcileTransactionsV2: Perform a Transactions Reconciliation.  # noqa: E501

Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_transactions_v2(async_req=True)
>>> result = thread.get()

:param transaction_reconciliation_request_v2:
:type transaction_reconciliation_request_v2: TransactionReconciliationRequestV2
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ReconciliationResponse"""
        return self.__client.reconcile_transactions_v2(**kwargs)

   def reconcile_transactions_v2_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ReconcileTransactionsV2: Perform a Transactions Reconciliation.  # noqa: E501

Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_transactions_v2_with_http_info(async_req=True)
>>> result = thread.get()

:param transaction_reconciliation_request_v2:
:type transaction_reconciliation_request_v2: TransactionReconciliationRequestV2
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ReconciliationResponse, int, HTTPHeaderDict)"""
        return self.__client.reconcile_transactions_v2_with_http_info(**kwargs)

   def reconcile_transactions_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ReconcileTransactions: Perform a Transactions Reconciliation.  # noqa: E501

Evaluates two sets of transactions to determine which transactions from each set likely match  using the rules of a specified mapping.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_transactions_with_http_info(async_req=True)
>>> result = thread.get()

:param transaction_reconciliation_request:
:type transaction_reconciliation_request: TransactionReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionsReconciliationsResponse, int, HTTPHeaderDict)"""
        return self.__client.reconcile_transactions_with_http_info(**kwargs)

   def reconcile_valuation(self, **kwargs) -> 'Any':
        """ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes.  # noqa: E501

Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_valuation(async_req=True)
>>> result = thread.get()

:param valuations_reconciliation_request: The specifications of the inputs to the reconciliation
:type valuations_reconciliation_request: ValuationsReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ListAggregationReconciliation"""
        return self.__client.reconcile_valuation(**kwargs)

   def reconcile_valuation_with_http_info(self, **kwargs) -> 'Any':
        """ReconcileValuation: Reconcile valuations performed on one or two sets of holdings using one or two configuration recipes.  # noqa: E501

Perform valuation of one or two set of holdings using different one or two configuration recipes. Produce a breakdown of the resulting differences in valuation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.reconcile_valuation_with_http_info(async_req=True)
>>> result = thread.get()

:param valuations_reconciliation_request: The specifications of the inputs to the reconciliation
:type valuations_reconciliation_request: ValuationsReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ListAggregationReconciliation, int, HTTPHeaderDict)"""
        return self.__client.reconcile_valuation_with_http_info(**kwargs)

   def update_reconciliation(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation  # noqa: E501

Update a given scheduled reconciliation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_reconciliation(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reconciliation to be updated (required)
:type scope: str
:param code: The code of the reconciliation to be updated (required)
:type code: str
:param update_reconciliation_request: The updated definition of the reconciliation
:type update_reconciliation_request: UpdateReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Reconciliation"""
        return self.__client.update_reconciliation(scope, code, **kwargs)

   def update_reconciliation_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpdateReconciliation: Update scheduled reconciliation  # noqa: E501

Update a given scheduled reconciliation  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_reconciliation_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reconciliation to be updated (required)
:type scope: str
:param code: The code of the reconciliation to be updated (required)
:type code: str
:param update_reconciliation_request: The updated definition of the reconciliation
:type update_reconciliation_request: UpdateReconciliationRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Reconciliation, int, HTTPHeaderDict)"""
        return self.__client.update_reconciliation_with_http_info(scope, code, **kwargs)

   def upsert_reconciliation_mapping(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping  # noqa: E501

If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_reconciliation_mapping(async_req=True)
>>> result = thread.get()

:param mapping: The mapping to be created / updated.
:type mapping: Mapping
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Mapping"""
        return self.__client.upsert_reconciliation_mapping(**kwargs)

   def upsert_reconciliation_mapping_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertReconciliationMapping: Create or update a mapping  # noqa: E501

If no mapping exists with the specified scope and code will create a new one.  Else will update the existing mapping  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_reconciliation_mapping_with_http_info(async_req=True)
>>> result = thread.get()

:param mapping: The mapping to be created / updated.
:type mapping: Mapping
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Mapping, int, HTTPHeaderDict)"""
        return self.__client.upsert_reconciliation_mapping_with_http_info(**kwargs)

reconciliations_api = __ReconciliationsApiAuthedAndStubbed()

class __ReferenceListsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ReferenceListsApi)

   def delete_reference_list(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteReferenceList: Delete Reference List  # noqa: E501

Delete a Reference List instance.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_reference_list(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the Reference List belongs. (required)
:type scope: str
:param code: The Reference List's unique identifier. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_reference_list(scope, code, **kwargs)

   def delete_reference_list_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteReferenceList: Delete Reference List  # noqa: E501

Delete a Reference List instance.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_reference_list_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the Reference List belongs. (required)
:type scope: str
:param code: The Reference List's unique identifier. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_reference_list_with_http_info(scope, code, **kwargs)

   def get_reference_list(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetReferenceList: Get Reference List  # noqa: E501

Retrieve a Reference List instance at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reference_list(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the Reference List belongs. (required)
:type scope: str
:param code: The Reference List's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Reference List. Defaults to return the latest version of the Reference List if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ReferenceListResponse"""
        return self.__client.get_reference_list(scope, code, **kwargs)

   def get_reference_list_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetReferenceList: Get Reference List  # noqa: E501

Retrieve a Reference List instance at a point in AsAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reference_list_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope to which the Reference List belongs. (required)
:type scope: str
:param code: The Reference List's unique identifier. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the Reference List. Defaults to return the latest version of the Reference List if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ReferenceListResponse, int, HTTPHeaderDict)"""
        return self.__client.get_reference_list_with_http_info(scope, code, **kwargs)

   def list_reference_lists(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListReferenceLists: List Reference Lists  # noqa: E501

List all the Reference Lists matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_reference_lists(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list Reference Lists. Defaults to return the latest version of Reference Lists if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Reference Lists from a previous call to list Reference Lists.              This value is returned from the previous call. If a pagination token is provided, the filter, limit and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfReferenceListResponse"""
        return self.__client.list_reference_lists(**kwargs)

   def list_reference_lists_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListReferenceLists: List Reference Lists  # noqa: E501

List all the Reference Lists matching particular criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_reference_lists_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to list Reference Lists. Defaults to return the latest version of Reference Lists if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing Reference Lists from a previous call to list Reference Lists.              This value is returned from the previous call. If a pagination token is provided, the filter, limit and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfReferenceListResponse, int, HTTPHeaderDict)"""
        return self.__client.list_reference_lists_with_http_info(**kwargs)

   def upsert_reference_list(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertReferenceList: Upsert Reference List  # noqa: E501

Insert the Reference List if it does not exist or update the Reference List with the supplied state if it does exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_reference_list(async_req=True)
>>> result = thread.get()

:param reference_list_request: The payload describing the Reference List instance.
:type reference_list_request: ReferenceListRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ReferenceListResponse"""
        return self.__client.upsert_reference_list(**kwargs)

   def upsert_reference_list_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertReferenceList: Upsert Reference List  # noqa: E501

Insert the Reference List if it does not exist or update the Reference List with the supplied state if it does exist.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_reference_list_with_http_info(async_req=True)
>>> result = thread.get()

:param reference_list_request: The payload describing the Reference List instance.
:type reference_list_request: ReferenceListRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ReferenceListResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_reference_list_with_http_info(**kwargs)

reference_lists_api = __ReferenceListsApiAuthedAndStubbed()

class __ReferencePortfolioApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ReferencePortfolioApi)

   def create_reference_portfolio(self, scope: Any, create_reference_portfolio_request: Any, **kwargs) -> 'Any':
        """CreateReferencePortfolio: Create reference portfolio  # noqa: E501

Create a reference portfolio in a particular scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_reference_portfolio(scope, create_reference_portfolio_request, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create the reference portfolio. (required)
:type scope: str
:param create_reference_portfolio_request: The definition of the reference portfolio. (required)
:type create_reference_portfolio_request: CreateReferencePortfolioRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Portfolio"""
        return self.__client.create_reference_portfolio(scope, create_reference_portfolio_request, **kwargs)

   def create_reference_portfolio_with_http_info(self, scope: Any, create_reference_portfolio_request: Any, **kwargs) -> 'Any':
        """CreateReferencePortfolio: Create reference portfolio  # noqa: E501

Create a reference portfolio in a particular scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_reference_portfolio_with_http_info(scope, create_reference_portfolio_request, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create the reference portfolio. (required)
:type scope: str
:param create_reference_portfolio_request: The definition of the reference portfolio. (required)
:type create_reference_portfolio_request: CreateReferencePortfolioRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Portfolio, int, HTTPHeaderDict)"""
        return self.__client.create_reference_portfolio_with_http_info(scope, create_reference_portfolio_request, **kwargs)

   def get_reference_portfolio_constituents(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetReferencePortfolioConstituents: Get reference portfolio constituents  # noqa: E501

Get constituents from a reference portfolio at a particular effective time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reference_portfolio_constituents(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reference portfolio. (required)
:type scope: str
:param code: The code of the reference portfolio. Together with the scope this uniquely identifies              the reference portfolio. (required)
:type code: str
:param effective_at: The effective date of the constituents to retrieve. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve constituents. Defaults to return the latest version              of each constituent if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Instrument' or 'ReferenceHolding' domain to decorate onto              constituents. These take the format {domain}/{scope}/{code} e.g. 'Instrument/system/Name' or              'ReferenceHolding/strategy/quantsignal'. Defaults to return all available instrument and reference holding properties if not specified.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetReferencePortfolioConstituentsResponse"""
        return self.__client.get_reference_portfolio_constituents(scope, code, **kwargs)

   def get_reference_portfolio_constituents_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetReferencePortfolioConstituents: Get reference portfolio constituents  # noqa: E501

Get constituents from a reference portfolio at a particular effective time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_reference_portfolio_constituents_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reference portfolio. (required)
:type scope: str
:param code: The code of the reference portfolio. Together with the scope this uniquely identifies              the reference portfolio. (required)
:type code: str
:param effective_at: The effective date of the constituents to retrieve. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve constituents. Defaults to return the latest version              of each constituent if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'Instrument' or 'ReferenceHolding' domain to decorate onto              constituents. These take the format {domain}/{scope}/{code} e.g. 'Instrument/system/Name' or              'ReferenceHolding/strategy/quantsignal'. Defaults to return all available instrument and reference holding properties if not specified.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetReferencePortfolioConstituentsResponse, int, HTTPHeaderDict)"""
        return self.__client.get_reference_portfolio_constituents_with_http_info(scope, code, **kwargs)

   def list_constituents_adjustments(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """ListConstituentsAdjustments: List constituents adjustments  # noqa: E501

List adjustments made to constituents in a reference portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_constituents_adjustments(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reference portfolio. (required)
:type scope: str
:param code: The code of the reference portfolio. Together with the scope this uniquely identifies              the reference portfolio. (required)
:type code: str
:param from_effective_at: Events between this time (inclusive) and the toEffectiveAt are returned. (required)
:type from_effective_at: str
:param to_effective_at: Events between this time (inclusive) and the fromEffectiveAt are returned. (required)
:type to_effective_at: str
:param as_at_time: The asAt time for which the result is valid.
:type as_at_time: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfConstituentsAdjustmentHeader"""
        return self.__client.list_constituents_adjustments(scope, code, from_effective_at, to_effective_at, **kwargs)

   def list_constituents_adjustments_with_http_info(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """ListConstituentsAdjustments: List constituents adjustments  # noqa: E501

List adjustments made to constituents in a reference portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_constituents_adjustments_with_http_info(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reference portfolio. (required)
:type scope: str
:param code: The code of the reference portfolio. Together with the scope this uniquely identifies              the reference portfolio. (required)
:type code: str
:param from_effective_at: Events between this time (inclusive) and the toEffectiveAt are returned. (required)
:type from_effective_at: str
:param to_effective_at: Events between this time (inclusive) and the fromEffectiveAt are returned. (required)
:type to_effective_at: str
:param as_at_time: The asAt time for which the result is valid.
:type as_at_time: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfConstituentsAdjustmentHeader, int, HTTPHeaderDict)"""
        return self.__client.list_constituents_adjustments_with_http_info(scope, code, from_effective_at, to_effective_at, **kwargs)

   def upsert_reference_portfolio_constituents(self, scope: Any, code: Any, upsert_reference_portfolio_constituents_request: Any, **kwargs) -> 'Any':
        """UpsertReferencePortfolioConstituents: Upsert reference portfolio constituents  # noqa: E501

Add constituents to a reference portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_reference_portfolio_constituents(scope, code, upsert_reference_portfolio_constituents_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reference portfolio. (required)
:type scope: str
:param code: The code of the reference portfolio. Together with the scope this uniquely identifies              the reference portfolio. (required)
:type code: str
:param upsert_reference_portfolio_constituents_request: The constituents to upload to the reference portfolio. (required)
:type upsert_reference_portfolio_constituents_request: UpsertReferencePortfolioConstituentsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertReferencePortfolioConstituentsResponse"""
        return self.__client.upsert_reference_portfolio_constituents(scope, code, upsert_reference_portfolio_constituents_request, **kwargs)

   def upsert_reference_portfolio_constituents_with_http_info(self, scope: Any, code: Any, upsert_reference_portfolio_constituents_request: Any, **kwargs) -> 'Any':
        """UpsertReferencePortfolioConstituents: Upsert reference portfolio constituents  # noqa: E501

Add constituents to a reference portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_reference_portfolio_constituents_with_http_info(scope, code, upsert_reference_portfolio_constituents_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the reference portfolio. (required)
:type scope: str
:param code: The code of the reference portfolio. Together with the scope this uniquely identifies              the reference portfolio. (required)
:type code: str
:param upsert_reference_portfolio_constituents_request: The constituents to upload to the reference portfolio. (required)
:type upsert_reference_portfolio_constituents_request: UpsertReferencePortfolioConstituentsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertReferencePortfolioConstituentsResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_reference_portfolio_constituents_with_http_info(scope, code, upsert_reference_portfolio_constituents_request, **kwargs)

reference_portfolio_api = __ReferencePortfolioApiAuthedAndStubbed()

class __RelationDefinitionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.RelationDefinitionsApi)

   def create_relation_definition(self, create_relation_definition_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateRelationDefinition: Create a relation definition  # noqa: E501

Define a new relation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relation_definition(create_relation_definition_request, async_req=True)
>>> result = thread.get()

:param create_relation_definition_request: The definition of the new relation. (required)
:type create_relation_definition_request: CreateRelationDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: RelationDefinition"""
        return self.__client.create_relation_definition(create_relation_definition_request, **kwargs)

   def create_relation_definition_with_http_info(self, create_relation_definition_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateRelationDefinition: Create a relation definition  # noqa: E501

Define a new relation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relation_definition_with_http_info(create_relation_definition_request, async_req=True)
>>> result = thread.get()

:param create_relation_definition_request: The definition of the new relation. (required)
:type create_relation_definition_request: CreateRelationDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (RelationDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_relation_definition_with_http_info(create_relation_definition_request, **kwargs)

   def delete_relation_definition(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteRelationDefinition: Delete relation definition  # noqa: E501

Delete the definition of the specified relation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relation_definition(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relation to be deleted. (required)
:type scope: str
:param code: The code of the relation to be deleted. Together with the domain and scope this uniquely              identifies the relation. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_relation_definition(scope, code, **kwargs)

   def delete_relation_definition_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteRelationDefinition: Delete relation definition  # noqa: E501

Delete the definition of the specified relation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relation_definition_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relation to be deleted. (required)
:type scope: str
:param code: The code of the relation to be deleted. Together with the domain and scope this uniquely              identifies the relation. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_relation_definition_with_http_info(scope, code, **kwargs)

   def get_relation_definition(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetRelationDefinition: Get relation definition  # noqa: E501

Retrieve the definition of a specified relation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_relation_definition(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the specified relation. (required)
:type scope: str
:param code: The code of the specified relation. Together with the domain and scope this uniquely              identifies the relation. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the relation definition. Defaults to return              the latest version of the definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: RelationDefinition"""
        return self.__client.get_relation_definition(scope, code, **kwargs)

   def get_relation_definition_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetRelationDefinition: Get relation definition  # noqa: E501

Retrieve the definition of a specified relation.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_relation_definition_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the specified relation. (required)
:type scope: str
:param code: The code of the specified relation. Together with the domain and scope this uniquely              identifies the relation. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the relation definition. Defaults to return              the latest version of the definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (RelationDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_relation_definition_with_http_info(scope, code, **kwargs)

relation_definitions_api = __RelationDefinitionsApiAuthedAndStubbed()

class __RelationsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.RelationsApi)

   def create_relation(self, scope: Any, code: Any, create_relation_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateRelation: Create Relation  # noqa: E501

Create a relation between two entity objects by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relation(scope, code, create_relation_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relation definition (required)
:type scope: str
:param code: The code of the relation definition (required)
:type code: str
:param create_relation_request: The details of the relation to create. (required)
:type create_relation_request: CreateRelationRequest
:param effective_at: The effective datetime or cut label at which the relation should be effective from. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CompleteRelation"""
        return self.__client.create_relation(scope, code, create_relation_request, **kwargs)

   def create_relation_with_http_info(self, scope: Any, code: Any, create_relation_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateRelation: Create Relation  # noqa: E501

Create a relation between two entity objects by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relation_with_http_info(scope, code, create_relation_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relation definition (required)
:type scope: str
:param code: The code of the relation definition (required)
:type code: str
:param create_relation_request: The details of the relation to create. (required)
:type create_relation_request: CreateRelationRequest
:param effective_at: The effective datetime or cut label at which the relation should be effective from. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CompleteRelation, int, HTTPHeaderDict)"""
        return self.__client.create_relation_with_http_info(scope, code, create_relation_request, **kwargs)

   def delete_relation(self, scope: Any, code: Any, delete_relation_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteRelation: Delete a relation  # noqa: E501

Delete a relation between two entity objects represented by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relation(scope, code, delete_relation_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relation definition (required)
:type scope: str
:param code: The code of the relation definition (required)
:type code: str
:param delete_relation_request: The details of the relation to delete. (required)
:type delete_relation_request: DeleteRelationRequest
:param effective_at: The effective datetime or cut label at which the relation should the deletion be effective from. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_relation(scope, code, delete_relation_request, **kwargs)

   def delete_relation_with_http_info(self, scope: Any, code: Any, delete_relation_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteRelation: Delete a relation  # noqa: E501

Delete a relation between two entity objects represented by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relation_with_http_info(scope, code, delete_relation_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relation definition (required)
:type scope: str
:param code: The code of the relation definition (required)
:type code: str
:param delete_relation_request: The details of the relation to delete. (required)
:type delete_relation_request: DeleteRelationRequest
:param effective_at: The effective datetime or cut label at which the relation should the deletion be effective from. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_relation_with_http_info(scope, code, delete_relation_request, **kwargs)

relations_api = __RelationsApiAuthedAndStubbed()

class __RelationshipDefinitionsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.RelationshipDefinitionsApi)

   def create_relationship_definition(self, create_relationship_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateRelationshipDefinition: Create Relationship Definition  # noqa: E501

Create a new relationship definition to be used for creating relationships between entities.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relationship_definition(create_relationship_definition_request, async_req=True)
>>> result = thread.get()

:param create_relationship_definition_request: The definition of the new relationship. (required)
:type create_relationship_definition_request: CreateRelationshipDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: RelationshipDefinition"""
        return self.__client.create_relationship_definition(create_relationship_definition_request, **kwargs)

   def create_relationship_definition_with_http_info(self, create_relationship_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateRelationshipDefinition: Create Relationship Definition  # noqa: E501

Create a new relationship definition to be used for creating relationships between entities.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relationship_definition_with_http_info(create_relationship_definition_request, async_req=True)
>>> result = thread.get()

:param create_relationship_definition_request: The definition of the new relationship. (required)
:type create_relationship_definition_request: CreateRelationshipDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (RelationshipDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_relationship_definition_with_http_info(create_relationship_definition_request, **kwargs)

   def delete_relationship_definition(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteRelationshipDefinition: Delete Relationship Definition  # noqa: E501

Delete the definition of the specified relationship.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relationship_definition(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship definition to be deleted. (required)
:type scope: str
:param code: The code of the relationship definition to be deleted. Together with the domain and scope this uniquely              identifies the relationship. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_relationship_definition(scope, code, **kwargs)

   def delete_relationship_definition_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteRelationshipDefinition: Delete Relationship Definition  # noqa: E501

Delete the definition of the specified relationship.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relationship_definition_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship definition to be deleted. (required)
:type scope: str
:param code: The code of the relationship definition to be deleted. Together with the domain and scope this uniquely              identifies the relationship. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_relationship_definition_with_http_info(scope, code, **kwargs)

   def get_relationship_definition(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetRelationshipDefinition: Get relationship definition  # noqa: E501

Retrieve the specified relationship definition  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_relationship_definition(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the specified relationship definition. (required)
:type scope: str
:param code: The code of the specified relationship definition. Together with the domain and scope this uniquely              identifies the relationship definition. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the relationship definition. Defaults to return              the latest version of the definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: RelationshipDefinition"""
        return self.__client.get_relationship_definition(scope, code, **kwargs)

   def get_relationship_definition_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetRelationshipDefinition: Get relationship definition  # noqa: E501

Retrieve the specified relationship definition  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_relationship_definition_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the specified relationship definition. (required)
:type scope: str
:param code: The code of the specified relationship definition. Together with the domain and scope this uniquely              identifies the relationship definition. (required)
:type code: str
:param as_at: The asAt datetime at which to retrieve the relationship definition. Defaults to return              the latest version of the definition if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (RelationshipDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_relationship_definition_with_http_info(scope, code, **kwargs)

   def list_relationship_definitions(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListRelationshipDefinitions: List relationship definitions  # noqa: E501

Retrieve one or more specified relationship definitions.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_relationship_definitions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the relationship definitions. Defaults to return              the latest version of each definition if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing relationship definitions from a previous call to list relationship definitions. This  value is returned from the previous call. If a pagination token is provided the filter, sortBy and asAt field  must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set.              For example, to filter on the Scope, use "scope eq 'ExampleScope'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfRelationshipDefinition"""
        return self.__client.list_relationship_definitions(**kwargs)

   def list_relationship_definitions_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListRelationshipDefinitions: List relationship definitions  # noqa: E501

Retrieve one or more specified relationship definitions.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_relationship_definitions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the relationship definitions. Defaults to return              the latest version of each definition if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing relationship definitions from a previous call to list relationship definitions. This  value is returned from the previous call. If a pagination token is provided the filter, sortBy and asAt field  must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the result set.              For example, to filter on the Scope, use "scope eq 'ExampleScope'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: A list of field names to sort by, each suffixed by " ASC" or " DESC"
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfRelationshipDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_relationship_definitions_with_http_info(**kwargs)

   def update_relationship_definition(self, scope: Any, code: Any, update_relationship_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateRelationshipDefinition: Update Relationship Definition  # noqa: E501

Update the definition of a specified existing relationship. Not all elements within a relationship definition  are modifiable due to the potential implications for values already stored against the relationship.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_relationship_definition(scope, code, update_relationship_definition_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship definition being updated. (required)
:type scope: str
:param code: The code of the relationship definition being updated. Together with the scope this uniquely              identifies the relationship definition. (required)
:type code: str
:param update_relationship_definition_request: The details of relationship definition to update. (required)
:type update_relationship_definition_request: UpdateRelationshipDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: RelationshipDefinition"""
        return self.__client.update_relationship_definition(scope, code, update_relationship_definition_request, **kwargs)

   def update_relationship_definition_with_http_info(self, scope: Any, code: Any, update_relationship_definition_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpdateRelationshipDefinition: Update Relationship Definition  # noqa: E501

Update the definition of a specified existing relationship. Not all elements within a relationship definition  are modifiable due to the potential implications for values already stored against the relationship.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_relationship_definition_with_http_info(scope, code, update_relationship_definition_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship definition being updated. (required)
:type scope: str
:param code: The code of the relationship definition being updated. Together with the scope this uniquely              identifies the relationship definition. (required)
:type code: str
:param update_relationship_definition_request: The details of relationship definition to update. (required)
:type update_relationship_definition_request: UpdateRelationshipDefinitionRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (RelationshipDefinition, int, HTTPHeaderDict)"""
        return self.__client.update_relationship_definition_with_http_info(scope, code, update_relationship_definition_request, **kwargs)

relationship_definitions_api = __RelationshipDefinitionsApiAuthedAndStubbed()

class __RelationshipsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.RelationshipsApi)

   def create_relationship(self, scope: Any, code: Any, create_relationship_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateRelationship: Create Relationship  # noqa: E501

Create a relationship between two entity objects by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relationship(scope, code, create_relationship_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship (required)
:type scope: str
:param code: The code of the relationship (required)
:type code: str
:param create_relationship_request: The details of the relationship to create. (required)
:type create_relationship_request: CreateRelationshipRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CompleteRelationship"""
        return self.__client.create_relationship(scope, code, create_relationship_request, **kwargs)

   def create_relationship_with_http_info(self, scope: Any, code: Any, create_relationship_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateRelationship: Create Relationship  # noqa: E501

Create a relationship between two entity objects by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_relationship_with_http_info(scope, code, create_relationship_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship (required)
:type scope: str
:param code: The code of the relationship (required)
:type code: str
:param create_relationship_request: The details of the relationship to create. (required)
:type create_relationship_request: CreateRelationshipRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CompleteRelationship, int, HTTPHeaderDict)"""
        return self.__client.create_relationship_with_http_info(scope, code, create_relationship_request, **kwargs)

   def delete_relationship(self, scope: Any, code: Any, delete_relationship_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteRelationship: Delete Relationship  # noqa: E501

Delete a relationship between two entity objects represented by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relationship(scope, code, delete_relationship_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship (required)
:type scope: str
:param code: The code of the relationship (required)
:type code: str
:param delete_relationship_request: The details of the relationship to delete. (required)
:type delete_relationship_request: DeleteRelationshipRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_relationship(scope, code, delete_relationship_request, **kwargs)

   def delete_relationship_with_http_info(self, scope: Any, code: Any, delete_relationship_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] DeleteRelationship: Delete Relationship  # noqa: E501

Delete a relationship between two entity objects represented by their identifiers  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_relationship_with_http_info(scope, code, delete_relationship_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the relationship (required)
:type scope: str
:param code: The code of the relationship (required)
:type code: str
:param delete_relationship_request: The details of the relationship to delete. (required)
:type delete_relationship_request: DeleteRelationshipRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_relationship_with_http_info(scope, code, delete_relationship_request, **kwargs)

relationships_api = __RelationshipsApiAuthedAndStubbed()

class __SchemasApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.SchemasApi)

   def get_entity_schema(self, entity: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetEntitySchema: Get schema  # noqa: E501

Gets the schema and meta-data for a given entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_entity_schema(entity, async_req=True)
>>> result = thread.get()

:param entity: The name of a valid entity (required)
:type entity: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Schema"""
        return self.__client.get_entity_schema(entity, **kwargs)

   def get_entity_schema_with_http_info(self, entity: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetEntitySchema: Get schema  # noqa: E501

Gets the schema and meta-data for a given entity  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_entity_schema_with_http_info(entity, async_req=True)
>>> result = thread.get()

:param entity: The name of a valid entity (required)
:type entity: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Schema, int, HTTPHeaderDict)"""
        return self.__client.get_entity_schema_with_http_info(entity, **kwargs)

   def get_property_schema(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPropertySchema: Get property schema  # noqa: E501

Get the schemas for the provided list of property keys.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_property_schema(async_req=True)
>>> result = thread.get()

:param property_keys: One or more property keys for which the schema is requested
:type property_keys: list[str]
:param as_at: Optional. The AsAt date of the data
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PropertySchema"""
        return self.__client.get_property_schema(**kwargs)

   def get_property_schema_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetPropertySchema: Get property schema  # noqa: E501

Get the schemas for the provided list of property keys.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_property_schema_with_http_info(async_req=True)
>>> result = thread.get()

:param property_keys: One or more property keys for which the schema is requested
:type property_keys: list[str]
:param as_at: Optional. The AsAt date of the data
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PropertySchema, int, HTTPHeaderDict)"""
        return self.__client.get_property_schema_with_http_info(**kwargs)

   def get_value_types(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetValueTypes: Get value types  # noqa: E501

Gets the available value types for which a schema is available.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_value_types(async_req=True)
>>> result = thread.get()

:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfValueType"""
        return self.__client.get_value_types(**kwargs)

   def get_value_types_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetValueTypes: Get value types  # noqa: E501

Gets the available value types for which a schema is available.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_value_types_with_http_info(async_req=True)
>>> result = thread.get()

:param sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
:type sort_by: list[str]
:param limit: Optional. When paginating, limit the number of returned results to this many.
:type limit: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfValueType, int, HTTPHeaderDict)"""
        return self.__client.get_value_types_with_http_info(**kwargs)

   def list_entities(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListEntities: List entities  # noqa: E501

List all available entities for which schema information is available.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_entities(async_req=True)
>>> result = thread.get()

:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfString"""
        return self.__client.list_entities(**kwargs)

   def list_entities_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListEntities: List entities  # noqa: E501

List all available entities for which schema information is available.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_entities_with_http_info(async_req=True)
>>> result = thread.get()

:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfString, int, HTTPHeaderDict)"""
        return self.__client.list_entities_with_http_info(**kwargs)

schemas_api = __SchemasApiAuthedAndStubbed()

class __ScopesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ScopesApi)

   def list_entity_scopes(self, entity_type: Any, **kwargs) -> 'Any':
        """ListEntityScopes: List Entity Scopes  # noqa: E501

List all the scopes for a given entity type that contain data.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_entity_scopes(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The entity type to list scopes for. (required)
:type entity_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfScopeDefinition"""
        return self.__client.list_entity_scopes(entity_type, **kwargs)

   def list_entity_scopes_with_http_info(self, entity_type: Any, **kwargs) -> 'Any':
        """ListEntityScopes: List Entity Scopes  # noqa: E501

List all the scopes for a given entity type that contain data.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_entity_scopes_with_http_info(entity_type, async_req=True)
>>> result = thread.get()

:param entity_type: The entity type to list scopes for. (required)
:type entity_type: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfScopeDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_entity_scopes_with_http_info(entity_type, **kwargs)

   def list_scopes(self, **kwargs) -> 'Any':
        """ListScopes: List Scopes  # noqa: E501

List all the scopes that contain data.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_scopes(async_req=True)
>>> result = thread.get()

:param filter: Expression to filter the result set.              For example, to filter on the Scope, use "scope eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfScopeDefinition"""
        return self.__client.list_scopes(**kwargs)

   def list_scopes_with_http_info(self, **kwargs) -> 'Any':
        """ListScopes: List Scopes  # noqa: E501

List all the scopes that contain data.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_scopes_with_http_info(async_req=True)
>>> result = thread.get()

:param filter: Expression to filter the result set.              For example, to filter on the Scope, use "scope eq 'string'"              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfScopeDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_scopes_with_http_info(**kwargs)

scopes_api = __ScopesApiAuthedAndStubbed()

class __ScriptedTranslationApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.ScriptedTranslationApi)

   def get_translation_dialect(self, scope: Any, vendor: Any, source_system: Any, entity_type: Any, serialisation_format: Any, version: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetTranslationDialect: Get a dialect.  # noqa: E501

Get the dialect with the given identifier at the specific asAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_translation_dialect(scope, vendor, source_system, entity_type, serialisation_format, version, async_req=True)
>>> result = thread.get()

:param scope: The scope of the dialect. (required)
:type scope: str
:param vendor: The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE. (required)
:type vendor: str
:param source_system: The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib. (required)
:type source_system: str
:param entity_type: The type of entity this dialect describes e.g. Instrument. (required)
:type entity_type: str
:param serialisation_format: The serialisation format of a document in this dialect. e.g. JSON, XML. (required)
:type serialisation_format: str
:param version: The semantic version of the dialect: MAJOR.MINOR.PATCH. (required)
:type version: str
:param as_at: The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Dialect"""
        return self.__client.get_translation_dialect(scope, vendor, source_system, entity_type, serialisation_format, version, **kwargs)

   def get_translation_dialect_with_http_info(self, scope: Any, vendor: Any, source_system: Any, entity_type: Any, serialisation_format: Any, version: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetTranslationDialect: Get a dialect.  # noqa: E501

Get the dialect with the given identifier at the specific asAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_translation_dialect_with_http_info(scope, vendor, source_system, entity_type, serialisation_format, version, async_req=True)
>>> result = thread.get()

:param scope: The scope of the dialect. (required)
:type scope: str
:param vendor: The vendor of the dialect, the entity that created it. e.g. ISDA, FINBOURNE. (required)
:type vendor: str
:param source_system: The source system of the dialect, the system that understands it. e.g. LUSID, QuantLib. (required)
:type source_system: str
:param entity_type: The type of entity this dialect describes e.g. Instrument. (required)
:type entity_type: str
:param serialisation_format: The serialisation format of a document in this dialect. e.g. JSON, XML. (required)
:type serialisation_format: str
:param version: The semantic version of the dialect: MAJOR.MINOR.PATCH. (required)
:type version: str
:param as_at: The asAt datetime at which to retrieve the dialect. Defaults to return the latest version of the dialect if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Dialect, int, HTTPHeaderDict)"""
        return self.__client.get_translation_dialect_with_http_info(scope, vendor, source_system, entity_type, serialisation_format, version, **kwargs)

   def get_translation_script(self, scope: Any, code: Any, version: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier.  # noqa: E501

Retrieves a translation script to be used for translating financial entities.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_translation_script(scope, code, version, async_req=True)
>>> result = thread.get()

:param scope: Scope of the translation script. (required)
:type scope: str
:param code: Code of the translation script. (required)
:type code: str
:param version: Semantic version of the translation script. (required)
:type version: str
:param as_at: The asAt datetime at which to retrieve the translation script. Defaults to latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TranslationScript"""
        return self.__client.get_translation_script(scope, code, version, **kwargs)

   def get_translation_script_with_http_info(self, scope: Any, code: Any, version: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetTranslationScript: Retrieve a translation script by its identifier.  # noqa: E501

Retrieves a translation script to be used for translating financial entities.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_translation_script_with_http_info(scope, code, version, async_req=True)
>>> result = thread.get()

:param scope: Scope of the translation script. (required)
:type scope: str
:param code: Code of the translation script. (required)
:type code: str
:param version: Semantic version of the translation script. (required)
:type version: str
:param as_at: The asAt datetime at which to retrieve the translation script. Defaults to latest.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TranslationScript, int, HTTPHeaderDict)"""
        return self.__client.get_translation_script_with_http_info(scope, code, version, **kwargs)

   def list_dialect_ids(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter.  # noqa: E501

List the stored dialects' identifiers with pagination and filtering at the specified asAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_dialect_ids(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfDialectId"""
        return self.__client.list_dialect_ids(**kwargs)

   def list_dialect_ids_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListDialectIds: List dialect identifiers matching an optional filter.  # noqa: E501

List the stored dialects' identifiers with pagination and filtering at the specified asAt time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_dialect_ids_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the dialects.              Defaults to return the latest version of the dialect if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing dialect IDs from a previous call to list dialect IDs.              This value is returned from the previous call. If a pagination token is provided the filter and asAt fields              must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:              https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfDialectId, int, HTTPHeaderDict)"""
        return self.__client.list_dialect_ids_with_http_info(**kwargs)

   def list_translation_script_ids(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers.  # noqa: E501

List translation script ids.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_translation_script_ids(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the script identifiers. Defaults to latest.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq 'my-scripts' to list result only for a particular scope.
:type filter: str
:param page: The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfTranslationScriptId"""
        return self.__client.list_translation_script_ids(**kwargs)

   def list_translation_script_ids_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListTranslationScriptIds: List translation script identifiers.  # noqa: E501

List translation script ids.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_translation_script_ids_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the script identifiers. Defaults to latest.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results. For example, Id.Version.Major eq 1 to list IDs with major version 1              or Id.Scope eq 'my-scripts' to list result only for a particular scope.
:type filter: str
:param page: The pagination token to use to continue listing translation script IDs; this              value is returned from the previous call. If a pagination token is provided, the filter field              must not have changed since the original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfTranslationScriptId, int, HTTPHeaderDict)"""
        return self.__client.list_translation_script_ids_with_http_info(**kwargs)

   def translate_entities(self, translate_entities_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script.  # noqa: E501

Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_entities(translate_entities_request, async_req=True)
>>> result = thread.get()

:param translate_entities_request: The entities to translate, along with identifiers for the script and (optional) dialect to use. (required)
:type translate_entities_request: TranslateEntitiesRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TranslateEntitiesResponse"""
        return self.__client.translate_entities(translate_entities_request, **kwargs)

   def translate_entities_inlined(self, translate_entities_inlined_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script.  # noqa: E501

Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_entities_inlined(translate_entities_inlined_request, async_req=True)
>>> result = thread.get()

:param translate_entities_inlined_request: The entities to translate, along with the script to use and an optional schema for validation. (required)
:type translate_entities_inlined_request: TranslateEntitiesInlinedRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TranslateEntitiesResponse"""
        return self.__client.translate_entities_inlined(translate_entities_inlined_request, **kwargs)

   def translate_entities_inlined_with_http_info(self, translate_entities_inlined_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] TranslateEntitiesInlined: Translate a collection of entities, inlining the body of the translation script.  # noqa: E501

Run the provided translation request. The entities to translate, script to use and dialect to validate results against  are all specified in the request body. The entities are given as a dictionary with (ephemeral) unique correlation IDs.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_entities_inlined_with_http_info(translate_entities_inlined_request, async_req=True)
>>> result = thread.get()

:param translate_entities_inlined_request: The entities to translate, along with the script to use and an optional schema for validation. (required)
:type translate_entities_inlined_request: TranslateEntitiesInlinedRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TranslateEntitiesResponse, int, HTTPHeaderDict)"""
        return self.__client.translate_entities_inlined_with_http_info(translate_entities_inlined_request, **kwargs)

   def translate_entities_with_http_info(self, translate_entities_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] TranslateEntities: Translate a collection of entities with a specified translation script.  # noqa: E501

Run the provided translation request. The entities to translate are specified in the request body as a  dictionary with (ephemeral) unique correlation IDs. The script to use and optional dialect to validate  results against are sourced from the database.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_entities_with_http_info(translate_entities_request, async_req=True)
>>> result = thread.get()

:param translate_entities_request: The entities to translate, along with identifiers for the script and (optional) dialect to use. (required)
:type translate_entities_request: TranslateEntitiesRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TranslateEntitiesResponse, int, HTTPHeaderDict)"""
        return self.__client.translate_entities_with_http_info(translate_entities_request, **kwargs)

   def upsert_translation_dialect(self, upsert_dialect_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect.  # noqa: E501

Upsert the given dialect.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_translation_dialect(upsert_dialect_request, async_req=True)
>>> result = thread.get()

:param upsert_dialect_request: The dialect to upsert. (required)
:type upsert_dialect_request: UpsertDialectRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Dialect"""
        return self.__client.upsert_translation_dialect(upsert_dialect_request, **kwargs)

   def upsert_translation_dialect_with_http_info(self, upsert_dialect_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertTranslationDialect: Upsert a Dialect.  # noqa: E501

Upsert the given dialect.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_translation_dialect_with_http_info(upsert_dialect_request, async_req=True)
>>> result = thread.get()

:param upsert_dialect_request: The dialect to upsert. (required)
:type upsert_dialect_request: UpsertDialectRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Dialect, int, HTTPHeaderDict)"""
        return self.__client.upsert_translation_dialect_with_http_info(upsert_dialect_request, **kwargs)

   def upsert_translation_script(self, upsert_translation_script_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertTranslationScript: Upsert a translation script.  # noqa: E501

Upserts a translation script to be used for translating financial entities.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_translation_script(upsert_translation_script_request, async_req=True)
>>> result = thread.get()

:param upsert_translation_script_request: The translation script to be upserted. (required)
:type upsert_translation_script_request: UpsertTranslationScriptRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TranslationScript"""
        return self.__client.upsert_translation_script(upsert_translation_script_request, **kwargs)

   def upsert_translation_script_with_http_info(self, upsert_translation_script_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] UpsertTranslationScript: Upsert a translation script.  # noqa: E501

Upserts a translation script to be used for translating financial entities.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_translation_script_with_http_info(upsert_translation_script_request, async_req=True)
>>> result = thread.get()

:param upsert_translation_script_request: The translation script to be upserted. (required)
:type upsert_translation_script_request: UpsertTranslationScriptRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TranslationScript, int, HTTPHeaderDict)"""
        return self.__client.upsert_translation_script_with_http_info(upsert_translation_script_request, **kwargs)

scripted_translation_api = __ScriptedTranslationApiAuthedAndStubbed()

class __SearchApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.SearchApi)

   def instruments_search(self, instrument_search_property: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] InstrumentsSearch: Instruments search  # noqa: E501

Search across all instruments that have been mastered in LUSID. Optionally augment the results with instruments from an external symbology service,  currently OpenFIGI.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.instruments_search(instrument_search_property, async_req=True)
>>> result = thread.get()

:param instrument_search_property: A collection of instrument properties to search for. LUSID will return instruments for any matched              properties. (required)
:type instrument_search_property: list[InstrumentSearchProperty]
:param mastered_effective_at: The effective datetime or cut label to use when searching mastered instruments. This parameter has no effect on instruments that  have not been mastered within LUSID. Defaults to the current LUSID system datetime if not specified.
:type mastered_effective_at: str
:param mastered_only: If set to true, only search over instruments that have been mastered within LUSID. Defaults to false.
:type mastered_only: bool
:param scope: The scope in which the instrument lies.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: list[InstrumentMatch]"""
        return self.__client.instruments_search(instrument_search_property, **kwargs)

   def instruments_search_with_http_info(self, instrument_search_property: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] InstrumentsSearch: Instruments search  # noqa: E501

Search across all instruments that have been mastered in LUSID. Optionally augment the results with instruments from an external symbology service,  currently OpenFIGI.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.instruments_search_with_http_info(instrument_search_property, async_req=True)
>>> result = thread.get()

:param instrument_search_property: A collection of instrument properties to search for. LUSID will return instruments for any matched              properties. (required)
:type instrument_search_property: list[InstrumentSearchProperty]
:param mastered_effective_at: The effective datetime or cut label to use when searching mastered instruments. This parameter has no effect on instruments that  have not been mastered within LUSID. Defaults to the current LUSID system datetime if not specified.
:type mastered_effective_at: str
:param mastered_only: If set to true, only search over instruments that have been mastered within LUSID. Defaults to false.
:type mastered_only: bool
:param scope: The scope in which the instrument lies.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (list[InstrumentMatch], int, HTTPHeaderDict)"""
        return self.__client.instruments_search_with_http_info(instrument_search_property, **kwargs)

   def search_portfolio_groups(self, **kwargs) -> 'Any':
        """SearchPortfolioGroups: Search Portfolio Groups  # noqa: E501

Search through all portfolio groups  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.search_portfolio_groups(async_req=True)
>>> result = thread.get()

:param search: A parameter used for searching any portfolio group field. Wildcards(*) are supported at the end of words (e.g. 'Port*'). Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type search: str
:param filter: Expression to filter the result set.   For example, to filter on the Scope, use "id.scope eq 'string'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName. Multiple fields can be denoted by a comma e.g. -MyFieldName,AnotherFieldName,-AFurtherFieldName
:type sort_by: str
:param limit: When paginating, only return this number of records
:type limit: int
:param page: Encoded page string returned from a previous search result that will retrieve the next page of data. When this field is supplied, filter, sortBy and search fields should not be supplied.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPortfolioGroupSearchResult"""
        return self.__client.search_portfolio_groups(**kwargs)

   def search_portfolio_groups_with_http_info(self, **kwargs) -> 'Any':
        """SearchPortfolioGroups: Search Portfolio Groups  # noqa: E501

Search through all portfolio groups  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.search_portfolio_groups_with_http_info(async_req=True)
>>> result = thread.get()

:param search: A parameter used for searching any portfolio group field. Wildcards(*) are supported at the end of words (e.g. 'Port*'). Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type search: str
:param filter: Expression to filter the result set.   For example, to filter on the Scope, use "id.scope eq 'string'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName. Multiple fields can be denoted by a comma e.g. -MyFieldName,AnotherFieldName,-AFurtherFieldName
:type sort_by: str
:param limit: When paginating, only return this number of records
:type limit: int
:param page: Encoded page string returned from a previous search result that will retrieve the next page of data. When this field is supplied, filter, sortBy and search fields should not be supplied.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPortfolioGroupSearchResult, int, HTTPHeaderDict)"""
        return self.__client.search_portfolio_groups_with_http_info(**kwargs)

   def search_portfolios(self, **kwargs) -> 'Any':
        """SearchPortfolios: Search Portfolios  # noqa: E501

Search through all portfolios  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.search_portfolios(async_req=True)
>>> result = thread.get()

:param search: A parameter used for searching any portfolio field. Wildcards(*) are supported at the end of words (e.g. 'Port*'). Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type search: str
:param filter: Expression to filter the result set.   For example, to filter on the portfolio Type, use "type eq 'Transaction'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName. Multiple fields can be denoted by a comma e.g. -MyFieldName,AnotherFieldName,-AFurtherFieldName
:type sort_by: str
:param limit: When paginating, only return this number of records
:type limit: int
:param page: Encoded page string returned from a previous search result that will retrieve the next page of data. When this field is supplied, filter, sortBy and search fields should not be supplied.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPortfolioSearchResult"""
        return self.__client.search_portfolios(**kwargs)

   def search_portfolios_with_http_info(self, **kwargs) -> 'Any':
        """SearchPortfolios: Search Portfolios  # noqa: E501

Search through all portfolios  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.search_portfolios_with_http_info(async_req=True)
>>> result = thread.get()

:param search: A parameter used for searching any portfolio field. Wildcards(*) are supported at the end of words (e.g. 'Port*'). Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type search: str
:param filter: Expression to filter the result set.   For example, to filter on the portfolio Type, use "type eq 'Transaction'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName. Multiple fields can be denoted by a comma e.g. -MyFieldName,AnotherFieldName,-AFurtherFieldName
:type sort_by: str
:param limit: When paginating, only return this number of records
:type limit: int
:param page: Encoded page string returned from a previous search result that will retrieve the next page of data. When this field is supplied, filter, sortBy and search fields should not be supplied.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPortfolioSearchResult, int, HTTPHeaderDict)"""
        return self.__client.search_portfolios_with_http_info(**kwargs)

   def search_properties(self, **kwargs) -> 'Any':
        """SearchProperties: Search Property Definitions  # noqa: E501

Search through all Property Definitions  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.search_properties(async_req=True)
>>> result = thread.get()

:param search: A parameter used for searching any field. Wildcards(*) are supported at the end of words (e.g. 'Port*'). Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type search: str
:param filter: Expression to filter the result set.   For example, to filter on the Value Type, use "valueType eq 'string'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName. Multiple fields can be denoted by a comma e.g. -MyFieldName,AnotherFieldName,-AFurtherFieldName
:type sort_by: str
:param limit: When paginating, only return this number of records
:type limit: int
:param page: Encoded page string returned from a previous search result that will retrieve the next page of data. When this field is supplied, filter, sortBy and search fields should not be supplied.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfPropertyDefinitionSearchResult"""
        return self.__client.search_properties(**kwargs)

   def search_properties_with_http_info(self, **kwargs) -> 'Any':
        """SearchProperties: Search Property Definitions  # noqa: E501

Search through all Property Definitions  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.search_properties_with_http_info(async_req=True)
>>> result = thread.get()

:param search: A parameter used for searching any field. Wildcards(*) are supported at the end of words (e.g. 'Port*'). Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type search: str
:param filter: Expression to filter the result set.   For example, to filter on the Value Type, use "valueType eq 'string'"  Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param sort_by: Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName. Multiple fields can be denoted by a comma e.g. -MyFieldName,AnotherFieldName,-AFurtherFieldName
:type sort_by: str
:param limit: When paginating, only return this number of records
:type limit: int
:param page: Encoded page string returned from a previous search result that will retrieve the next page of data. When this field is supplied, filter, sortBy and search fields should not be supplied.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfPropertyDefinitionSearchResult, int, HTTPHeaderDict)"""
        return self.__client.search_properties_with_http_info(**kwargs)

search_api = __SearchApiAuthedAndStubbed()

class __SequencesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.SequencesApi)

   def create_sequence(self, scope: Any, create_sequence_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateSequence: Create a new sequence  # noqa: E501

Create a new sequence  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_sequence(scope, create_sequence_request, async_req=True)
>>> result = thread.get()

:param scope: Scope of the sequence. (required)
:type scope: str
:param create_sequence_request: Request to create sequence (required)
:type create_sequence_request: CreateSequenceRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: SequenceDefinition"""
        return self.__client.create_sequence(scope, create_sequence_request, **kwargs)

   def create_sequence_with_http_info(self, scope: Any, create_sequence_request: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateSequence: Create a new sequence  # noqa: E501

Create a new sequence  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_sequence_with_http_info(scope, create_sequence_request, async_req=True)
>>> result = thread.get()

:param scope: Scope of the sequence. (required)
:type scope: str
:param create_sequence_request: Request to create sequence (required)
:type create_sequence_request: CreateSequenceRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (SequenceDefinition, int, HTTPHeaderDict)"""
        return self.__client.create_sequence_with_http_info(scope, create_sequence_request, **kwargs)

   def get_sequence(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetSequence: Get a specified sequence  # noqa: E501

Return the details of a specified sequence  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_sequence(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the sequence. (required)
:type scope: str
:param code: Code of the sequence. This together with stated scope uniquely              identifies the sequence. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: SequenceDefinition"""
        return self.__client.get_sequence(scope, code, **kwargs)

   def get_sequence_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetSequence: Get a specified sequence  # noqa: E501

Return the details of a specified sequence  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_sequence_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the sequence. (required)
:type scope: str
:param code: Code of the sequence. This together with stated scope uniquely              identifies the sequence. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (SequenceDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_sequence_with_http_info(scope, code, **kwargs)

   def list_sequences(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListSequences: List Sequences  # noqa: E501

List sequences which satisfies filtering criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_sequences(async_req=True)
>>> result = thread.get()

:param page: The pagination token to use to continue listing sequences from a previous call to list sequences. This  value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 500 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfSequenceDefinition"""
        return self.__client.list_sequences(**kwargs)

   def list_sequences_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListSequences: List Sequences  # noqa: E501

List sequences which satisfies filtering criteria.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_sequences_with_http_info(async_req=True)
>>> result = thread.get()

:param page: The pagination token to use to continue listing sequences from a previous call to list sequences. This  value is returned from the previous call.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 500 if not specified.
:type limit: int
:param filter: Expression to filter the result set.               Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfSequenceDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_sequences_with_http_info(**kwargs)

   def next(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] Next: Get next values from sequence  # noqa: E501

Get the next set of values from a specified sequence  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.next(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the sequence. (required)
:type scope: str
:param code: Code of the sequence. This together with stated scope uniquely              identifies the sequence. (required)
:type code: str
:param batch: Number of sequences items to return for the specified sequence. Default to 1 if not specified.
:type batch: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: NextValueInSequenceResponse"""
        return self.__client.next(scope, code, **kwargs)

   def next_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] Next: Get next values from sequence  # noqa: E501

Get the next set of values from a specified sequence  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.next_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: Scope of the sequence. (required)
:type scope: str
:param code: Code of the sequence. This together with stated scope uniquely              identifies the sequence. (required)
:type code: str
:param batch: Number of sequences items to return for the specified sequence. Default to 1 if not specified.
:type batch: int
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (NextValueInSequenceResponse, int, HTTPHeaderDict)"""
        return self.__client.next_with_http_info(scope, code, **kwargs)

sequences_api = __SequencesApiAuthedAndStubbed()

class __StructuredResultDataApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.StructuredResultDataApi)

   def create_data_map(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateDataMap: Create data map  # noqa: E501

Create or update one or more structured result store address definition data maps in a particular scope. Note these are immutable and cannot be changed once created.                In the request, each data map must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data map object in the response.                The response returns both the collection of successfully created or updated data maps, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_data_map(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create or update data maps. (required)
:type scope: str
:param request_body: Individual data map creation requests. (required)
:type request_body: dict(str, CreateDataMapRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertStructuredDataResponse"""
        return self.__client.create_data_map(scope, request_body, **kwargs)

   def create_data_map_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateDataMap: Create data map  # noqa: E501

Create or update one or more structured result store address definition data maps in a particular scope. Note these are immutable and cannot be changed once created.                In the request, each data map must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data map object in the response.                The response returns both the collection of successfully created or updated data maps, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_data_map_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create or update data maps. (required)
:type scope: str
:param request_body: Individual data map creation requests. (required)
:type request_body: dict(str, CreateDataMapRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.create_data_map_with_http_info(scope, request_body, **kwargs)

   def delete_structured_result_data(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteStructuredResultData: Delete structured result data  # noqa: E501

Delete one or more structured result data items from a particular scope. Each item is identified by a unique ID which includes  information about its type as well as the exact effective datetime (to the microsecond) at which it entered the system (became valid).                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns both the collection of successfully deleted data items, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_structured_result_data(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope from which to delete data items. (required)
:type scope: str
:param request_body: The data IDs to delete, each keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, StructuredResultDataId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AnnulStructuredDataResponse"""
        return self.__client.delete_structured_result_data(scope, request_body, **kwargs)

   def delete_structured_result_data_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteStructuredResultData: Delete structured result data  # noqa: E501

Delete one or more structured result data items from a particular scope. Each item is identified by a unique ID which includes  information about its type as well as the exact effective datetime (to the microsecond) at which it entered the system (became valid).                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns both the collection of successfully deleted data items, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_structured_result_data_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope from which to delete data items. (required)
:type scope: str
:param request_body: The data IDs to delete, each keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, StructuredResultDataId)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AnnulStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_structured_result_data_with_http_info(scope, request_body, **kwargs)

   def get_address_key_definitions_for_document(self, scope: Any, code: Any, source: Any, result_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAddressKeyDefinitionsForDocument: Get AddressKeyDefinitions for a virtual document.  # noqa: E501

For a given virtual document retrieve all the address key definitions that are in use.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_address_key_definitions_for_document(scope, code, source, result_type, async_req=True)
>>> result = thread.get()

:param scope: The scope of the document for which address key definitions are retrieved. (required)
:type scope: str
:param code: The code of the document for which address key definitions are retrieved. (required)
:type code: str
:param source: The source of the document for which address key definitions are retrieved. (required)
:type source: str
:param result_type: The result type of the document for which address key definitions are retrieved. (required)
:type result_type: str
:param effective_at: The effective datetime to query the document for which the address key definitions are retrieved.              Defaults to querying the latest version if not specified.
:type effective_at: str
:param as_at: The asAt datetime to query the document for which the address key definitions are retrieved.              Defaults to querying the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfAddressKeyDefinition"""
        return self.__client.get_address_key_definitions_for_document(scope, code, source, result_type, **kwargs)

   def get_address_key_definitions_for_document_with_http_info(self, scope: Any, code: Any, source: Any, result_type: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetAddressKeyDefinitionsForDocument: Get AddressKeyDefinitions for a virtual document.  # noqa: E501

For a given virtual document retrieve all the address key definitions that are in use.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_address_key_definitions_for_document_with_http_info(scope, code, source, result_type, async_req=True)
>>> result = thread.get()

:param scope: The scope of the document for which address key definitions are retrieved. (required)
:type scope: str
:param code: The code of the document for which address key definitions are retrieved. (required)
:type code: str
:param source: The source of the document for which address key definitions are retrieved. (required)
:type source: str
:param result_type: The result type of the document for which address key definitions are retrieved. (required)
:type result_type: str
:param effective_at: The effective datetime to query the document for which the address key definitions are retrieved.              Defaults to querying the latest version if not specified.
:type effective_at: str
:param as_at: The asAt datetime to query the document for which the address key definitions are retrieved.              Defaults to querying the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfAddressKeyDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_address_key_definitions_for_document_with_http_info(scope, code, source, result_type, **kwargs)

   def get_data_map(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetDataMap: Get data map  # noqa: E501

Retrieve one or more structured result store address definition data maps from a particular scope.                Each data map can be identified by its invariant key, which can be thought of as a permanent URL.  For each ID, LUSID returns the most recently matched item.                In the request, each data map must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data map in the response.                The response returns three collections. The first contains successfully retrieved data maps. The second contains those with a  valid identifier but that could not be found. The third contains those that failed because LUSID could not construct a valid identifier from the request.                For the IDs that failed to resolve or could not be found, a reason is provided.                It is important to check the failed sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_data_map(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope from which to retrieve data maps. (required)
:type scope: str
:param request_body: The data map keys to look up, each keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, DataMapKey)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetDataMapResponse"""
        return self.__client.get_data_map(scope, request_body, **kwargs)

   def get_data_map_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetDataMap: Get data map  # noqa: E501

Retrieve one or more structured result store address definition data maps from a particular scope.                Each data map can be identified by its invariant key, which can be thought of as a permanent URL.  For each ID, LUSID returns the most recently matched item.                In the request, each data map must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data map in the response.                The response returns three collections. The first contains successfully retrieved data maps. The second contains those with a  valid identifier but that could not be found. The third contains those that failed because LUSID could not construct a valid identifier from the request.                For the IDs that failed to resolve or could not be found, a reason is provided.                It is important to check the failed sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_data_map_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope from which to retrieve data maps. (required)
:type scope: str
:param request_body: The data map keys to look up, each keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, DataMapKey)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetDataMapResponse, int, HTTPHeaderDict)"""
        return self.__client.get_data_map_with_http_info(scope, request_body, **kwargs)

   def get_structured_result_data(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetStructuredResultData: Get structured result data  # noqa: E501

Retrieve one or more structured result data items from a particular scope.                Each item can be identified by its time invariant structured result data identifier. For each ID, LUSID  returns the most recently matched item with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified to control how far back to look from the specified  effective datetime. LUSID returns the most recent item within this window.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.    The response returns three collections. The first contains successfully retrieved data items. The second contains those with a  valid identifier but that could not be found. The third contains those that failed because LUSID could not construct a valid identifier from the request.    For the IDs that failed to resolve or could not be found, a reason is provided.                It is important to check the failed sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_structured_result_data(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope from which to retrieve data items. (required)
:type scope: str
:param request_body: The time invariant set of structured data identifiers to retrieve, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, StructuredResultDataId)
:param as_at: The asAt datetime at which to retrieve the structured result data. Defaults to returning the latest version if not specified.
:type as_at: datetime
:param max_age: The duration of the look-back window in ISO8601 time interval format, for example 'P1Y2M3DT4H30M' (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime to generate a effective datetime window inside which a data item must exist to be retrieved.
:type max_age: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetStructuredResultDataResponse"""
        return self.__client.get_structured_result_data(scope, request_body, **kwargs)

   def get_structured_result_data_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetStructuredResultData: Get structured result data  # noqa: E501

Retrieve one or more structured result data items from a particular scope.                Each item can be identified by its time invariant structured result data identifier. For each ID, LUSID  returns the most recently matched item with respect to the provided (or default) effective datetime.                 An optional maximum age range window can be specified to control how far back to look from the specified  effective datetime. LUSID returns the most recent item within this window.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.    The response returns three collections. The first contains successfully retrieved data items. The second contains those with a  valid identifier but that could not be found. The third contains those that failed because LUSID could not construct a valid identifier from the request.    For the IDs that failed to resolve or could not be found, a reason is provided.                It is important to check the failed sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_structured_result_data_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope from which to retrieve data items. (required)
:type scope: str
:param request_body: The time invariant set of structured data identifiers to retrieve, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, StructuredResultDataId)
:param as_at: The asAt datetime at which to retrieve the structured result data. Defaults to returning the latest version if not specified.
:type as_at: datetime
:param max_age: The duration of the look-back window in ISO8601 time interval format, for example 'P1Y2M3DT4H30M' (1 year, 2 months, 3 days, 4 hours and 30 minutes).               This is subtracted from the provided effectiveAt datetime to generate a effective datetime window inside which a data item must exist to be retrieved.
:type max_age: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetStructuredResultDataResponse, int, HTTPHeaderDict)"""
        return self.__client.get_structured_result_data_with_http_info(scope, request_body, **kwargs)

   def get_virtual_document(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetVirtualDocument: Get Virtual Documents  # noqa: E501

Retrieve one or more virtual documents from a particular scope.                Each item can be identified by its time invariant structured result data identifier. For each ID, LUSID  returns the most recently matched item with respect to the provided effective datetime.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns two collections. The first contains successfully retrieved data items. The second contains those with a  valid identifier but that could not be found, or those that failed because LUSID could not construct a valid identifier from the request.                For the IDs that failed to resolve or could not be found, a reason is provided.                It is important to check the failed sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_virtual_document(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to construct the virtual documents. (required)
:type scope: str
:param request_body: The time invariant set of structured data identifiers to retrieve, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, StructuredResultDataId)
:param as_at: The asAt datetime at which to retrieve the structured result data. Defaults to returning the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: GetVirtualDocumentResponse"""
        return self.__client.get_virtual_document(scope, request_body, **kwargs)

   def get_virtual_document_rows(self, scope: Any, code: Any, source: Any, result_type: Any, effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetVirtualDocumentRows: Get Virtual Document Rows  # noqa: E501

Retrieve the rows of the virtual document with the specified identifiers and the given effectiveAt date time.    Get virtual document rows merges multiple StructuredResultData items upserted with UpsertStructuredResultData  for a single StructuredResultDataId.                Since an item of StructuredResultData is always upserted with a StructuredResultDataId, of which  effectiveAt is a part, then merging across the asAt dimension is supported but not merging across the  effectiveAt dimension.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_virtual_document_rows(scope, code, source, result_type, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to retrieve the virtual document. (required)
:type scope: str
:param code: The code of the virtual document to retrieve. (required)
:type code: str
:param source: The source of the virtual document to retrieve. (required)
:type source: str
:param result_type: The result type of the virtual document to retrieve. (required)
:type result_type: str
:param effective_at: The effectiveAt datetime at which to retrieve the virtual document. (required)
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the virtual document. Defaults to returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing virtual document rows from a previous               call to list virtual document rows. This value is returned from the previous call. If a pagination token is               provided the filter, effectiveAt, and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:               https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfVirtualRow"""
        return self.__client.get_virtual_document_rows(scope, code, source, result_type, effective_at, **kwargs)

   def get_virtual_document_rows_with_http_info(self, scope: Any, code: Any, source: Any, result_type: Any, effective_at: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetVirtualDocumentRows: Get Virtual Document Rows  # noqa: E501

Retrieve the rows of the virtual document with the specified identifiers and the given effectiveAt date time.    Get virtual document rows merges multiple StructuredResultData items upserted with UpsertStructuredResultData  for a single StructuredResultDataId.                Since an item of StructuredResultData is always upserted with a StructuredResultDataId, of which  effectiveAt is a part, then merging across the asAt dimension is supported but not merging across the  effectiveAt dimension.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_virtual_document_rows_with_http_info(scope, code, source, result_type, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to retrieve the virtual document. (required)
:type scope: str
:param code: The code of the virtual document to retrieve. (required)
:type code: str
:param source: The source of the virtual document to retrieve. (required)
:type source: str
:param result_type: The result type of the virtual document to retrieve. (required)
:type result_type: str
:param effective_at: The effectiveAt datetime at which to retrieve the virtual document. (required)
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the virtual document. Defaults to returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing virtual document rows from a previous               call to list virtual document rows. This value is returned from the previous call. If a pagination token is               provided the filter, effectiveAt, and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the number of returned results to this many.
:type limit: int
:param filter: Expression to filter the result set. Read more about filtering results from LUSID here:               https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfVirtualRow, int, HTTPHeaderDict)"""
        return self.__client.get_virtual_document_rows_with_http_info(scope, code, source, result_type, effective_at, **kwargs)

   def get_virtual_document_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetVirtualDocument: Get Virtual Documents  # noqa: E501

Retrieve one or more virtual documents from a particular scope.                Each item can be identified by its time invariant structured result data identifier. For each ID, LUSID  returns the most recently matched item with respect to the provided effective datetime.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns two collections. The first contains successfully retrieved data items. The second contains those with a  valid identifier but that could not be found, or those that failed because LUSID could not construct a valid identifier from the request.                For the IDs that failed to resolve or could not be found, a reason is provided.                It is important to check the failed sets for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_virtual_document_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to construct the virtual documents. (required)
:type scope: str
:param request_body: The time invariant set of structured data identifiers to retrieve, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, StructuredResultDataId)
:param as_at: The asAt datetime at which to retrieve the structured result data. Defaults to returning the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (GetVirtualDocumentResponse, int, HTTPHeaderDict)"""
        return self.__client.get_virtual_document_with_http_info(scope, request_body, **kwargs)

   def upsert_result_value(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertResultValue: Upsert result value  # noqa: E501

Create or update one or more Upsert one or more result values in a particular scope. An item is updated if it already exists  and created if it does not.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns both the collection of successfully created or updated data items, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_result_value(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to construct the virtual documents. (required)
:type scope: str
:param request_body: The time invariant set of structured data identifiers to retrieve, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, UpsertResultValuesDataRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertStructuredDataResponse"""
        return self.__client.upsert_result_value(scope, request_body, **kwargs)

   def upsert_result_value_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertResultValue: Upsert result value  # noqa: E501

Create or update one or more Upsert one or more result values in a particular scope. An item is updated if it already exists  and created if it does not.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns both the collection of successfully created or updated data items, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_result_value_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to construct the virtual documents. (required)
:type scope: str
:param request_body: The time invariant set of structured data identifiers to retrieve, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, UpsertResultValuesDataRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_result_value_with_http_info(scope, request_body, **kwargs)

   def upsert_structured_result_data(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[BETA] UpsertStructuredResultData: Upsert structured result data  # noqa: E501

Create or update one or more structured result data items in a particular scope. An item is updated if it already exists  and created if it does not.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns both the collection of successfully created or updated data items, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_structured_result_data(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create or update data items. (required)
:type scope: str
:param request_body: The set of data items to create or update, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, UpsertStructuredResultDataRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertStructuredDataResponse"""
        return self.__client.upsert_structured_result_data(scope, request_body, **kwargs)

   def upsert_structured_result_data_with_http_info(self, scope: Any, request_body: Any, **kwargs) -> 'Any':
        """[BETA] UpsertStructuredResultData: Upsert structured result data  # noqa: E501

Create or update one or more structured result data items in a particular scope. An item is updated if it already exists  and created if it does not.                In the request, each data item must be keyed by a unique correlation ID. This ID is ephemeral and not stored by LUSID.  It serves only to easily identify each data item in the response.                The response returns both the collection of successfully created or updated data items, as well as those that failed.  For each failure, a reason is provided.                It is important to check the failed set for any unsuccessful results.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_structured_result_data_with_http_info(scope, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create or update data items. (required)
:type scope: str
:param request_body: The set of data items to create or update, keyed by a unique, ephemeral correlation ID. (required)
:type request_body: dict(str, UpsertStructuredResultDataRequest)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertStructuredDataResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_structured_result_data_with_http_info(scope, request_body, **kwargs)

structured_result_data_api = __StructuredResultDataApiAuthedAndStubbed()

class __SystemConfigurationApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.SystemConfigurationApi)

   def create_configuration_transaction_type(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateConfigurationTransactionType: Create transaction type  # noqa: E501

Create a new transaction type by specifying a definition and mappings to movements.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_configuration_transaction_type(async_req=True)
>>> result = thread.get()

:param transaction_configuration_data_request: A transaction type definition.
:type transaction_configuration_data_request: TransactionConfigurationDataRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionSetConfigurationData"""
        return self.__client.create_configuration_transaction_type(**kwargs)

   def create_configuration_transaction_type_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateConfigurationTransactionType: Create transaction type  # noqa: E501

Create a new transaction type by specifying a definition and mappings to movements.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_configuration_transaction_type_with_http_info(async_req=True)
>>> result = thread.get()

:param transaction_configuration_data_request: A transaction type definition.
:type transaction_configuration_data_request: TransactionConfigurationDataRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionSetConfigurationData, int, HTTPHeaderDict)"""
        return self.__client.create_configuration_transaction_type_with_http_info(**kwargs)

   def create_side_definition(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateSideDefinition: Create side definition  # noqa: E501

Create a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_side_definition(async_req=True)
>>> result = thread.get()

:param side_configuration_data_request: The definition of the side.
:type side_configuration_data_request: SideConfigurationDataRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionSetConfigurationData"""
        return self.__client.create_side_definition(**kwargs)

   def create_side_definition_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateSideDefinition: Create side definition  # noqa: E501

Create a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_side_definition_with_http_info(async_req=True)
>>> result = thread.get()

:param side_configuration_data_request: The definition of the side.
:type side_configuration_data_request: SideConfigurationDataRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionSetConfigurationData, int, HTTPHeaderDict)"""
        return self.__client.create_side_definition_with_http_info(**kwargs)

   def delete_transaction_configuration_source(self, source: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTransactionConfigurationSource: Delete all transaction configurations for a source  # noqa: E501

/// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_configuration_source(source, async_req=True)
>>> result = thread.get()

:param source: The source to delete transaction configurations for (required)
:type source: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_transaction_configuration_source(source, **kwargs)

   def delete_transaction_configuration_source_with_http_info(self, source: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTransactionConfigurationSource: Delete all transaction configurations for a source  # noqa: E501

/// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_configuration_source_with_http_info(source, async_req=True)
>>> result = thread.get()

:param source: The source to delete transaction configurations for (required)
:type source: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_transaction_configuration_source_with_http_info(source, **kwargs)

   def get_transaction_configuration_source(self, source: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionConfigurationSource: Get all transaction configurations for a source  # noqa: E501

Returns failure if requested source is not found  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_configuration_source(source, async_req=True)
>>> result = thread.get()

:param source: The source for which to retrieve transaction configurations (required)
:type source: str
:param as_at: The asAt datetime at which to retrieve the transaction configurations.              Defaults to returning the latest version of the transaction configurations if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionSetConfigurationData"""
        return self.__client.get_transaction_configuration_source(source, **kwargs)

   def get_transaction_configuration_source_with_http_info(self, source: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionConfigurationSource: Get all transaction configurations for a source  # noqa: E501

Returns failure if requested source is not found  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_configuration_source_with_http_info(source, async_req=True)
>>> result = thread.get()

:param source: The source for which to retrieve transaction configurations (required)
:type source: str
:param as_at: The asAt datetime at which to retrieve the transaction configurations.              Defaults to returning the latest version of the transaction configurations if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionSetConfigurationData, int, HTTPHeaderDict)"""
        return self.__client.get_transaction_configuration_source_with_http_info(source, **kwargs)

   def list_configuration_transaction_types(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListConfigurationTransactionTypes: List transaction types  # noqa: E501

Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_configuration_transaction_types(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionSetConfigurationData"""
        return self.__client.list_configuration_transaction_types(**kwargs)

   def list_configuration_transaction_types_with_http_info(self, **kwargs) -> 'Any':
        """[EARLY ACCESS] ListConfigurationTransactionTypes: List transaction types  # noqa: E501

Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_configuration_transaction_types_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionSetConfigurationData, int, HTTPHeaderDict)"""
        return self.__client.list_configuration_transaction_types_with_http_info(**kwargs)

   def set_configuration_transaction_types(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetConfigurationTransactionTypes: Set transaction types  # noqa: E501

Configure all existing transaction types. Note it is not possible to configure a single existing transaction type on its own.                WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_configuration_transaction_types(async_req=True)
>>> result = thread.get()

:param transaction_set_configuration_data_request: The complete set of transaction type definitions.
:type transaction_set_configuration_data_request: TransactionSetConfigurationDataRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionSetConfigurationData"""
        return self.__client.set_configuration_transaction_types(**kwargs)

   def set_configuration_transaction_types_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetConfigurationTransactionTypes: Set transaction types  # noqa: E501

Configure all existing transaction types. Note it is not possible to configure a single existing transaction type on its own.                WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_configuration_transaction_types_with_http_info(async_req=True)
>>> result = thread.get()

:param transaction_set_configuration_data_request: The complete set of transaction type definitions.
:type transaction_set_configuration_data_request: TransactionSetConfigurationDataRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionSetConfigurationData, int, HTTPHeaderDict)"""
        return self.__client.set_configuration_transaction_types_with_http_info(**kwargs)

   def set_transaction_configuration_source(self, source: Any, set_transaction_configuration_source_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetTransactionConfigurationSource: Set transaction types for a source  # noqa: E501

This will replace all the existing transaction configurations for the given source                WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_transaction_configuration_source(source, set_transaction_configuration_source_request, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction configurations for (required)
:type source: str
:param set_transaction_configuration_source_request: The set of transaction configurations (required)
:type set_transaction_configuration_source_request: list[SetTransactionConfigurationSourceRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionSetConfigurationData"""
        return self.__client.set_transaction_configuration_source(source, set_transaction_configuration_source_request, **kwargs)

   def set_transaction_configuration_source_with_http_info(self, source: Any, set_transaction_configuration_source_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] SetTransactionConfigurationSource: Set transaction types for a source  # noqa: E501

This will replace all the existing transaction configurations for the given source                WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_transaction_configuration_source_with_http_info(source, set_transaction_configuration_source_request, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction configurations for (required)
:type source: str
:param set_transaction_configuration_source_request: The set of transaction configurations (required)
:type set_transaction_configuration_source_request: list[SetTransactionConfigurationSourceRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionSetConfigurationData, int, HTTPHeaderDict)"""
        return self.__client.set_transaction_configuration_source_with_http_info(source, set_transaction_configuration_source_request, **kwargs)

system_configuration_api = __SystemConfigurationApiAuthedAndStubbed()

class __TaxRuleSetsApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.TaxRuleSetsApi)

   def create_tax_rule_set(self, create_tax_rule_set_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateTaxRuleSet: Create a tax rule set.  # noqa: E501

Creates a tax rule set definition at the given effective time.  The user must be entitled to read any properties specified in each rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_tax_rule_set(create_tax_rule_set_request, async_req=True)
>>> result = thread.get()

:param create_tax_rule_set_request: The contents of the rule set. (required)
:type create_tax_rule_set_request: CreateTaxRuleSetRequest
:param effective_at: The effective datetime or cut label at which the rule set will take effect.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TaxRuleSet"""
        return self.__client.create_tax_rule_set(create_tax_rule_set_request, **kwargs)

   def create_tax_rule_set_with_http_info(self, create_tax_rule_set_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] CreateTaxRuleSet: Create a tax rule set.  # noqa: E501

Creates a tax rule set definition at the given effective time.  The user must be entitled to read any properties specified in each rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_tax_rule_set_with_http_info(create_tax_rule_set_request, async_req=True)
>>> result = thread.get()

:param create_tax_rule_set_request: The contents of the rule set. (required)
:type create_tax_rule_set_request: CreateTaxRuleSetRequest
:param effective_at: The effective datetime or cut label at which the rule set will take effect.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TaxRuleSet, int, HTTPHeaderDict)"""
        return self.__client.create_tax_rule_set_with_http_info(create_tax_rule_set_request, **kwargs)

   def delete_tax_rule_set(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTaxRuleSet: Delete a tax rule set.  # noqa: E501

<br>              Deletes the rule set for all effective time.                <br>              The rule set will remain viewable at previous as at times, but it will no longer be considered applicable.                <br>              This cannot be undone.                # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_tax_rule_set(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The rule set scope. (required)
:type scope: str
:param code: The rule set code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_tax_rule_set(scope, code, **kwargs)

   def delete_tax_rule_set_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTaxRuleSet: Delete a tax rule set.  # noqa: E501

<br>              Deletes the rule set for all effective time.                <br>              The rule set will remain viewable at previous as at times, but it will no longer be considered applicable.                <br>              This cannot be undone.                # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_tax_rule_set_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The rule set scope. (required)
:type scope: str
:param code: The rule set code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_tax_rule_set_with_http_info(scope, code, **kwargs)

   def get_tax_rule_set(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTaxRuleSet: Retrieve the definition of single tax rule set.  # noqa: E501

Retrieves the tax rule set definition at the given effective and as at times.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_tax_rule_set(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The rule set scope. (required)
:type scope: str
:param code: The rule set code. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the rule definition.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definition. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TaxRuleSet"""
        return self.__client.get_tax_rule_set(scope, code, **kwargs)

   def get_tax_rule_set_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTaxRuleSet: Retrieve the definition of single tax rule set.  # noqa: E501

Retrieves the tax rule set definition at the given effective and as at times.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_tax_rule_set_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The rule set scope. (required)
:type scope: str
:param code: The rule set code. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the rule definition.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definition. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TaxRuleSet, int, HTTPHeaderDict)"""
        return self.__client.get_tax_rule_set_with_http_info(scope, code, **kwargs)

   def list_tax_rule_sets(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTaxRuleSets: List tax rule sets.  # noqa: E501

Retrieves all tax rule set definitions at the given effective and as at times  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_tax_rule_sets(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to retrieve the rule definitions.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfTaxRuleSet"""
        return self.__client.list_tax_rule_sets(**kwargs)

   def list_tax_rule_sets_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTaxRuleSets: List tax rule sets.  # noqa: E501

Retrieves all tax rule set definitions at the given effective and as at times  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_tax_rule_sets_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to retrieve the rule definitions.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfTaxRuleSet, int, HTTPHeaderDict)"""
        return self.__client.list_tax_rule_sets_with_http_info(**kwargs)

   def update_tax_rule_set(self, scope: Any, code: Any, update_tax_rule_set_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpdateTaxRuleSet: Update a tax rule set.  # noqa: E501

Updates the tax rule set definition at the given effective time.  The changes will take place from this effective time until the next effective time that the rule has been updated at.  For example, consider a rule that has been created or updated effective at the first day of the coming month.  An upsert effective from the current day will only change the definition until that day.  An additional upsert at the same time (first day of the month) is required if the newly-updated definition is to supersede the future definition.  The user must be entitled to read any properties specified in each rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_tax_rule_set(scope, code, update_tax_rule_set_request, async_req=True)
>>> result = thread.get()

:param scope: The rule set scope. (required)
:type scope: str
:param code: The rule set code. (required)
:type code: str
:param update_tax_rule_set_request: The contents of the rule set. (required)
:type update_tax_rule_set_request: UpdateTaxRuleSetRequest
:param effective_at: The effective datetime or cut label at which the rule set will take effect.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TaxRuleSet"""
        return self.__client.update_tax_rule_set(scope, code, update_tax_rule_set_request, **kwargs)

   def update_tax_rule_set_with_http_info(self, scope: Any, code: Any, update_tax_rule_set_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpdateTaxRuleSet: Update a tax rule set.  # noqa: E501

Updates the tax rule set definition at the given effective time.  The changes will take place from this effective time until the next effective time that the rule has been updated at.  For example, consider a rule that has been created or updated effective at the first day of the coming month.  An upsert effective from the current day will only change the definition until that day.  An additional upsert at the same time (first day of the month) is required if the newly-updated definition is to supersede the future definition.  The user must be entitled to read any properties specified in each rule.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.update_tax_rule_set_with_http_info(scope, code, update_tax_rule_set_request, async_req=True)
>>> result = thread.get()

:param scope: The rule set scope. (required)
:type scope: str
:param code: The rule set code. (required)
:type code: str
:param update_tax_rule_set_request: The contents of the rule set. (required)
:type update_tax_rule_set_request: UpdateTaxRuleSetRequest
:param effective_at: The effective datetime or cut label at which the rule set will take effect.  Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TaxRuleSet, int, HTTPHeaderDict)"""
        return self.__client.update_tax_rule_set_with_http_info(scope, code, update_tax_rule_set_request, **kwargs)

tax_rule_sets_api = __TaxRuleSetsApiAuthedAndStubbed()

class __TransactionConfigurationApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.TransactionConfigurationApi)

   def delete_side_definition(self, side: Any, **kwargs) -> 'Any':
        """DeleteSideDefinition: Delete the given side definition  # noqa: E501

Delete the side which user specify in the request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_side_definition(side, async_req=True)
>>> result = thread.get()

:param side: The label to uniquely identify the side. (required)
:type side: str
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_side_definition(side, **kwargs)

   def delete_side_definition_with_http_info(self, side: Any, **kwargs) -> 'Any':
        """DeleteSideDefinition: Delete the given side definition  # noqa: E501

Delete the side which user specify in the request.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_side_definition_with_http_info(side, async_req=True)
>>> result = thread.get()

:param side: The label to uniquely identify the side. (required)
:type side: str
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_side_definition_with_http_info(side, **kwargs)

   def delete_transaction_type(self, source: Any, type: Any, **kwargs) -> 'Any':
        """DeleteTransactionType: Delete a transaction type  # noqa: E501

/// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_type(source, type, async_req=True)
>>> result = thread.get()

:param source: The source that the type is in (required)
:type source: str
:param type: One of the type's aliases (required)
:type type: str
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_transaction_type(source, type, **kwargs)

   def delete_transaction_type_source(self, source: Any, **kwargs) -> 'Any':
        """DeleteTransactionTypeSource: Delete all transaction types for the given source and scope  # noqa: E501

Delete all the types for the given source and scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_type_source(source, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction types for. (required)
:type source: str
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_transaction_type_source(source, **kwargs)

   def delete_transaction_type_source_with_http_info(self, source: Any, **kwargs) -> 'Any':
        """DeleteTransactionTypeSource: Delete all transaction types for the given source and scope  # noqa: E501

Delete all the types for the given source and scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_type_source_with_http_info(source, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction types for. (required)
:type source: str
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_transaction_type_source_with_http_info(source, **kwargs)

   def delete_transaction_type_with_http_info(self, source: Any, type: Any, **kwargs) -> 'Any':
        """DeleteTransactionType: Delete a transaction type  # noqa: E501

/// WARNING! Changing existing transaction types has a material impact on how data, new and old,  is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_type_with_http_info(source, type, async_req=True)
>>> result = thread.get()

:param source: The source that the type is in (required)
:type source: str
:param type: One of the type's aliases (required)
:type type: str
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_transaction_type_with_http_info(source, type, **kwargs)

   def get_side_definition(self, side: Any, **kwargs) -> 'Any':
        """GetSideDefinition: Get the side definition for a given side name( or label)  # noqa: E501

Get the side definition user requested.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_side_definition(side, async_req=True)
>>> result = thread.get()

:param side: The label to uniquely identify the side. (required)
:type side: str
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: SideDefinition"""
        return self.__client.get_side_definition(side, **kwargs)

   def get_side_definition_with_http_info(self, side: Any, **kwargs) -> 'Any':
        """GetSideDefinition: Get the side definition for a given side name( or label)  # noqa: E501

Get the side definition user requested.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_side_definition_with_http_info(side, async_req=True)
>>> result = thread.get()

:param side: The label to uniquely identify the side. (required)
:type side: str
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (SideDefinition, int, HTTPHeaderDict)"""
        return self.__client.get_side_definition_with_http_info(side, **kwargs)

   def get_transaction_type(self, source: Any, type: Any, **kwargs) -> 'Any':
        """GetTransactionType: Get a single transaction configuration type  # noqa: E501

Get a single transaction type. Returns failure if not found  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_type(source, type, async_req=True)
>>> result = thread.get()

:param source: The source that the type is in (required)
:type source: str
:param type: One of the type's aliases (required)
:type type: str
:param as_at: The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified
:type as_at: datetime
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionType"""
        return self.__client.get_transaction_type(source, type, **kwargs)

   def get_transaction_type_with_http_info(self, source: Any, type: Any, **kwargs) -> 'Any':
        """GetTransactionType: Get a single transaction configuration type  # noqa: E501

Get a single transaction type. Returns failure if not found  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_type_with_http_info(source, type, async_req=True)
>>> result = thread.get()

:param source: The source that the type is in (required)
:type source: str
:param type: One of the type's aliases (required)
:type type: str
:param as_at: The asAt datetime at which to retrieve the transaction configuration.              Defaults to returning the latest version of the transaction configuration type if not specified
:type as_at: datetime
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionType, int, HTTPHeaderDict)"""
        return self.__client.get_transaction_type_with_http_info(source, type, **kwargs)

   def list_side_definitions(self, **kwargs) -> 'Any':
        """ListSideDefinitions: List the side definitions  # noqa: E501

List all the side definitions in the given scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_side_definitions(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified.
:type as_at: datetime
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfSideDefinition"""
        return self.__client.list_side_definitions(**kwargs)

   def list_side_definitions_with_http_info(self, **kwargs) -> 'Any':
        """ListSideDefinitions: List the side definitions  # noqa: E501

List all the side definitions in the given scope  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_side_definitions_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults to returning the latest versions if not specified.
:type as_at: datetime
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfSideDefinition, int, HTTPHeaderDict)"""
        return self.__client.list_side_definitions_with_http_info(**kwargs)

   def list_transaction_types(self, **kwargs) -> 'Any':
        """ListTransactionTypes: List transaction types  # noqa: E501

Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_types(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified.
:type as_at: datetime
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: dict(str, list[TransactionType])"""
        return self.__client.list_transaction_types(**kwargs)

   def list_transaction_types_with_http_info(self, **kwargs) -> 'Any':
        """ListTransactionTypes: List transaction types  # noqa: E501

Get the list of current transaction types. For information on the default transaction types provided with  LUSID, see https://support.lusid.com/knowledgebase/article/KA-01873/.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_types_with_http_info(async_req=True)
>>> result = thread.get()

:param as_at: The asAt datetime at which to retrieve the transaction types. Defaults              to returning the latest versions if not specified.
:type as_at: datetime
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (dict(str, list[TransactionType]), int, HTTPHeaderDict)"""
        return self.__client.list_transaction_types_with_http_info(**kwargs)

   def set_side_definition(self, side: Any, side_definition_request: Any, **kwargs) -> 'Any':
        """SetSideDefinition: Set a side definition  # noqa: E501

Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_side_definition(side, side_definition_request, async_req=True)
>>> result = thread.get()

:param side: The label to uniquely identify the side. (required)
:type side: str
:param side_definition_request: The side definition to create or replace. (required)
:type side_definition_request: SideDefinitionRequest
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: SideDefinition"""
        return self.__client.set_side_definition(side, side_definition_request, **kwargs)

   def set_side_definition_with_http_info(self, side: Any, side_definition_request: Any, **kwargs) -> 'Any':
        """SetSideDefinition: Set a side definition  # noqa: E501

Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_side_definition_with_http_info(side, side_definition_request, async_req=True)
>>> result = thread.get()

:param side: The label to uniquely identify the side. (required)
:type side: str
:param side_definition_request: The side definition to create or replace. (required)
:type side_definition_request: SideDefinitionRequest
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (SideDefinition, int, HTTPHeaderDict)"""
        return self.__client.set_side_definition_with_http_info(side, side_definition_request, **kwargs)

   def set_side_definitions(self, sides_definition_request: Any, **kwargs) -> 'Any':
        """SetSideDefinitions: Set the given side definitions  # noqa: E501

Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_side_definitions(sides_definition_request, async_req=True)
>>> result = thread.get()

:param sides_definition_request: The list of side definitions to create, or replace. (required)
:type sides_definition_request: list[SidesDefinitionRequest]
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfSideDefinition"""
        return self.__client.set_side_definitions(sides_definition_request, **kwargs)

   def set_side_definitions_with_http_info(self, sides_definition_request: Any, **kwargs) -> 'Any':
        """SetSideDefinitions: Set the given side definitions  # noqa: E501

Set a new side definition for use in a transaction type. For more information, see https://support.lusid.com/knowledgebase/article/KA-01875.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_side_definitions_with_http_info(sides_definition_request, async_req=True)
>>> result = thread.get()

:param sides_definition_request: The list of side definitions to create, or replace. (required)
:type sides_definition_request: list[SidesDefinitionRequest]
:param scope: The scope in which the side exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfSideDefinition, int, HTTPHeaderDict)"""
        return self.__client.set_side_definitions_with_http_info(sides_definition_request, **kwargs)

   def set_transaction_type(self, source: Any, type: Any, transaction_type_request: Any, **kwargs) -> 'Any':
        """SetTransactionType: Set a specific transaction type  # noqa: E501

Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_transaction_type(source, type, transaction_type_request, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction configuration for (required)
:type source: str
:param type: One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type (required)
:type type: str
:param transaction_type_request: The transaction configuration to set (required)
:type transaction_type_request: TransactionTypeRequest
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TransactionType"""
        return self.__client.set_transaction_type(source, type, transaction_type_request, **kwargs)

   def set_transaction_type_source(self, source: Any, transaction_type_request: Any, **kwargs) -> 'Any':
        """SetTransactionTypeSource: Set the transaction types for the given source and scope  # noqa: E501

The complete set of transaction types for the source.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_transaction_type_source(source, transaction_type_request, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction types for. (required)
:type source: str
:param transaction_type_request: The set of transaction types. (required)
:type transaction_type_request: list[TransactionTypeRequest]
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfTransactionType"""
        return self.__client.set_transaction_type_source(source, transaction_type_request, **kwargs)

   def set_transaction_type_source_with_http_info(self, source: Any, transaction_type_request: Any, **kwargs) -> 'Any':
        """SetTransactionTypeSource: Set the transaction types for the given source and scope  # noqa: E501

The complete set of transaction types for the source.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_transaction_type_source_with_http_info(source, transaction_type_request, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction types for. (required)
:type source: str
:param transaction_type_request: The set of transaction types. (required)
:type transaction_type_request: list[TransactionTypeRequest]
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfTransactionType, int, HTTPHeaderDict)"""
        return self.__client.set_transaction_type_source_with_http_info(source, transaction_type_request, **kwargs)

   def set_transaction_type_with_http_info(self, source: Any, type: Any, transaction_type_request: Any, **kwargs) -> 'Any':
        """SetTransactionType: Set a specific transaction type  # noqa: E501

Set a transaction type for the given source and type. If the requested transaction type does not exist, it will be created    WARNING! Changing existing transaction types has a material impact on how data, new and old, is processed and aggregated by LUSID, and will affect your whole organisation. Only call this API if you are fully aware of the implications of the change.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_transaction_type_with_http_info(source, type, transaction_type_request, async_req=True)
>>> result = thread.get()

:param source: The source to set the transaction configuration for (required)
:type source: str
:param type: One of the transaction configuration alias types to uniquely identify the configuration. If this type does not exist, then a new transaction type is created using the body of the request in the given source, without including this type (required)
:type type: str
:param transaction_type_request: The transaction configuration to set (required)
:type transaction_type_request: TransactionTypeRequest
:param scope: The scope in which the transaction types exists. When not supplied the scope is 'default'.
:type scope: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TransactionType, int, HTTPHeaderDict)"""
        return self.__client.set_transaction_type_with_http_info(source, type, transaction_type_request, **kwargs)

transaction_configuration_api = __TransactionConfigurationApiAuthedAndStubbed()

class __TransactionFeesApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.TransactionFeesApi)

   def delete_transaction_fee_rule(self, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTransactionFeeRule: Deletes a fee rule.  # noqa: E501

<br>              Deletes the rule for all effective time.                <br>              The rule will remain viewable at previous as at times, but it will no longer be considered by              GetApplicableFees.                <br>              This cannot be undone.                # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_fee_rule(code, async_req=True)
>>> result = thread.get()

:param code: The fee rule code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_transaction_fee_rule(code, **kwargs)

   def delete_transaction_fee_rule_with_http_info(self, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteTransactionFeeRule: Deletes a fee rule.  # noqa: E501

<br>              Deletes the rule for all effective time.                <br>              The rule will remain viewable at previous as at times, but it will no longer be considered by              GetApplicableFees.                <br>              This cannot be undone.                # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_transaction_fee_rule_with_http_info(code, async_req=True)
>>> result = thread.get()

:param code: The fee rule code. (required)
:type code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_transaction_fee_rule_with_http_info(code, **kwargs)

   def get_applicable_transaction_fees(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetApplicableTransactionFees: Get the Fees and Commissions that may be applicable to a transaction.  # noqa: E501

Additionally, matching can be based on the instrument's properties, its portfolio properties, and any additional property keys present in the data file.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_applicable_transaction_fees(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to match rule definitions. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to match rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param instrument_identifier_type: Optional. The unique identifier type to use, eg 'Figi' or 'LusidInstrumentId'.
:type instrument_identifier_type: str
:param instrument_identifier: Optional. The Instrument Identifier to get properties for.
:type instrument_identifier: str
:param portfolio_scope: Optional. The scope of the portfolio to fetch properties from.
:type portfolio_scope: str
:param portfolio_code: Optional. The code of the portfolio to fetch properties from.
:type portfolio_code: str
:param request_body: Any other property keys or fields, including the top-level fields of the              fee rule (e.g. "ExecutionBroker" and "SettlementCurrency" ) and those defined in AdditionalKeys, along with              their corresponding values that should be matched for fees. Eg. "Instrument/default/Name=exampleValue" or              "AdditionalKey2=Value2".
:type request_body: dict(str, str)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfFeeRule"""
        return self.__client.get_applicable_transaction_fees(**kwargs)

   def get_applicable_transaction_fees_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetApplicableTransactionFees: Get the Fees and Commissions that may be applicable to a transaction.  # noqa: E501

Additionally, matching can be based on the instrument's properties, its portfolio properties, and any additional property keys present in the data file.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_applicable_transaction_fees_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to match rule definitions. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to match rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param instrument_identifier_type: Optional. The unique identifier type to use, eg 'Figi' or 'LusidInstrumentId'.
:type instrument_identifier_type: str
:param instrument_identifier: Optional. The Instrument Identifier to get properties for.
:type instrument_identifier: str
:param portfolio_scope: Optional. The scope of the portfolio to fetch properties from.
:type portfolio_scope: str
:param portfolio_code: Optional. The code of the portfolio to fetch properties from.
:type portfolio_code: str
:param request_body: Any other property keys or fields, including the top-level fields of the              fee rule (e.g. "ExecutionBroker" and "SettlementCurrency" ) and those defined in AdditionalKeys, along with              their corresponding values that should be matched for fees. Eg. "Instrument/default/Name=exampleValue" or              "AdditionalKey2=Value2".
:type request_body: dict(str, str)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfFeeRule, int, HTTPHeaderDict)"""
        return self.__client.get_applicable_transaction_fees_with_http_info(**kwargs)

   def get_transaction_fee_rule(self, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionFeeRule: Retrieve the definition of single fee rule.  # noqa: E501

Retrieves the fee rule definition at the given effective and as at times.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_fee_rule(code, async_req=True)
>>> result = thread.get()

:param code: The fee rule code. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the rule definition. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definition. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: FeeRule"""
        return self.__client.get_transaction_fee_rule(code, **kwargs)

   def get_transaction_fee_rule_with_http_info(self, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetTransactionFeeRule: Retrieve the definition of single fee rule.  # noqa: E501

Retrieves the fee rule definition at the given effective and as at times.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_fee_rule_with_http_info(code, async_req=True)
>>> result = thread.get()

:param code: The fee rule code. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the rule definition. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definition. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (FeeRule, int, HTTPHeaderDict)"""
        return self.__client.get_transaction_fee_rule_with_http_info(code, **kwargs)

   def list_transaction_fee_rules(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTransactionFeeRules: List fee rules, with optional filtering.  # noqa: E501

For more information about filtering results,  see https://support.lusid.com/knowledgebase/article/KA-01914.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_fee_rules(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to retrieve the rule definitions. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.
:type filter: str
:param page: The pagination token to use to continue listing entities; this value is returned from the previous call. If  a pagination token is provided, the filter, effectiveAt and asAt fields must not have changed since the  original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfFeeRule"""
        return self.__client.list_transaction_fee_rules(**kwargs)

   def list_transaction_fee_rules_with_http_info(self, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListTransactionFeeRules: List fee rules, with optional filtering.  # noqa: E501

For more information about filtering results,  see https://support.lusid.com/knowledgebase/article/KA-01914.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_transaction_fee_rules_with_http_info(async_req=True)
>>> result = thread.get()

:param effective_at: The effective datetime or cut label at which to retrieve the rule definitions. Defaults to the current LUSID  system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the rule definitions. Defaults to returning the latest version if not  specified.
:type as_at: datetime
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.
:type filter: str
:param page: The pagination token to use to continue listing entities; this value is returned from the previous call. If  a pagination token is provided, the filter, effectiveAt and asAt fields must not have changed since the  original request.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfFeeRule, int, HTTPHeaderDict)"""
        return self.__client.list_transaction_fee_rules_with_http_info(**kwargs)

   def upsert_transaction_fee_rules(self, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertTransactionFeeRules: Upsert fee rules.  # noqa: E501

<br>              To upsert a new rule, the code field must be left empty, a code will then be assigned and returned as part              of the response. To update an existing rule, include the fee code. It is possible to both create and update              fee rules in the same request.                <br>              The upsert is transactional - either all create/update operations will succeed or none of them will.                # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_transaction_fee_rules(request_body, async_req=True)
>>> result = thread.get()

:param request_body: A dictionary of upsert request identifiers to rule upsert requests. The request              identifiers are valid for the request only and can be used to link the upserted fee rule to the code of a              created fee rule. (required)
:type request_body: dict(str, FeeRuleUpsertRequest)
:param effective_at: The effective datetime or cut label at which the rule will take effect. Defaults to the current LUSID  system datetime if not specified. In the case of an update, the changes will take place from this effective  time until the next effective time that the rule as been upserted at. For example, consider a rule that  already exists, and has previously had an update applied so that the definition will change on the first day  of the coming month. An upsert effective from the current day will only change the definition until the  first day of the coming month. An additional upsert at the same time (first day of the month) is required  if the newly-updated definition is to supersede the future definition.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: FeeRuleUpsertResponse"""
        return self.__client.upsert_transaction_fee_rules(request_body, **kwargs)

   def upsert_transaction_fee_rules_with_http_info(self, request_body: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertTransactionFeeRules: Upsert fee rules.  # noqa: E501

<br>              To upsert a new rule, the code field must be left empty, a code will then be assigned and returned as part              of the response. To update an existing rule, include the fee code. It is possible to both create and update              fee rules in the same request.                <br>              The upsert is transactional - either all create/update operations will succeed or none of them will.                # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_transaction_fee_rules_with_http_info(request_body, async_req=True)
>>> result = thread.get()

:param request_body: A dictionary of upsert request identifiers to rule upsert requests. The request              identifiers are valid for the request only and can be used to link the upserted fee rule to the code of a              created fee rule. (required)
:type request_body: dict(str, FeeRuleUpsertRequest)
:param effective_at: The effective datetime or cut label at which the rule will take effect. Defaults to the current LUSID  system datetime if not specified. In the case of an update, the changes will take place from this effective  time until the next effective time that the rule as been upserted at. For example, consider a rule that  already exists, and has previously had an update applied so that the definition will change on the first day  of the coming month. An upsert effective from the current day will only change the definition until the  first day of the coming month. An additional upsert at the same time (first day of the month) is required  if the newly-updated definition is to supersede the future definition.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (FeeRuleUpsertResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_transaction_fee_rules_with_http_info(request_body, **kwargs)

transaction_fees_api = __TransactionFeesApiAuthedAndStubbed()

class __TransactionPortfoliosApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.TransactionPortfoliosApi)

   def adjust_holdings(self, scope: Any, code: Any, effective_at: Any, adjust_holding_request: Any, **kwargs) -> 'Any':
        """AdjustHoldings: Adjust holdings  # noqa: E501

Adjust one or more holdings of the specified transaction portfolio to the provided targets. LUSID will  automatically construct adjustment transactions to ensure that the holdings which have been adjusted are  always set to the provided targets for the specified effective datetime. Read more about the difference between  adjusting and setting holdings here https://support.lusid.com/how-do-i-adjust-my-holdings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.adjust_holdings(scope, code, effective_at, adjust_holding_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which the holdings should be set to the provided targets. (required)
:type effective_at: str
:param adjust_holding_request: The selected set of holdings to adjust to the provided targets for the              transaction portfolio. (required)
:type adjust_holding_request: list[AdjustHoldingRequest]
:param reconciliation_methods: Optional parameter for specifying a reconciliation method: e.g. FxForward.
:type reconciliation_methods: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AdjustHolding"""
        return self.__client.adjust_holdings(scope, code, effective_at, adjust_holding_request, **kwargs)

   def adjust_holdings_with_http_info(self, scope: Any, code: Any, effective_at: Any, adjust_holding_request: Any, **kwargs) -> 'Any':
        """AdjustHoldings: Adjust holdings  # noqa: E501

Adjust one or more holdings of the specified transaction portfolio to the provided targets. LUSID will  automatically construct adjustment transactions to ensure that the holdings which have been adjusted are  always set to the provided targets for the specified effective datetime. Read more about the difference between  adjusting and setting holdings here https://support.lusid.com/how-do-i-adjust-my-holdings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.adjust_holdings_with_http_info(scope, code, effective_at, adjust_holding_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which the holdings should be set to the provided targets. (required)
:type effective_at: str
:param adjust_holding_request: The selected set of holdings to adjust to the provided targets for the              transaction portfolio. (required)
:type adjust_holding_request: list[AdjustHoldingRequest]
:param reconciliation_methods: Optional parameter for specifying a reconciliation method: e.g. FxForward.
:type reconciliation_methods: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AdjustHolding, int, HTTPHeaderDict)"""
        return self.__client.adjust_holdings_with_http_info(scope, code, effective_at, adjust_holding_request, **kwargs)

   def batch_adjust_holdings(self, scope: Any, code: Any, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchAdjustHoldings: Batch adjust holdings  # noqa: E501

Adjust one or more holdings of the specified transaction portfolio to the provided targets. LUSID will  automatically construct adjustment transactions to ensure that the holdings which have been adjusted are  always set to the provided targets for the specified effective datetime in each request.                Each request must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each adjustment in the response.    Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_adjust_holdings(scope, code, success_mode, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies               the transaction portfolio. (required)
:type code: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial (required)
:type success_mode: str
:param request_body: The selected set of holdings to adjust to the provided targets for the               transaction portfolio. (required)
:type request_body: dict(str, AdjustHoldingForDateRequest)
:param reconciliation_methods: Optional parameter for specifying a reconciliation method: e.g. FxForward.
:type reconciliation_methods: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BatchAdjustHoldingsResponse"""
        return self.__client.batch_adjust_holdings(scope, code, success_mode, request_body, **kwargs)

   def batch_adjust_holdings_with_http_info(self, scope: Any, code: Any, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchAdjustHoldings: Batch adjust holdings  # noqa: E501

Adjust one or more holdings of the specified transaction portfolio to the provided targets. LUSID will  automatically construct adjustment transactions to ensure that the holdings which have been adjusted are  always set to the provided targets for the specified effective datetime in each request.                Each request must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each adjustment in the response.    Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_adjust_holdings_with_http_info(scope, code, success_mode, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies               the transaction portfolio. (required)
:type code: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial (required)
:type success_mode: str
:param request_body: The selected set of holdings to adjust to the provided targets for the               transaction portfolio. (required)
:type request_body: dict(str, AdjustHoldingForDateRequest)
:param reconciliation_methods: Optional parameter for specifying a reconciliation method: e.g. FxForward.
:type reconciliation_methods: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BatchAdjustHoldingsResponse, int, HTTPHeaderDict)"""
        return self.__client.batch_adjust_holdings_with_http_info(scope, code, success_mode, request_body, **kwargs)

   def batch_create_trade_tickets(self, scope: Any, code: Any, lusid_trade_ticket: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchCreateTradeTickets: Batch Create Trade Tickets  # noqa: E501

Batch create trade tickets. Each ticket is broadly equivalent to a singular call to upsert an instrument, then a counterparty and finally  a transaction that makes use of the two.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_create_trade_tickets(scope, code, lusid_trade_ticket, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param lusid_trade_ticket: the trade tickets to create (required)
:type lusid_trade_ticket: list[LusidTradeTicket]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CreateTradeTicketsResponse"""
        return self.__client.batch_create_trade_tickets(scope, code, lusid_trade_ticket, **kwargs)

   def batch_create_trade_tickets_with_http_info(self, scope: Any, code: Any, lusid_trade_ticket: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchCreateTradeTickets: Batch Create Trade Tickets  # noqa: E501

Batch create trade tickets. Each ticket is broadly equivalent to a singular call to upsert an instrument, then a counterparty and finally  a transaction that makes use of the two.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_create_trade_tickets_with_http_info(scope, code, lusid_trade_ticket, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param lusid_trade_ticket: the trade tickets to create (required)
:type lusid_trade_ticket: list[LusidTradeTicket]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CreateTradeTicketsResponse, int, HTTPHeaderDict)"""
        return self.__client.batch_create_trade_tickets_with_http_info(scope, code, lusid_trade_ticket, **kwargs)

   def batch_upsert_transactions(self, scope: Any, code: Any, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchUpsertTransactions: Batch upsert transactions  # noqa: E501

Create or update transactions in the transaction portfolio. A transaction will be updated  if it already exists and created if it does not.    Each request must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each transaction in the response.    Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_upsert_transactions(scope, code, success_mode, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial. (required)
:type success_mode: str
:param request_body: The payload describing the transactions to be created or updated. (required)
:type request_body: dict(str, TransactionRequest)
:param preserve_properties: If set to false, the entire property set will be overwritten by the provided properties. If not specified or set to true, only the properties provided will be updated.
:type preserve_properties: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BatchUpsertPortfolioTransactionsResponse"""
        return self.__client.batch_upsert_transactions(scope, code, success_mode, request_body, **kwargs)

   def batch_upsert_transactions_with_http_info(self, scope: Any, code: Any, success_mode: Any, request_body: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] BatchUpsertTransactions: Batch upsert transactions  # noqa: E501

Create or update transactions in the transaction portfolio. A transaction will be updated  if it already exists and created if it does not.    Each request must be keyed by a unique correlation id. This id is ephemeral and is not stored by LUSID.  It serves only as a way to easily identify each transaction in the response.    Note: If using partial failure modes, then it is important to check the response body for failures as any failures will still return a 200 status code  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.batch_upsert_transactions_with_http_info(scope, code, success_mode, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param success_mode: Whether the batch request should fail Atomically or in a Partial fashion - Allowed Values: Atomic, Partial. (required)
:type success_mode: str
:param request_body: The payload describing the transactions to be created or updated. (required)
:type request_body: dict(str, TransactionRequest)
:param preserve_properties: If set to false, the entire property set will be overwritten by the provided properties. If not specified or set to true, only the properties provided will be updated.
:type preserve_properties: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BatchUpsertPortfolioTransactionsResponse, int, HTTPHeaderDict)"""
        return self.__client.batch_upsert_transactions_with_http_info(scope, code, success_mode, request_body, **kwargs)

   def build_transactions(self, scope: Any, code: Any, transaction_query_parameters: Any, **kwargs) -> 'Any':
        """BuildTransactions: Build transactions  # noqa: E501

Builds and returns all transactions that affect the holdings of a portfolio over a given interval of  effective time into a set of output transactions. This includes transactions automatically generated by  LUSID such as holding adjustments.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.build_transactions(scope, code, transaction_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_query_parameters: The query queryParameters which control how the output transactions are built. (required)
:type transaction_query_parameters: TransactionQueryParameters
:param as_at: The asAt datetime at which to build the transactions. Defaults to return the latest              version of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the "Instrument" or "Transaction" domain to decorate onto              the transactions. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or              "Transaction/strategy/quantsignal".
:type property_keys: list[str]
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing transactions from a previous call to BuildTransactions.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfOutputTransaction"""
        return self.__client.build_transactions(scope, code, transaction_query_parameters, **kwargs)

   def build_transactions_with_http_info(self, scope: Any, code: Any, transaction_query_parameters: Any, **kwargs) -> 'Any':
        """BuildTransactions: Build transactions  # noqa: E501

Builds and returns all transactions that affect the holdings of a portfolio over a given interval of  effective time into a set of output transactions. This includes transactions automatically generated by  LUSID such as holding adjustments.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.build_transactions_with_http_info(scope, code, transaction_query_parameters, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_query_parameters: The query queryParameters which control how the output transactions are built. (required)
:type transaction_query_parameters: TransactionQueryParameters
:param as_at: The asAt datetime at which to build the transactions. Defaults to return the latest              version of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the "Instrument" or "Transaction" domain to decorate onto              the transactions. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or              "Transaction/strategy/quantsignal".
:type property_keys: list[str]
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param page: The pagination token to use to continue listing transactions from a previous call to BuildTransactions.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfOutputTransaction, int, HTTPHeaderDict)"""
        return self.__client.build_transactions_with_http_info(scope, code, transaction_query_parameters, **kwargs)

   def cancel_adjust_holdings(self, scope: Any, code: Any, effective_at: Any, **kwargs) -> 'Any':
        """CancelAdjustHoldings: Cancel adjust holdings  # noqa: E501

Cancel all previous holding adjustments made on the specified transaction portfolio for a specified effective  datetime. This should be used to undo holding adjustments made via set holdings or adjust holdings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.cancel_adjust_holdings(scope, code, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which the holding adjustments should be undone. (required)
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.cancel_adjust_holdings(scope, code, effective_at, **kwargs)

   def cancel_adjust_holdings_with_http_info(self, scope: Any, code: Any, effective_at: Any, **kwargs) -> 'Any':
        """CancelAdjustHoldings: Cancel adjust holdings  # noqa: E501

Cancel all previous holding adjustments made on the specified transaction portfolio for a specified effective  datetime. This should be used to undo holding adjustments made via set holdings or adjust holdings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.cancel_adjust_holdings_with_http_info(scope, code, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which the holding adjustments should be undone. (required)
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.cancel_adjust_holdings_with_http_info(scope, code, effective_at, **kwargs)

   def cancel_transactions(self, scope: Any, code: Any, transaction_ids: Any, **kwargs) -> 'Any':
        """CancelTransactions: Cancel transactions  # noqa: E501

Cancel one or more transactions from the transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.cancel_transactions(scope, code, transaction_ids, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_ids: The IDs of the transactions to cancel. (required)
:type transaction_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.cancel_transactions(scope, code, transaction_ids, **kwargs)

   def cancel_transactions_with_http_info(self, scope: Any, code: Any, transaction_ids: Any, **kwargs) -> 'Any':
        """CancelTransactions: Cancel transactions  # noqa: E501

Cancel one or more transactions from the transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.cancel_transactions_with_http_info(scope, code, transaction_ids, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_ids: The IDs of the transactions to cancel. (required)
:type transaction_ids: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.cancel_transactions_with_http_info(scope, code, transaction_ids, **kwargs)

   def create_portfolio(self, scope: Any, create_transaction_portfolio_request: Any, **kwargs) -> 'Any':
        """CreatePortfolio: Create portfolio  # noqa: E501

Create a transaction portfolio in a particular scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_portfolio(scope, create_transaction_portfolio_request, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create the transaction portfolio. (required)
:type scope: str
:param create_transaction_portfolio_request: The definition of the transaction portfolio. (required)
:type create_transaction_portfolio_request: CreateTransactionPortfolioRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: Portfolio"""
        return self.__client.create_portfolio(scope, create_transaction_portfolio_request, **kwargs)

   def create_portfolio_with_http_info(self, scope: Any, create_transaction_portfolio_request: Any, **kwargs) -> 'Any':
        """CreatePortfolio: Create portfolio  # noqa: E501

Create a transaction portfolio in a particular scope.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_portfolio_with_http_info(scope, create_transaction_portfolio_request, async_req=True)
>>> result = thread.get()

:param scope: The scope in which to create the transaction portfolio. (required)
:type scope: str
:param create_transaction_portfolio_request: The definition of the transaction portfolio. (required)
:type create_transaction_portfolio_request: CreateTransactionPortfolioRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (Portfolio, int, HTTPHeaderDict)"""
        return self.__client.create_portfolio_with_http_info(scope, create_transaction_portfolio_request, **kwargs)

   def create_trade_ticket(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateTradeTicket: Create Trade Ticket  # noqa: E501

Upsert a trade ticket. Broadly equivalent to a singular call to upsert an instrument, then a counterparty and finally  a transaction that makes use of the two. It can be viewed as a utility function or part of a workflow more familiar to users  with OTC systems than flow and equity trading ones.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_trade_ticket(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param lusid_trade_ticket: the trade ticket to upsert
:type lusid_trade_ticket: LusidTradeTicket
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: LusidTradeTicket"""
        return self.__client.create_trade_ticket(scope, code, **kwargs)

   def create_trade_ticket_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] CreateTradeTicket: Create Trade Ticket  # noqa: E501

Upsert a trade ticket. Broadly equivalent to a singular call to upsert an instrument, then a counterparty and finally  a transaction that makes use of the two. It can be viewed as a utility function or part of a workflow more familiar to users  with OTC systems than flow and equity trading ones.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.create_trade_ticket_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param lusid_trade_ticket: the trade ticket to upsert
:type lusid_trade_ticket: LusidTradeTicket
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (LusidTradeTicket, int, HTTPHeaderDict)"""
        return self.__client.create_trade_ticket_with_http_info(scope, code, **kwargs)

   def delete_custodian_accounts(self, scope: Any, code: Any, resource_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteCustodianAccounts: Soft or hard delete multiple custodian accounts  # noqa: E501

Delete one or more custodian accounts from the Transaction Portfolios. Soft deletion marks the custodian account as inactive  While the Hard deletion is deleting the custodian account.  The batch limit per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_custodian_accounts(scope, code, resource_id, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolios. (required)
:type scope: str
:param code: The code of the Transaction Portfolios. Together with the scope this uniquely identifies              the Transaction Portfolios. (required)
:type code: str
:param resource_id: The scope and codes of the custodian accounts to delete. (required)
:type resource_id: list[ResourceId]
:param delete_mode: The delete mode to use (defaults to 'Soft').
:type delete_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeleteCustodianAccountsResponse"""
        return self.__client.delete_custodian_accounts(scope, code, resource_id, **kwargs)

   def delete_custodian_accounts_with_http_info(self, scope: Any, code: Any, resource_id: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] DeleteCustodianAccounts: Soft or hard delete multiple custodian accounts  # noqa: E501

Delete one or more custodian accounts from the Transaction Portfolios. Soft deletion marks the custodian account as inactive  While the Hard deletion is deleting the custodian account.  The batch limit per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_custodian_accounts_with_http_info(scope, code, resource_id, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolios. (required)
:type scope: str
:param code: The code of the Transaction Portfolios. Together with the scope this uniquely identifies              the Transaction Portfolios. (required)
:type code: str
:param resource_id: The scope and codes of the custodian accounts to delete. (required)
:type resource_id: list[ResourceId]
:param delete_mode: The delete mode to use (defaults to 'Soft').
:type delete_mode: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeleteCustodianAccountsResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_custodian_accounts_with_http_info(scope, code, resource_id, **kwargs)

   def delete_properties_from_transaction(self, scope: Any, code: Any, transaction_id: Any, property_keys: Any, **kwargs) -> 'Any':
        """DeletePropertiesFromTransaction: Delete properties from transaction  # noqa: E501

Delete one or more properties from a single transaction in a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_properties_from_transaction(scope, code, transaction_id, property_keys, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_id: The unique ID of the transaction from which to delete properties. (required)
:type transaction_id: str
:param property_keys: The property keys of the properties to delete.              These must be from the "Transaction" domain and have the format {domain}/{scope}/{code}, for example              "Transaction/strategy/quantsignal". (required)
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: DeletedEntityResponse"""
        return self.__client.delete_properties_from_transaction(scope, code, transaction_id, property_keys, **kwargs)

   def delete_properties_from_transaction_with_http_info(self, scope: Any, code: Any, transaction_id: Any, property_keys: Any, **kwargs) -> 'Any':
        """DeletePropertiesFromTransaction: Delete properties from transaction  # noqa: E501

Delete one or more properties from a single transaction in a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.delete_properties_from_transaction_with_http_info(scope, code, transaction_id, property_keys, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_id: The unique ID of the transaction from which to delete properties. (required)
:type transaction_id: str
:param property_keys: The property keys of the properties to delete.              These must be from the "Transaction" domain and have the format {domain}/{scope}/{code}, for example              "Transaction/strategy/quantsignal". (required)
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (DeletedEntityResponse, int, HTTPHeaderDict)"""
        return self.__client.delete_properties_from_transaction_with_http_info(scope, code, transaction_id, property_keys, **kwargs)

   def get_a2_b_data(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """GetA2BData: Get A2B data  # noqa: E501

Get an A2B report for the given portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_a2_b_data(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio to retrieve the A2B report for. (required)
:type scope: str
:param code: The code of the portfolio to retrieve the A2B report for. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version              of each transaction if not specified.
:type as_at: datetime
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param property_keys: A list of property keys from the "Instrument" domain to decorate onto              the results. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfA2BDataRecord"""
        return self.__client.get_a2_b_data(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_a2_b_data_with_http_info(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """GetA2BData: Get A2B data  # noqa: E501

Get an A2B report for the given portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_a2_b_data_with_http_info(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio to retrieve the A2B report for. (required)
:type scope: str
:param code: The code of the portfolio to retrieve the A2B report for. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version              of each transaction if not specified.
:type as_at: datetime
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param property_keys: A list of property keys from the "Instrument" domain to decorate onto              the results. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfA2BDataRecord, int, HTTPHeaderDict)"""
        return self.__client.get_a2_b_data_with_http_info(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_a2_b_movements(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """GetA2BMovements: Get an A2B report at the movement level for the given portfolio.  # noqa: E501

Get an A2B report at the movement level for the given portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_a2_b_movements(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio to retrieve the A2B movement report for. (required)
:type scope: str
:param code: The code of the portfolio to retrieve the A2B movement report for. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version              of each transaction if not specified.
:type as_at: datetime
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param property_keys: A list of property keys from the "Instrument" domain to decorate onto              the results. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfA2BMovementRecord"""
        return self.__client.get_a2_b_movements(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_a2_b_movements_with_http_info(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """GetA2BMovements: Get an A2B report at the movement level for the given portfolio.  # noqa: E501

Get an A2B report at the movement level for the given portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_a2_b_movements_with_http_info(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the portfolio to retrieve the A2B movement report for. (required)
:type scope: str
:param code: The code of the portfolio to retrieve the A2B movement report for. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version              of each transaction if not specified.
:type as_at: datetime
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param property_keys: A list of property keys from the "Instrument" domain to decorate onto              the results. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name".
:type property_keys: list[str]
:param filter: Expression to filter the result set.              Read more about filtering results from LUSID here https://support.lusid.com/filtering-results-from-lusid.
:type filter: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfA2BMovementRecord, int, HTTPHeaderDict)"""
        return self.__client.get_a2_b_movements_with_http_info(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_bucketed_cash_flows(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetBucketedCashFlows: Get bucketed cash flows from a list of portfolios  # noqa: E501

We bucket/aggregate a transaction portfolio's instruments by date or tenor specified in the request.  The cashflows are grouped by both instrumentId and currency.                If you want transactional level cashflow, please use the 'GetUpsertableCashFlows' endpoint.  If you want instrument cashflow, please use the 'GetPortfolioCashFlows' endpoint.  Note that these endpoints do not apply bucketing.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_bucketed_cash_flows(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param bucketed_cash_flow_request: Request specifying the bucketing of cashflows
:type bucketed_cash_flow_request: BucketedCashFlowRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: BucketedCashFlowResponse"""
        return self.__client.get_bucketed_cash_flows(scope, code, **kwargs)

   def get_bucketed_cash_flows_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetBucketedCashFlows: Get bucketed cash flows from a list of portfolios  # noqa: E501

We bucket/aggregate a transaction portfolio's instruments by date or tenor specified in the request.  The cashflows are grouped by both instrumentId and currency.                If you want transactional level cashflow, please use the 'GetUpsertableCashFlows' endpoint.  If you want instrument cashflow, please use the 'GetPortfolioCashFlows' endpoint.  Note that these endpoints do not apply bucketing.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_bucketed_cash_flows_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies the portfolio. (required)
:type code: str
:param bucketed_cash_flow_request: Request specifying the bucketing of cashflows
:type bucketed_cash_flow_request: BucketedCashFlowRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (BucketedCashFlowResponse, int, HTTPHeaderDict)"""
        return self.__client.get_bucketed_cash_flows_with_http_info(scope, code, **kwargs)

   def get_custodian_account(self, scope: Any, code: Any, custodian_account_scope: Any, custodian_account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetCustodianAccount: Get Custodian Account  # noqa: E501

Retrieve the definition of a particular Custodian Account which is part of a Transaction Portfolios.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custodian_account(scope, code, custodian_account_scope, custodian_account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolio. (required)
:type scope: str
:param code: The code of the Transaction Portfolio. Together with the scope this uniquely identifies the Transaction Portfolio. (required)
:type code: str
:param custodian_account_scope: The scope of the Custodian Account. (required)
:type custodian_account_scope: str
:param custodian_account_code: The code of the Custodian Account. (required)
:type custodian_account_code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Custodian Account properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Custodian Account definition. Defaults to returning the latest version of the Custodian Account definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'CustodianAccount' domain to decorate onto the Custodian Account.              These must take the format {domain}/{scope}/{code}, for example 'CustodianAccount/Manager/Id'. If not provided will return all the entitled properties for that Custodian Account.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustodianAccount"""
        return self.__client.get_custodian_account(scope, code, custodian_account_scope, custodian_account_code, **kwargs)

   def get_custodian_account_with_http_info(self, scope: Any, code: Any, custodian_account_scope: Any, custodian_account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetCustodianAccount: Get Custodian Account  # noqa: E501

Retrieve the definition of a particular Custodian Account which is part of a Transaction Portfolios.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_custodian_account_with_http_info(scope, code, custodian_account_scope, custodian_account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolio. (required)
:type scope: str
:param code: The code of the Transaction Portfolio. Together with the scope this uniquely identifies the Transaction Portfolio. (required)
:type code: str
:param custodian_account_scope: The scope of the Custodian Account. (required)
:type custodian_account_scope: str
:param custodian_account_code: The code of the Custodian Account. (required)
:type custodian_account_code: str
:param effective_at: The effective datetime or cut label at which to retrieve the Custodian Account properties. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the Custodian Account definition. Defaults to returning the latest version of the Custodian Account definition if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the 'CustodianAccount' domain to decorate onto the Custodian Account.              These must take the format {domain}/{scope}/{code}, for example 'CustodianAccount/Manager/Id'. If not provided will return all the entitled properties for that Custodian Account.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustodianAccount, int, HTTPHeaderDict)"""
        return self.__client.get_custodian_account_with_http_info(scope, code, custodian_account_scope, custodian_account_code, **kwargs)

   def get_details(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetDetails: Get details  # noqa: E501

Get certain details associated with a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_details(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the              scope this uniquely identifies the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the details of the transaction              portfolio. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the details of the transaction portfolio. Defaults              to returning the latest version of the details if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioDetails"""
        return self.__client.get_details(scope, code, **kwargs)

   def get_details_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetDetails: Get details  # noqa: E501

Get certain details associated with a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_details_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the              scope this uniquely identifies the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the details of the transaction              portfolio. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the details of the transaction portfolio. Defaults              to returning the latest version of the details if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioDetails, int, HTTPHeaderDict)"""
        return self.__client.get_details_with_http_info(scope, code, **kwargs)

   def get_holding_contributors(self, scope: Any, code: Any, holding_id: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetHoldingContributors: Get Holdings Contributors  # noqa: E501

Lists all transactions that affect the holdings of a portfolio over a given effective interval. This includes  transactions automatically generated by LUSID such as holding adjustments.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holding_contributors(scope, code, holding_id, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param holding_id: The unique holding identifier (required)
:type holding_id: int
:param effective_date: Effective date
:type effective_date: datetime
:param from_trade_date: The from trade date, defaults to first time this holding is opened, lower bound for transactions
:type from_trade_date: datetime
:param to_trade_date: The to trade date upper bound date, defaults to effectiveDate. upper bound for transactions
:type to_trade_date: datetime
:param include_historic: If true, transactions from previously closed holdings are returned.              If false, only transactions from last time position is opened.
:type include_historic: bool
:param tax_lot_id: Constrains the Holding Contributors to those which contributed to the specified tax lot.
:type tax_lot_id: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param as_at: The asAt datetime at which to build the transactions. Defaults to return the latest              version of each transaction if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing transactions from a previous call to GetHoldingContributors.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfHoldingContributor"""
        return self.__client.get_holding_contributors(scope, code, holding_id, **kwargs)

   def get_holding_contributors_with_http_info(self, scope: Any, code: Any, holding_id: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetHoldingContributors: Get Holdings Contributors  # noqa: E501

Lists all transactions that affect the holdings of a portfolio over a given effective interval. This includes  transactions automatically generated by LUSID such as holding adjustments.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holding_contributors_with_http_info(scope, code, holding_id, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param holding_id: The unique holding identifier (required)
:type holding_id: int
:param effective_date: Effective date
:type effective_date: datetime
:param from_trade_date: The from trade date, defaults to first time this holding is opened, lower bound for transactions
:type from_trade_date: datetime
:param to_trade_date: The to trade date upper bound date, defaults to effectiveDate. upper bound for transactions
:type to_trade_date: datetime
:param include_historic: If true, transactions from previously closed holdings are returned.              If false, only transactions from last time position is opened.
:type include_historic: bool
:param tax_lot_id: Constrains the Holding Contributors to those which contributed to the specified tax lot.
:type tax_lot_id: str
:param limit: When paginating, limit the number of returned results to this many. Defaults to 100 if not specified.
:type limit: int
:param as_at: The asAt datetime at which to build the transactions. Defaults to return the latest              version of each transaction if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing transactions from a previous call to GetHoldingContributors.
:type page: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfHoldingContributor, int, HTTPHeaderDict)"""
        return self.__client.get_holding_contributors_with_http_info(scope, code, holding_id, **kwargs)

   def get_holdings(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetHoldings: Get holdings  # noqa: E501

Calculate holdings for a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the holdings of the transaction              portfolio. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings of the transaction portfolio. Defaults              to return the latest version if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to filter on the Holding Type, use "holdingType eq 'p'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Holding", "Custodian Account" or "Portfolio" domain to decorate onto              holdings. These must have the format {domain}/{scope}/{code}, for example "Instrument/system/Name" or "Holding/system/Cost".
:type property_keys: list[str]
:param by_taxlots: Whether or not to expand the holdings to return the underlying tax-lots. Defaults to              False.
:type by_taxlots: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfPortfolioHolding"""
        return self.__client.get_holdings(scope, code, **kwargs)

   def get_holdings_adjustment(self, scope: Any, code: Any, effective_at: Any, **kwargs) -> 'Any':
        """GetHoldingsAdjustment: Get holdings adjustment  # noqa: E501

Get a holdings adjustment made to a transaction portfolio at a specific effective datetime. Note that a  holdings adjustment will only be returned if one exists for the specified effective datetime.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_adjustment(scope, code, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label of the holdings adjustment. (required)
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings adjustment. Defaults to the return the latest              version of the holdings adjustment if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the ‘Instrument' domain to decorate onto holdings adjustments.              These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.              Note that properties from the 'Holding’ domain are automatically returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: HoldingsAdjustment"""
        return self.__client.get_holdings_adjustment(scope, code, effective_at, **kwargs)

   def get_holdings_adjustment_with_http_info(self, scope: Any, code: Any, effective_at: Any, **kwargs) -> 'Any':
        """GetHoldingsAdjustment: Get holdings adjustment  # noqa: E501

Get a holdings adjustment made to a transaction portfolio at a specific effective datetime. Note that a  holdings adjustment will only be returned if one exists for the specified effective datetime.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_adjustment_with_http_info(scope, code, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label of the holdings adjustment. (required)
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings adjustment. Defaults to the return the latest              version of the holdings adjustment if not specified.
:type as_at: datetime
:param property_keys: A list of property keys from the ‘Instrument' domain to decorate onto holdings adjustments.              These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name'.              Note that properties from the 'Holding’ domain are automatically returned.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (HoldingsAdjustment, int, HTTPHeaderDict)"""
        return self.__client.get_holdings_adjustment_with_http_info(scope, code, effective_at, **kwargs)

   def get_holdings_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetHoldings: Get holdings  # noqa: E501

Calculate holdings for a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the holdings of the transaction              portfolio. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings of the transaction portfolio. Defaults              to return the latest version if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to filter on the Holding Type, use "holdingType eq 'p'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Holding", "Custodian Account" or "Portfolio" domain to decorate onto              holdings. These must have the format {domain}/{scope}/{code}, for example "Instrument/system/Name" or "Holding/system/Cost".
:type property_keys: list[str]
:param by_taxlots: Whether or not to expand the holdings to return the underlying tax-lots. Defaults to              False.
:type by_taxlots: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfPortfolioHolding, int, HTTPHeaderDict)"""
        return self.__client.get_holdings_with_http_info(scope, code, **kwargs)

   def get_holdings_with_orders(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetHoldingsWithOrders: Get holdings with orders  # noqa: E501

Get the holdings of a transaction portfolio. Create virtual holdings for any outstanding orders,  and account for order state/fulfillment; that is, treat outstanding orders (and related records) as  if they had been realised at moment of query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_with_orders(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the holdings of the transaction              portfolio. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings of the transaction portfolio. Defaults              to return the latest version of the holdings if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to filter on the Holding Type, use "holdingType eq 'p'"              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Holding" or "Portfolio" domain to decorate onto              the holdings. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or "Holding/system/Cost".
:type property_keys: list[str]
:param by_taxlots: Whether or not to expand the holdings to return the underlying tax-lots. Defaults to              False.
:type by_taxlots: bool
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListWithWarningsOfPortfolioHolding"""
        return self.__client.get_holdings_with_orders(scope, code, **kwargs)

   def get_holdings_with_orders_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] GetHoldingsWithOrders: Get holdings with orders  # noqa: E501

Get the holdings of a transaction portfolio. Create virtual holdings for any outstanding orders,  and account for order state/fulfillment; that is, treat outstanding orders (and related records) as  if they had been realised at moment of query.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_holdings_with_orders_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to retrieve the holdings of the transaction              portfolio. Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings of the transaction portfolio. Defaults              to return the latest version of the holdings if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to filter on the Holding Type, use "holdingType eq 'p'"              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the "Instrument", "Holding" or "Portfolio" domain to decorate onto              the holdings. These take the format {domain}/{scope}/{code} e.g. "Instrument/system/Name" or "Holding/system/Cost".
:type property_keys: list[str]
:param by_taxlots: Whether or not to expand the holdings to return the underlying tax-lots. Defaults to              False.
:type by_taxlots: bool
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeId
:type recipe_id_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListWithWarningsOfPortfolioHolding, int, HTTPHeaderDict)"""
        return self.__client.get_holdings_with_orders_with_http_info(scope, code, **kwargs)

   def get_portfolio_cash_flows(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetPortfolioCashFlows: Get portfolio cash flows  # noqa: E501

Get the set of cash flows that occur in a window for the transaction portfolio's instruments.                Note that grouping can affect the quantity of information returned; where a holding is an amalgamation of one or more (e.g. cash) instruments, a unique  transaction identifier will not be available. The same may go for diagnostic information (e.g. multiple sources of an aggregate cash amount on a date that is  not split out. Grouping at the transaction and instrument level is recommended for those seeking to attribute individual flows.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_cash_flows(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this               uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today.
:type effective_at: str
:param window_start: The lower bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               There is no lower bound if this is not specified. i.e. it is the minimum date.
:type window_start: str
:param window_end: The upper bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               The upper bound defaults to 'max date' if it is not specified
:type window_end: str
:param as_at: The asAt datetime at which to retrieve the data. Defaults to returning the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".               For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param exclude_unsettled_trades: If absent or set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results. If set to true, unsettled trades will be excluded from the result set.
:type exclude_unsettled_trades: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfInstrumentCashFlow"""
        return self.__client.get_portfolio_cash_flows(scope, code, **kwargs)

   def get_portfolio_cash_flows_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetPortfolioCashFlows: Get portfolio cash flows  # noqa: E501

Get the set of cash flows that occur in a window for the transaction portfolio's instruments.                Note that grouping can affect the quantity of information returned; where a holding is an amalgamation of one or more (e.g. cash) instruments, a unique  transaction identifier will not be available. The same may go for diagnostic information (e.g. multiple sources of an aggregate cash amount on a date that is  not split out. Grouping at the transaction and instrument level is recommended for those seeking to attribute individual flows.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_cash_flows_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this               uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today.
:type effective_at: str
:param window_start: The lower bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               There is no lower bound if this is not specified. i.e. it is the minimum date.
:type window_start: str
:param window_end: The upper bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               The upper bound defaults to 'max date' if it is not specified
:type window_end: str
:param as_at: The asAt datetime at which to retrieve the data. Defaults to returning the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".               For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param exclude_unsettled_trades: If absent or set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results. If set to true, unsettled trades will be excluded from the result set.
:type exclude_unsettled_trades: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfInstrumentCashFlow, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_cash_flows_with_http_info(scope, code, **kwargs)

   def get_portfolio_cash_ladder(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, effective_at: Any, **kwargs) -> 'Any':
        """GetPortfolioCashLadder: Get portfolio cash ladder  # noqa: E501

Get a cash ladder for a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_cash_ladder(scope, code, from_effective_at, to_effective_at, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param effective_at: The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today. (required)
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to returning the latest version              of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param exclude_unsettled_trades: If absent or set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results. If set to true, unsettled trades will be excluded from the result set.
:type exclude_unsettled_trades: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPortfolioCashLadder"""
        return self.__client.get_portfolio_cash_ladder(scope, code, from_effective_at, to_effective_at, effective_at, **kwargs)

   def get_portfolio_cash_ladder_with_http_info(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, effective_at: Any, **kwargs) -> 'Any':
        """GetPortfolioCashLadder: Get portfolio cash ladder  # noqa: E501

Get a cash ladder for a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_cash_ladder_with_http_info(scope, code, from_effective_at, to_effective_at, effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param effective_at: The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today. (required)
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to returning the latest version              of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param exclude_unsettled_trades: If absent or set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results. If set to true, unsettled trades will be excluded from the result set.
:type exclude_unsettled_trades: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPortfolioCashLadder, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_cash_ladder_with_http_info(scope, code, from_effective_at, to_effective_at, effective_at, **kwargs)

   def get_portfolio_cash_statement(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """GetPortfolioCashStatement: Get portfolio cash statement  # noqa: E501

Get a cash statement for a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_cash_statement(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to returning the latest version              of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfPortfolioCashFlow"""
        return self.__client.get_portfolio_cash_statement(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_portfolio_cash_statement_with_http_info(self, scope: Any, code: Any, from_effective_at: Any, to_effective_at: Any, **kwargs) -> 'Any':
        """GetPortfolioCashStatement: Get portfolio cash statement  # noqa: E501

Get a cash statement for a transaction portfolio.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_portfolio_cash_statement_with_http_info(scope, code, from_effective_at, to_effective_at, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this              uniquely identifies the portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified. (required)
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no upper bound if this is not specified. (required)
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to returning the latest version              of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.              For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".              For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfPortfolioCashFlow, int, HTTPHeaderDict)"""
        return self.__client.get_portfolio_cash_statement_with_http_info(scope, code, from_effective_at, to_effective_at, **kwargs)

   def get_transaction_history(self, scope: Any, code: Any, transaction_id: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetTransactionHistory: Get the history of a transaction  # noqa: E501

Get all of the changes that have happened to a transaction.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_history(scope, code, transaction_id, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_id: The unique ID of the transaction to create or update. (required)
:type transaction_id: str
:param as_at: The asAt datetime at which to retrieve the history of the transaction. Defaults              to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfChangeHistory"""
        return self.__client.get_transaction_history(scope, code, transaction_id, **kwargs)

   def get_transaction_history_with_http_info(self, scope: Any, code: Any, transaction_id: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] GetTransactionHistory: Get the history of a transaction  # noqa: E501

Get all of the changes that have happened to a transaction.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transaction_history_with_http_info(scope, code, transaction_id, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_id: The unique ID of the transaction to create or update. (required)
:type transaction_id: str
:param as_at: The asAt datetime at which to retrieve the history of the transaction. Defaults              to return the latest version if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfChangeHistory, int, HTTPHeaderDict)"""
        return self.__client.get_transaction_history_with_http_info(scope, code, transaction_id, **kwargs)

   def get_transactions(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetTransactions: Get transactions  # noqa: E501

Retrieve all the transactions that occurred during a particular time interval.                If the portfolio is a derived transaction portfolio, the transactions returned are the  union set of all transactions of the parent (and any grandparents, etc.) as well as  those of the derived transaction portfolio itself.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transactions(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies               the transaction portfolio. (required)
:type code: str
:param from_transaction_date: The lower bound effective datetime or cut label (inclusive) from which to retrieve transactions.               There is no lower bound if this is not specified.
:type from_transaction_date: str
:param to_transaction_date: The upper bound effective datetime or cut label (inclusive) from which to retrieve transactions.               There is no upper bound if this is not specified.
:type to_transaction_date: str
:param as_at: The asAt datetime at which to retrieve transactions. Defaults to returning the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression with which to filter the result set.               For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'"               For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'Instrument', 'Transaction', "LegalEntity" or "CustodianAccount" domain to decorate onto               transactions. These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name' or               'Transaction/strategy/quantsignal'.
:type property_keys: list[str]
:param page: The pagination token to use to continue listing transactions from a previous call to GetTransactions.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. The current behaviour is               to return all transactions if possible, but this will change to defaulting to 1000 if not specified in the future. It is recommended               to populate this field to enable pagination.
:type limit: int
:param show_cancelled_transactions: Option to specify whether or not to include cancelled transactions,               including previous versions of transactions which have since been amended.               Defaults to False if not specified.
:type show_cancelled_transactions: bool
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: VersionedResourceListOfTransaction"""
        return self.__client.get_transactions(scope, code, **kwargs)

   def get_transactions_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """GetTransactions: Get transactions  # noqa: E501

Retrieve all the transactions that occurred during a particular time interval.                If the portfolio is a derived transaction portfolio, the transactions returned are the  union set of all transactions of the parent (and any grandparents, etc.) as well as  those of the derived transaction portfolio itself.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_transactions_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies               the transaction portfolio. (required)
:type code: str
:param from_transaction_date: The lower bound effective datetime or cut label (inclusive) from which to retrieve transactions.               There is no lower bound if this is not specified.
:type from_transaction_date: str
:param to_transaction_date: The upper bound effective datetime or cut label (inclusive) from which to retrieve transactions.               There is no upper bound if this is not specified.
:type to_transaction_date: str
:param as_at: The asAt datetime at which to retrieve transactions. Defaults to returning the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression with which to filter the result set.               For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'"               For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'Instrument', 'Transaction', "LegalEntity" or "CustodianAccount" domain to decorate onto               transactions. These must have the format {domain}/{scope}/{code}, for example 'Instrument/system/Name' or               'Transaction/strategy/quantsignal'.
:type property_keys: list[str]
:param page: The pagination token to use to continue listing transactions from a previous call to GetTransactions.
:type page: str
:param limit: When paginating, limit the number of returned results to this many. The current behaviour is               to return all transactions if possible, but this will change to defaulting to 1000 if not specified in the future. It is recommended               to populate this field to enable pagination.
:type limit: int
:param show_cancelled_transactions: Option to specify whether or not to include cancelled transactions,               including previous versions of transactions which have since been amended.               Defaults to False if not specified.
:type show_cancelled_transactions: bool
:param sort_by: A list of field names or properties to sort by, each suffixed by " ASC" or " DESC".
:type sort_by: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (VersionedResourceListOfTransaction, int, HTTPHeaderDict)"""
        return self.__client.get_transactions_with_http_info(scope, code, **kwargs)

   def get_upsertable_portfolio_cash_flows(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetUpsertablePortfolioCashFlows: Get upsertable portfolio cash flows.  # noqa: E501

Get the set of cash flows that occur in a window for the given portfolio instruments as a set of upsertable transactions (DTOs).                Note that grouping can affect the quantity of information returned; where a holding is an amalgamation of one or more (e.g. cash) instruments, a unique  transaction identifier will not be available. The same may go for diagnostic information (e.g. multiple sources of an aggregate cash amount on a date that is  not split out. Grouping at the transaction and instrument level is recommended for those seeking to attribute individual flows.                In essence this is identical to the 'GetCashFlows' endpoint but returns the cash flows as a set of transactions suitable for directly putting back into LUSID.  There are a couple of important points:  (1) Internally it can not be fully known where the user wishes to insert these transactions, e.g. portfolio and movement type.      These are therefore defaulted to a sensible option; the user will likely need to change these.  (2) Similarly, knowledge of any properties the user might wish to add to a transaction are unknown and consequently left empty.  (3) The transaction id that is added is simply a concatenation of the original transaction id, instrument id and payment date and direction. The user can happily override this.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_upsertable_portfolio_cash_flows(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this               uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today.
:type effective_at: str
:param window_start: The lower bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               There is no lower bound if this is not specified. i.e. uses minimum date-time
:type window_start: str
:param window_end: The upper bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               The upper bound defaults to 'max date' if it is not specified
:type window_end: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".               For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param exclude_unsettled_trades: If absent or set to true, unsettled trades will be excluded from the result set. If set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results.
:type exclude_unsettled_trades: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfTransaction"""
        return self.__client.get_upsertable_portfolio_cash_flows(scope, code, **kwargs)

   def get_upsertable_portfolio_cash_flows_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[BETA] GetUpsertablePortfolioCashFlows: Get upsertable portfolio cash flows.  # noqa: E501

Get the set of cash flows that occur in a window for the given portfolio instruments as a set of upsertable transactions (DTOs).                Note that grouping can affect the quantity of information returned; where a holding is an amalgamation of one or more (e.g. cash) instruments, a unique  transaction identifier will not be available. The same may go for diagnostic information (e.g. multiple sources of an aggregate cash amount on a date that is  not split out. Grouping at the transaction and instrument level is recommended for those seeking to attribute individual flows.                In essence this is identical to the 'GetCashFlows' endpoint but returns the cash flows as a set of transactions suitable for directly putting back into LUSID.  There are a couple of important points:  (1) Internally it can not be fully known where the user wishes to insert these transactions, e.g. portfolio and movement type.      These are therefore defaulted to a sensible option; the user will likely need to change these.  (2) Similarly, knowledge of any properties the user might wish to add to a transaction are unknown and consequently left empty.  (3) The transaction id that is added is simply a concatenation of the original transaction id, instrument id and payment date and direction. The user can happily override this.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.get_upsertable_portfolio_cash_flows_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this               uniquely identifies the portfolio. (required)
:type code: str
:param effective_at: The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today.
:type effective_at: str
:param window_start: The lower bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               There is no lower bound if this is not specified. i.e. uses minimum date-time
:type window_start: str
:param window_end: The upper bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.               The upper bound defaults to 'max date' if it is not specified
:type window_end: str
:param as_at: The asAt datetime at which to retrieve the portfolio. Defaults to return the latest version               of each transaction if not specified.
:type as_at: datetime
:param filter: Expression to filter the result set.               For example, to return only transactions with a transaction type of 'Buy', specify "type eq 'Buy'".               For more information about filtering LUSID results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param recipe_id_scope: The scope of the given recipeId
:type recipe_id_scope: str
:param recipe_id_code: The code of the given recipeID
:type recipe_id_code: str
:param exclude_unsettled_trades: If absent or set to true, unsettled trades will be excluded from the result set. If set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results.
:type exclude_unsettled_trades: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfTransaction, int, HTTPHeaderDict)"""
        return self.__client.get_upsertable_portfolio_cash_flows_with_http_info(scope, code, **kwargs)

   def list_custodian_accounts(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListCustodianAccounts: List Custodian Accounts  # noqa: E501

List the custodian accounts in a Transaction Portfolios  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custodian_accounts(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolio. (required)
:type scope: str
:param code: The code of the Transaction Portfolio. Together with the scope this uniquely identifies              the Transaction Portfolios. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties decorated on Custodian Accounts. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing custodian accounts; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Custodian Account type, specify "code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'CustodianAccount' domain to decorate onto the Custodian Account.              These must have the format {domain}/{scope}/{code}, for example 'CustodianAccount/system/Name'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PagedResourceListOfCustodianAccount"""
        return self.__client.list_custodian_accounts(scope, code, **kwargs)

   def list_custodian_accounts_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] ListCustodianAccounts: List Custodian Accounts  # noqa: E501

List the custodian accounts in a Transaction Portfolios  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_custodian_accounts_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolio. (required)
:type scope: str
:param code: The code of the Transaction Portfolio. Together with the scope this uniquely identifies              the Transaction Portfolios. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which to list the TimeVariant properties decorated on Custodian Accounts. Defaults to the current LUSID              system datetime if not specified.
:type effective_at: str
:param as_at: The asAt datetime at which to retrieve the instrument. Defaults to              returning the latest version if not specified.
:type as_at: datetime
:param page: The pagination token to use to continue listing custodian accounts; this              value is returned from the previous call. If a pagination token is provided, the filter, effectiveAt              and asAt fields must not have changed since the original request.
:type page: str
:param limit: When paginating, limit the results to this number. Defaults to 100 if not specified.
:type limit: int
:param filter: Expression to filter the results.              For example, to filter on the Custodian Account type, specify "code eq '001'". For more information about filtering              results, see https://support.lusid.com/knowledgebase/article/KA-01914.
:type filter: str
:param property_keys: A list of property keys from the 'CustodianAccount' domain to decorate onto the Custodian Account.              These must have the format {domain}/{scope}/{code}, for example 'CustodianAccount/system/Name'.
:type property_keys: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PagedResourceListOfCustodianAccount, int, HTTPHeaderDict)"""
        return self.__client.list_custodian_accounts_with_http_info(scope, code, **kwargs)

   def list_holdings_adjustments(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """ListHoldingsAdjustments: List holdings adjustments  # noqa: E501

List the holdings adjustments made to the specified transaction portfolio over a specified interval of effective time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_holdings_adjustments(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the holdings              adjustments. There is no lower bound if this is not specified.
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the holdings              adjustments. There is no upper bound if this is not specified.
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings adjustments. Defaults to return the              latest version of each holding adjustment if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: ResourceListOfHoldingsAdjustmentHeader"""
        return self.__client.list_holdings_adjustments(scope, code, **kwargs)

   def list_holdings_adjustments_with_http_info(self, scope: Any, code: Any, **kwargs) -> 'Any':
        """ListHoldingsAdjustments: List holdings adjustments  # noqa: E501

List the holdings adjustments made to the specified transaction portfolio over a specified interval of effective time.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.list_holdings_adjustments_with_http_info(scope, code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the holdings              adjustments. There is no lower bound if this is not specified.
:type from_effective_at: str
:param to_effective_at: The upper bound effective datetime or cut label (inclusive) from which to retrieve the holdings              adjustments. There is no upper bound if this is not specified.
:type to_effective_at: str
:param as_at: The asAt datetime at which to retrieve the holdings adjustments. Defaults to return the              latest version of each holding adjustment if not specified.
:type as_at: datetime
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (ResourceListOfHoldingsAdjustmentHeader, int, HTTPHeaderDict)"""
        return self.__client.list_holdings_adjustments_with_http_info(scope, code, **kwargs)

   def patch_portfolio_details(self, scope: Any, code: Any, operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolioDetails: Patch portfolio details  # noqa: E501

Create or update certain details for a particular transaction portfolio.  The behaviour is defined by the JSON Patch specification.                Note that not all elements of a transaction portfolio definition are  modifiable once it has been created due to the potential implications for data already stored.  Currently supported properties are: SubHoldingKeys, BaseCurrency, AmortisationMethod  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_details(scope, code, operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the               scope this uniquely identifies the transaction portfolio. (required)
:type code: str
:param operation: The patch document. (required)
:type operation: list[Operation]
:param effective_at: The effective datetime or cut label at which the updated or inserted details should become valid.               Defaults to the current LUSID system datetime if not specified.               Note that this will affect all bitemporal entities in the request, but will not be used for any perpetual entities.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioDetails"""
        return self.__client.patch_portfolio_details(scope, code, operation, **kwargs)

   def patch_portfolio_details_with_http_info(self, scope: Any, code: Any, operation: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] PatchPortfolioDetails: Patch portfolio details  # noqa: E501

Create or update certain details for a particular transaction portfolio.  The behaviour is defined by the JSON Patch specification.                Note that not all elements of a transaction portfolio definition are  modifiable once it has been created due to the potential implications for data already stored.  Currently supported properties are: SubHoldingKeys, BaseCurrency, AmortisationMethod  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.patch_portfolio_details_with_http_info(scope, code, operation, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the               scope this uniquely identifies the transaction portfolio. (required)
:type code: str
:param operation: The patch document. (required)
:type operation: list[Operation]
:param effective_at: The effective datetime or cut label at which the updated or inserted details should become valid.               Defaults to the current LUSID system datetime if not specified.               Note that this will affect all bitemporal entities in the request, but will not be used for any perpetual entities.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioDetails, int, HTTPHeaderDict)"""
        return self.__client.patch_portfolio_details_with_http_info(scope, code, operation, **kwargs)

   def resolve_instrument(self, scope: Any, code: Any, instrument_identifier_type: Any, instrument_identifier_value: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ResolveInstrument: Resolve instrument  # noqa: E501

Try to resolve the instrument for transaction and holdings for a given instrument identifier and a specified  period of time. Also update the instrument identifiers with the given instrument identifiers collection.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.resolve_instrument(scope, code, instrument_identifier_type, instrument_identifier_value, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param instrument_identifier_type: The instrument identifier type. (required)
:type instrument_identifier_type: str
:param instrument_identifier_value: The value for the given instrument identifier. (required)
:type instrument_identifier_value: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified.
:type from_effective_at: str
:param re_resolve: When set to true, instrument resolution will be attempted for all transactions and holdings for the given identifier and date range.              When set to false (default behaviour), instrument resolution will only be attempted for those transactions and holdings that were previously unresolved.
:type re_resolve: bool
:param request_body: The dictionary with the instrument identifiers to be updated on the             transaction and holdings.
:type request_body: dict(str, str)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertPortfolioTransactionsResponse"""
        return self.__client.resolve_instrument(scope, code, instrument_identifier_type, instrument_identifier_value, **kwargs)

   def resolve_instrument_with_http_info(self, scope: Any, code: Any, instrument_identifier_type: Any, instrument_identifier_value: Any, **kwargs) -> 'Any':
        """[EARLY ACCESS] ResolveInstrument: Resolve instrument  # noqa: E501

Try to resolve the instrument for transaction and holdings for a given instrument identifier and a specified  period of time. Also update the instrument identifiers with the given instrument identifiers collection.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.resolve_instrument_with_http_info(scope, code, instrument_identifier_type, instrument_identifier_value, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param instrument_identifier_type: The instrument identifier type. (required)
:type instrument_identifier_type: str
:param instrument_identifier_value: The value for the given instrument identifier. (required)
:type instrument_identifier_value: str
:param from_effective_at: The lower bound effective datetime or cut label (inclusive) from which to retrieve the data.              There is no lower bound if this is not specified.
:type from_effective_at: str
:param re_resolve: When set to true, instrument resolution will be attempted for all transactions and holdings for the given identifier and date range.              When set to false (default behaviour), instrument resolution will only be attempted for those transactions and holdings that were previously unresolved.
:type re_resolve: bool
:param request_body: The dictionary with the instrument identifiers to be updated on the             transaction and holdings.
:type request_body: dict(str, str)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertPortfolioTransactionsResponse, int, HTTPHeaderDict)"""
        return self.__client.resolve_instrument_with_http_info(scope, code, instrument_identifier_type, instrument_identifier_value, **kwargs)

   def set_holdings(self, scope: Any, code: Any, effective_at: Any, adjust_holding_request: Any, **kwargs) -> 'Any':
        """SetHoldings: Set holdings  # noqa: E501

Set the holdings of the specified transaction portfolio to the provided targets. LUSID will automatically  construct adjustment transactions to ensure that the entire set of holdings for the transaction portfolio  are always set to the provided targets for the specified effective datetime. Read more about the difference between  adjusting and setting holdings here https://support.lusid.com/how-do-i-adjust-my-holdings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_holdings(scope, code, effective_at, adjust_holding_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which the holdings should be set to the provided targets. (required)
:type effective_at: str
:param adjust_holding_request: The complete set of target holdings for the transaction portfolio. (required)
:type adjust_holding_request: list[AdjustHoldingRequest]
:param reconciliation_methods: Optional parameter for specifying a reconciliation method: e.g. FxForward.
:type reconciliation_methods: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: AdjustHolding"""
        return self.__client.set_holdings(scope, code, effective_at, adjust_holding_request, **kwargs)

   def set_holdings_with_http_info(self, scope: Any, code: Any, effective_at: Any, adjust_holding_request: Any, **kwargs) -> 'Any':
        """SetHoldings: Set holdings  # noqa: E501

Set the holdings of the specified transaction portfolio to the provided targets. LUSID will automatically  construct adjustment transactions to ensure that the entire set of holdings for the transaction portfolio  are always set to the provided targets for the specified effective datetime. Read more about the difference between  adjusting and setting holdings here https://support.lusid.com/how-do-i-adjust-my-holdings.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.set_holdings_with_http_info(scope, code, effective_at, adjust_holding_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param effective_at: The effective datetime or cut label at which the holdings should be set to the provided targets. (required)
:type effective_at: str
:param adjust_holding_request: The complete set of target holdings for the transaction portfolio. (required)
:type adjust_holding_request: list[AdjustHoldingRequest]
:param reconciliation_methods: Optional parameter for specifying a reconciliation method: e.g. FxForward.
:type reconciliation_methods: list[str]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (AdjustHolding, int, HTTPHeaderDict)"""
        return self.__client.set_holdings_with_http_info(scope, code, effective_at, adjust_holding_request, **kwargs)

   def upsert_custodian_accounts(self, scope: Any, code: Any, custodian_account_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertCustodianAccounts: Upsert Custodian Accounts  # noqa: E501

Create or update Custodian Accounts in the Transaction Portfolios. A Custodian Account will be updated  if it already exists and created if it does not.  The batch limit per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custodian_accounts(scope, code, custodian_account_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolio. (required)
:type scope: str
:param code: The code of the Transaction Portfolio. Together with the scope this uniquely identifies              the Transaction Portfolios. (required)
:type code: str
:param custodian_account_request: A list of Custodian Accounts to be created or updated. (required)
:type custodian_account_request: list[CustodianAccountRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustodianAccountsUpsertResponse"""
        return self.__client.upsert_custodian_accounts(scope, code, custodian_account_request, **kwargs)

   def upsert_custodian_accounts_properties(self, scope: Any, code: Any, custodian_account_scope: Any, custodian_account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertCustodianAccountsProperties: Upsert custodian accounts properties  # noqa: E501

Update or insert one or more properties onto a single custodian account. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'CustodianAccount'.                Upserting a property that exists for a Transaction Portfolios, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custodian_accounts_properties(scope, code, custodian_account_scope, custodian_account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolios to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Transaction Portfolios to update or insert the properties onto. Together with the scope this uniquely identifies the Transaction Portfolios. (required)
:type code: str
:param custodian_account_scope: The scope of the Custodian Account to update or insert the properties onto. (required)
:type custodian_account_scope: str
:param custodian_account_code: The unique ID of the custodian account to create or update properties for. (required)
:type custodian_account_code: str
:param request_body: The properties to be updated or inserted onto the Transaction Portfolio. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "CustodianAccount/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: CustodianAccountProperties"""
        return self.__client.upsert_custodian_accounts_properties(scope, code, custodian_account_scope, custodian_account_code, **kwargs)

   def upsert_custodian_accounts_properties_with_http_info(self, scope: Any, code: Any, custodian_account_scope: Any, custodian_account_code: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertCustodianAccountsProperties: Upsert custodian accounts properties  # noqa: E501

Update or insert one or more properties onto a single custodian account. A property will be updated if it  already exists and inserted if it does not. All properties must be of the domain 'CustodianAccount'.                Upserting a property that exists for a Transaction Portfolios, with a null value, will delete the instance of the property for that group.                Properties have an <i>effectiveFrom</i> datetime for which the property is valid, and an <i>effectiveUntil</i>  datetime until which the property is valid. Not supplying an <i>effectiveUntil</i> datetime results in the property being  valid indefinitely, or until the next <i>effectiveFrom</i> datetime of the property.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custodian_accounts_properties_with_http_info(scope, code, custodian_account_scope, custodian_account_code, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolios to update or insert the properties onto. (required)
:type scope: str
:param code: The code of the Transaction Portfolios to update or insert the properties onto. Together with the scope this uniquely identifies the Transaction Portfolios. (required)
:type code: str
:param custodian_account_scope: The scope of the Custodian Account to update or insert the properties onto. (required)
:type custodian_account_scope: str
:param custodian_account_code: The unique ID of the custodian account to create or update properties for. (required)
:type custodian_account_code: str
:param request_body: The properties to be updated or inserted onto the Transaction Portfolio. Each property in               the request must be keyed by its unique property key. This has the format {domain}/{scope}/{code} e.g. "CustodianAccount/Manager/Id".
:type request_body: dict(str, ModelProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustodianAccountProperties, int, HTTPHeaderDict)"""
        return self.__client.upsert_custodian_accounts_properties_with_http_info(scope, code, custodian_account_scope, custodian_account_code, **kwargs)

   def upsert_custodian_accounts_with_http_info(self, scope: Any, code: Any, custodian_account_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] UpsertCustodianAccounts: Upsert Custodian Accounts  # noqa: E501

Create or update Custodian Accounts in the Transaction Portfolios. A Custodian Account will be updated  if it already exists and created if it does not.  The batch limit per request is 2,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_custodian_accounts_with_http_info(scope, code, custodian_account_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the Transaction Portfolio. (required)
:type scope: str
:param code: The code of the Transaction Portfolio. Together with the scope this uniquely identifies              the Transaction Portfolios. (required)
:type code: str
:param custodian_account_request: A list of Custodian Accounts to be created or updated. (required)
:type custodian_account_request: list[CustodianAccountRequest]
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (CustodianAccountsUpsertResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_custodian_accounts_with_http_info(scope, code, custodian_account_request, **kwargs)

   def upsert_portfolio_details(self, scope: Any, code: Any, create_portfolio_details: Any, **kwargs) -> 'Any':
        """UpsertPortfolioDetails: Upsert portfolio details  # noqa: E501

Create or update certain details for a particular transaction portfolio. The details are updated if they already exist, and inserted if they do not.                Note that not all elements of a transaction portfolio definition are  modifiable once it has been created due to the potential implications for data already stored.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_details(scope, code, create_portfolio_details, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the               scope this uniquely identifies the transaction portfolio. (required)
:type code: str
:param create_portfolio_details: The details to create or update for the specified transaction portfolio. (required)
:type create_portfolio_details: CreatePortfolioDetails
:param effective_at: The effective datetime or cut label at which the updated or inserted details should become valid.               Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: PortfolioDetails"""
        return self.__client.upsert_portfolio_details(scope, code, create_portfolio_details, **kwargs)

   def upsert_portfolio_details_with_http_info(self, scope: Any, code: Any, create_portfolio_details: Any, **kwargs) -> 'Any':
        """UpsertPortfolioDetails: Upsert portfolio details  # noqa: E501

Create or update certain details for a particular transaction portfolio. The details are updated if they already exist, and inserted if they do not.                Note that not all elements of a transaction portfolio definition are  modifiable once it has been created due to the potential implications for data already stored.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_portfolio_details_with_http_info(scope, code, create_portfolio_details, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the               scope this uniquely identifies the transaction portfolio. (required)
:type code: str
:param create_portfolio_details: The details to create or update for the specified transaction portfolio. (required)
:type create_portfolio_details: CreatePortfolioDetails
:param effective_at: The effective datetime or cut label at which the updated or inserted details should become valid.               Defaults to the current LUSID system datetime if not specified.
:type effective_at: str
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (PortfolioDetails, int, HTTPHeaderDict)"""
        return self.__client.upsert_portfolio_details_with_http_info(scope, code, create_portfolio_details, **kwargs)

   def upsert_transaction_properties(self, scope: Any, code: Any, transaction_id: Any, request_body: Any, **kwargs) -> 'Any':
        """UpsertTransactionProperties: Upsert transaction properties  # noqa: E501

Create or update one or more transaction properties for a single transaction in the transaction portfolio.  Each property will be updated if it already exists and created if it does not.  Both transaction and portfolio must exist at the time when properties are created or updated.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_transaction_properties(scope, code, transaction_id, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_id: The unique ID of the transaction to create or update properties for. (required)
:type transaction_id: str
:param request_body: The properties and their associated values to create or update. (required)
:type request_body: dict(str, PerpetualProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertTransactionPropertiesResponse"""
        return self.__client.upsert_transaction_properties(scope, code, transaction_id, request_body, **kwargs)

   def upsert_transaction_properties_with_http_info(self, scope: Any, code: Any, transaction_id: Any, request_body: Any, **kwargs) -> 'Any':
        """UpsertTransactionProperties: Upsert transaction properties  # noqa: E501

Create or update one or more transaction properties for a single transaction in the transaction portfolio.  Each property will be updated if it already exists and created if it does not.  Both transaction and portfolio must exist at the time when properties are created or updated.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_transaction_properties_with_http_info(scope, code, transaction_id, request_body, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_id: The unique ID of the transaction to create or update properties for. (required)
:type transaction_id: str
:param request_body: The properties and their associated values to create or update. (required)
:type request_body: dict(str, PerpetualProperty)
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertTransactionPropertiesResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_transaction_properties_with_http_info(scope, code, transaction_id, request_body, **kwargs)

   def upsert_transactions(self, scope: Any, code: Any, transaction_request: Any, **kwargs) -> 'Any':
        """UpsertTransactions: Upsert transactions  # noqa: E501

Create or update transactions in the transaction portfolio. A transaction will be updated  if it already exists and created if it does not.  The maximum number of transactions that this method can upsert per request is 10,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_transactions(scope, code, transaction_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_request: A list of transactions to be created or updated. (required)
:type transaction_request: list[TransactionRequest]
:param preserve_properties: If set to false, the entire property set will be overwritten by the provided properties. If not specified or set to true, only the properties provided will be updated.
:type preserve_properties: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: UpsertPortfolioTransactionsResponse"""
        return self.__client.upsert_transactions(scope, code, transaction_request, **kwargs)

   def upsert_transactions_with_http_info(self, scope: Any, code: Any, transaction_request: Any, **kwargs) -> 'Any':
        """UpsertTransactions: Upsert transactions  # noqa: E501

Create or update transactions in the transaction portfolio. A transaction will be updated  if it already exists and created if it does not.  The maximum number of transactions that this method can upsert per request is 10,000.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.upsert_transactions_with_http_info(scope, code, transaction_request, async_req=True)
>>> result = thread.get()

:param scope: The scope of the transaction portfolio. (required)
:type scope: str
:param code: The code of the transaction portfolio. Together with the scope this uniquely identifies              the transaction portfolio. (required)
:type code: str
:param transaction_request: A list of transactions to be created or updated. (required)
:type transaction_request: list[TransactionRequest]
:param preserve_properties: If set to false, the entire property set will be overwritten by the provided properties. If not specified or set to true, only the properties provided will be updated.
:type preserve_properties: bool
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (UpsertPortfolioTransactionsResponse, int, HTTPHeaderDict)"""
        return self.__client.upsert_transactions_with_http_info(scope, code, transaction_request, **kwargs)

transaction_portfolios_api = __TransactionPortfoliosApiAuthedAndStubbed()

class __TranslationApiAuthedAndStubbed:
   from lusid.utilities import ApiClientFactory as __ApiClientFactory
   from lusidjam import RefreshingToken as __RefreshingToken
   from typing import Dict, Any
   import os as __os
   __api_factory = __ApiClientFactory(token=__RefreshingToken(), api_secrets_filename=__os.environ.get('FBN_SECRETS_PATH',None), app_name='LusidJupyterNotebook')

   def __init__(self):
       import lusid.api as __api
       self.__client = self.__api_factory.build(__api.TranslationApi)

   def translate_instrument_definitions(self, translate_instrument_definitions_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] TranslateInstrumentDefinitions: Translate instruments  # noqa: E501

Translates one or more instruments into the given target dialect.                In the request each instrument definition should be keyed by a unique correlation id. This id is ephemeral  and is not stored by LUSID. It serves only as a way to easily identify each instrument in the response.                Any instrument that is not already in the LUSID dialect should be given as an ExoticInstrument.                The response will return both the collection of successfully translated instruments in the target dialect,  as well as those that failed.  For the failures a reason will be provided explaining why the instrument could not be updated or inserted.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_instrument_definitions(translate_instrument_definitions_request, async_req=True)
>>> result = thread.get()

:param translate_instrument_definitions_request: The definitions of the instruments to translate along with the target dialect. (required)
:type translate_instrument_definitions_request: TranslateInstrumentDefinitionsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TranslateInstrumentDefinitionsResponse"""
        return self.__client.translate_instrument_definitions(translate_instrument_definitions_request, **kwargs)

   def translate_instrument_definitions_with_http_info(self, translate_instrument_definitions_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] TranslateInstrumentDefinitions: Translate instruments  # noqa: E501

Translates one or more instruments into the given target dialect.                In the request each instrument definition should be keyed by a unique correlation id. This id is ephemeral  and is not stored by LUSID. It serves only as a way to easily identify each instrument in the response.                Any instrument that is not already in the LUSID dialect should be given as an ExoticInstrument.                The response will return both the collection of successfully translated instruments in the target dialect,  as well as those that failed.  For the failures a reason will be provided explaining why the instrument could not be updated or inserted.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_instrument_definitions_with_http_info(translate_instrument_definitions_request, async_req=True)
>>> result = thread.get()

:param translate_instrument_definitions_request: The definitions of the instruments to translate along with the target dialect. (required)
:type translate_instrument_definitions_request: TranslateInstrumentDefinitionsRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TranslateInstrumentDefinitionsResponse, int, HTTPHeaderDict)"""
        return self.__client.translate_instrument_definitions_with_http_info(translate_instrument_definitions_request, **kwargs)

   def translate_trade_tickets(self, translate_trade_ticket_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] TranslateTradeTickets: Translate trade ticket  # noqa: E501

Translates one or more trade tickets into the given target dialect.                In the request each trade ticket definition should be keyed by a unique correlation id. This id is ephemeral  and is not stored by LUSID. It serves only as a way to easily identify each trade ticket in the response.                The response will return both the collection of successfully translated trade tickets in the target dialect,  as well as those that failed.  For the failures a reason will be provided explaining why the trade ticket could not be updated or inserted.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_trade_tickets(translate_trade_ticket_request, async_req=True)
>>> result = thread.get()

:param translate_trade_ticket_request: The definitions of the trade ticket to translate along with the target dialect. (required)
:type translate_trade_ticket_request: TranslateTradeTicketRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:return: Returns the result object.
         If the method is called asynchronously,
         returns the request thread.
:rtype: TranslateTradeTicketsResponse"""
        return self.__client.translate_trade_tickets(translate_trade_ticket_request, **kwargs)

   def translate_trade_tickets_with_http_info(self, translate_trade_ticket_request: Any, **kwargs) -> 'Any':
        """[EXPERIMENTAL] TranslateTradeTickets: Translate trade ticket  # noqa: E501

Translates one or more trade tickets into the given target dialect.                In the request each trade ticket definition should be keyed by a unique correlation id. This id is ephemeral  and is not stored by LUSID. It serves only as a way to easily identify each trade ticket in the response.                The response will return both the collection of successfully translated trade tickets in the target dialect,  as well as those that failed.  For the failures a reason will be provided explaining why the trade ticket could not be updated or inserted.  # noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True

>>> thread = api.translate_trade_tickets_with_http_info(translate_trade_ticket_request, async_req=True)
>>> result = thread.get()

:param translate_trade_ticket_request: The definitions of the trade ticket to translate along with the target dialect. (required)
:type translate_trade_ticket_request: TranslateTradeTicketRequest
:param async_req: Whether to execute the request asynchronously.
:type async_req: bool, optional
:param _return_http_data_only: response data without head status code
                               and headers
:type _return_http_data_only: bool, optional
:param _preload_content: if False, the urllib3.HTTPResponse object will
                         be returned without reading/decoding response
                         data. Default is True.
:type _preload_content: bool, optional
:param _request_timeout: timeout setting for this request. If one
                         number provided, it will be total request
                         timeout. It can also be a pair (tuple) of
                         (connection, read) timeouts.
:param _request_auth: set to override the auth_settings for an a single
                      request; this effectively ignores the authentication
                      in the spec for a single request.
:type _request_auth: dict, optional
:return: Returns the result object, the HTTP status code, and the headers.
         If the method is called asynchronously,
         returns the request thread.
:rtype: (TranslateTradeTicketsResponse, int, HTTPHeaderDict)"""
        return self.__client.translate_trade_tickets_with_http_info(translate_trade_ticket_request, **kwargs)

translation_api = __TranslationApiAuthedAndStubbed()

