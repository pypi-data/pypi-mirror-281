# coding: utf-8

"""
    Collibra Import API

    <p>The Import API is an efficient way to load large volumes of data into the Collibra Data Governance Center. The API can automatically differentiate between creating and updating data.</p>  # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from collibra_import.api_client import ApiClient


class ImportApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def evict_synchronization_cache(self, synchronization_id, **kwargs):  # noqa: E501
        """Removes all cache entries corresponding to the provided synchronization id.  # noqa: E501

        Removes all cache entries corresponding to the provided synchronization <code>id</code>.<p>The synchronization component is optimized to only execute commands that differ from cycle to cycle. Call this method to clear the command cache and force the execution of all commands in this cycle.</p><p>Note: this operation does not stop the tracking of the resources identified by the provided synchronization <code>id</code>. The next synchronization process usingthe same <code>id</code> will still be able to detect resources that should be removed.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evict_synchronization_cache(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id of the operation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.evict_synchronization_cache_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.evict_synchronization_cache_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def evict_synchronization_cache_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Removes all cache entries corresponding to the provided synchronization id.  # noqa: E501

        Removes all cache entries corresponding to the provided synchronization <code>id</code>.<p>The synchronization component is optimized to only execute commands that differ from cycle to cycle. Call this method to clear the command cache and force the execution of all commands in this cycle.</p><p>Note: this operation does not stop the tracking of the resources identified by the provided synchronization <code>id</code>. The next synchronization process usingthe same <code>id</code> will still be able to detect resources that should be removed.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evict_synchronization_cache_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id of the operation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evict_synchronization_cache" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `evict_synchronization_cache`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/evict', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def exists(self, synchronization_id, **kwargs):  # noqa: E501
        """Checks whether given synchronization id already exists.  # noqa: E501

        Checks whether given synchronization <code>id</code> already exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exists(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id of the operation. (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.exists_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.exists_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def exists_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Checks whether given synchronization id already exists.  # noqa: E501

        Checks whether given synchronization <code>id</code> already exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exists_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id of the operation. (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/exists/{synchronizationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_synchronization_infos(self, **kwargs):  # noqa: E501
        """Returns synchronization information matching the given search criteria.  # noqa: E501

        Returns synchronization information matching the given search criteria.<p>Only parameters that are specified in this request and have not <code>null</code> values are used for filtering. All other parameters are ignored.</p><p>The returned synchronization information satisfies all constraints that are specified in this search criteria. By default a result containing 1000 synchronization infos is returned.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_synchronization_infos(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: The first result to retrieve. If not set (offset = <code>0</code>), results will be retrieved starting from row <code>0</code>.
        :param int limit: The maximum number of results to retrieve. If not set (limit = <code>0</code>), the default limit will be used. The maximum allowed limit is 1000.
        :param int count_limit: Allows to limit the number of elements that will be counted. -1 will count everything and 0 will cause the count to be skipped
        :return: PagedResponseSynchronizationInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_synchronization_infos_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_synchronization_infos_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_synchronization_infos_with_http_info(self, **kwargs):  # noqa: E501
        """Returns synchronization information matching the given search criteria.  # noqa: E501

        Returns synchronization information matching the given search criteria.<p>Only parameters that are specified in this request and have not <code>null</code> values are used for filtering. All other parameters are ignored.</p><p>The returned synchronization information satisfies all constraints that are specified in this search criteria. By default a result containing 1000 synchronization infos is returned.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_synchronization_infos_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int offset: The first result to retrieve. If not set (offset = <code>0</code>), results will be retrieved starting from row <code>0</code>.
        :param int limit: The maximum number of results to retrieve. If not set (limit = <code>0</code>), the default limit will be used. The maximum allowed limit is 1000.
        :param int count_limit: Allows to limit the number of elements that will be counted. -1 will count everything and 0 will cause the count to be skipped
        :return: PagedResponseSynchronizationInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['offset', 'limit', 'count_limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_synchronization_infos" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'count_limit' in params:
            query_params.append(('countLimit', params['count_limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseSynchronizationInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_csv_in_job(self, **kwargs):  # noqa: E501
        """Starts import from the CSV file in job (asynchronously).  # noqa: E501

        Starts import from the CSV file in job (asynchronously).  <br/><p>Request can either accept <code>id</code> of the uploaded file that contains CSV input which should be used for import - or the file itself.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_csv_in_job(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str separator:
        :param str quote:
        :param str escape:
        :param bool strict_quotes:
        :param bool ignore_leading_whitespace:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_csv_in_job_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_csv_in_job_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_csv_in_job_with_http_info(self, **kwargs):  # noqa: E501
        """Starts import from the CSV file in job (asynchronously).  # noqa: E501

        Starts import from the CSV file in job (asynchronously).  <br/><p>Request can either accept <code>id</code> of the uploaded file that contains CSV input which should be used for import - or the file itself.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_csv_in_job_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str separator:
        :param str quote:
        :param str escape:
        :param bool strict_quotes:
        :param bool ignore_leading_whitespace:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'separator', 'quote', 'escape', 'strict_quotes', 'ignore_leading_whitespace', 'header_row', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_csv_in_job" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'separator' in params:
            form_params.append(('separator', params['separator']))  # noqa: E501
        if 'quote' in params:
            form_params.append(('quote', params['quote']))  # noqa: E501
        if 'escape' in params:
            form_params.append(('escape', params['escape']))  # noqa: E501
        if 'strict_quotes' in params:
            form_params.append(('strictQuotes', params['strict_quotes']))  # noqa: E501
        if 'ignore_leading_whitespace' in params:
            form_params.append(('ignoreLeadingWhitespace', params['ignore_leading_whitespace']))  # noqa: E501
        if 'header_row' in params:
            form_params.append(('headerRow', params['header_row']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/csv-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_excel_in_job(self, **kwargs):  # noqa: E501
        """Starts import from the Excel file in job (asynchronously).  # noqa: E501

        Starts import from the Excel file in job (asynchronously).  <br/><p>Request can either accept <code>id</code> of the uploaded file that contains Excel input which should be used for import - or the file itself.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_excel_in_job(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str sheet_name:
        :param int sheet_index:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_excel_in_job_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_excel_in_job_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_excel_in_job_with_http_info(self, **kwargs):  # noqa: E501
        """Starts import from the Excel file in job (asynchronously).  # noqa: E501

        Starts import from the Excel file in job (asynchronously).  <br/><p>Request can either accept <code>id</code> of the uploaded file that contains Excel input which should be used for import - or the file itself.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_excel_in_job_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str sheet_name:
        :param int sheet_index:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'sheet_name', 'sheet_index', 'header_row', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_excel_in_job" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'sheet_name' in params:
            form_params.append(('sheetName', params['sheet_name']))  # noqa: E501
        if 'sheet_index' in params:
            form_params.append(('sheetIndex', params['sheet_index']))  # noqa: E501
        if 'header_row' in params:
            form_params.append(('headerRow', params['header_row']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/excel-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_json_in_job(self, **kwargs):  # noqa: E501
        """Starts import from the JSON file in job (asynchronously).  # noqa: E501

        Starts import from the JSON file in job (asynchronously).  <br/><p>Request can either accept <code>id</code> of the uploaded file that contains JSON input which should be used for import - or the file itself.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_json_in_job(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str relations_action:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_json_in_job_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_json_in_job_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_json_in_job_with_http_info(self, **kwargs):  # noqa: E501
        """Starts import from the JSON file in job (asynchronously).  # noqa: E501

        Starts import from the JSON file in job (asynchronously).  <br/><p>Request can either accept <code>id</code> of the uploaded file that contains JSON input which should be used for import - or the file itself.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_json_in_job_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str relations_action:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'relations_action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_json_in_job" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'relations_action' in params:
            form_params.append(('relationsAction', params['relations_action']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/json-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_synchronization(self, synchronization_id, **kwargs):  # noqa: E501
        """Removes all information about synchronization process corresponding to provided synchronization id.  # noqa: E501

        Removes all information about synchronization process corresponding to provided synchronization <code>id</code>.<p>This operation stops tracking of synchronization identified by provided synchronization <code>id</code>. The next synchronization process specified with this <code>id</code> will not be able to detect resources that should be removed.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_synchronization(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id of the operation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_synchronization_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_synchronization_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def remove_synchronization_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Removes all information about synchronization process corresponding to provided synchronization id.  # noqa: E501

        Removes all information about synchronization process corresponding to provided synchronization <code>id</code>.<p>This operation stops tracking of synchronization identified by provided synchronization <code>id</code>. The next synchronization process specified with this <code>id</code> will not be able to detect resources that should be removed.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_synchronization_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id of the operation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_synchronization" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `remove_synchronization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_batch_csv_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts batch synchronization from the CSV file in job (asynchronously).  # noqa: E501

        Starts batch synchronization from the CSV file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains CSV input which should be used for import or the file itself. The input file is treated as a part (batch) of synchronization process. After last batch, finalization (cleanup) process should be called.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_batch_csv_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str separator:
        :param str quote:
        :param str escape:
        :param bool strict_quotes:
        :param bool ignore_leading_whitespace:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_batch_csv_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_batch_csv_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_batch_csv_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts batch synchronization from the CSV file in job (asynchronously).  # noqa: E501

        Starts batch synchronization from the CSV file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains CSV input which should be used for import or the file itself. The input file is treated as a part (batch) of synchronization process. After last batch, finalization (cleanup) process should be called.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_batch_csv_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str separator:
        :param str quote:
        :param str escape:
        :param bool strict_quotes:
        :param bool ignore_leading_whitespace:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'separator', 'quote', 'escape', 'strict_quotes', 'ignore_leading_whitespace', 'header_row', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_batch_csv_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_batch_csv_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'separator' in params:
            form_params.append(('separator', params['separator']))  # noqa: E501
        if 'quote' in params:
            form_params.append(('quote', params['quote']))  # noqa: E501
        if 'escape' in params:
            form_params.append(('escape', params['escape']))  # noqa: E501
        if 'strict_quotes' in params:
            form_params.append(('strictQuotes', params['strict_quotes']))  # noqa: E501
        if 'ignore_leading_whitespace' in params:
            form_params.append(('ignoreLeadingWhitespace', params['ignore_leading_whitespace']))  # noqa: E501
        if 'header_row' in params:
            form_params.append(('headerRow', params['header_row']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/batch/csv-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_batch_excel_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts batch synchronization from the Excel file in job (asynchronously).  # noqa: E501

        Starts batch synchronization from the Excel file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains Excel input which should be used for import or the file itself. The input file is treated as a part (batch) of synchronization process. After last batch, finalization (cleanup) process should be called.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_batch_excel_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str sheet_name:
        :param int sheet_index:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_batch_excel_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_batch_excel_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_batch_excel_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts batch synchronization from the Excel file in job (asynchronously).  # noqa: E501

        Starts batch synchronization from the Excel file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains Excel input which should be used for import or the file itself. The input file is treated as a part (batch) of synchronization process. After last batch, finalization (cleanup) process should be called.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_batch_excel_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str sheet_name:
        :param int sheet_index:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'sheet_name', 'sheet_index', 'header_row', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_batch_excel_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_batch_excel_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'sheet_name' in params:
            form_params.append(('sheetName', params['sheet_name']))  # noqa: E501
        if 'sheet_index' in params:
            form_params.append(('sheetIndex', params['sheet_index']))  # noqa: E501
        if 'header_row' in params:
            form_params.append(('headerRow', params['header_row']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/batch/excel-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_batch_json_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts batch synchronization from the JSON file in job (asynchronously).  # noqa: E501

        Starts batch synchronization from the JSON file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains JSON input which should be used for import or the file itself. The input file is treated as a part (batch) of synchronization process. After last batch, finalization (cleanup) process should be called.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_batch_json_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str relations_action:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_batch_json_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_batch_json_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_batch_json_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts batch synchronization from the JSON file in job (asynchronously).  # noqa: E501

        Starts batch synchronization from the JSON file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains JSON input which should be used for import or the file itself. The input file is treated as a part (batch) of synchronization process. After last batch, finalization (cleanup) process should be called.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_batch_json_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str relations_action:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'relations_action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_batch_json_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_batch_json_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'relations_action' in params:
            form_params.append(('relationsAction', params['relations_action']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/batch/json-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_csv_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts full synchronization from the CSV file in job (asynchronously).  # noqa: E501

        Starts full synchronization from the CSV file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains CSV input which should be used for import or the file itself. The input file is treated as a full input of synchronization process.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_csv_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :param str separator:
        :param str quote:
        :param str escape:
        :param bool strict_quotes:
        :param bool ignore_leading_whitespace:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_csv_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_csv_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_csv_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts full synchronization from the CSV file in job (asynchronously).  # noqa: E501

        Starts full synchronization from the CSV file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains CSV input which should be used for import or the file itself. The input file is treated as a full input of synchronization process.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_csv_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :param str separator:
        :param str quote:
        :param str escape:
        :param bool strict_quotes:
        :param bool ignore_leading_whitespace:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'finalization_strategy', 'missing_asset_status_id', 'separator', 'quote', 'escape', 'strict_quotes', 'ignore_leading_whitespace', 'header_row', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_csv_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_csv_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'finalization_strategy' in params:
            form_params.append(('finalizationStrategy', params['finalization_strategy']))  # noqa: E501
        if 'missing_asset_status_id' in params:
            form_params.append(('missingAssetStatusId', params['missing_asset_status_id']))  # noqa: E501
        if 'separator' in params:
            form_params.append(('separator', params['separator']))  # noqa: E501
        if 'quote' in params:
            form_params.append(('quote', params['quote']))  # noqa: E501
        if 'escape' in params:
            form_params.append(('escape', params['escape']))  # noqa: E501
        if 'strict_quotes' in params:
            form_params.append(('strictQuotes', params['strict_quotes']))  # noqa: E501
        if 'ignore_leading_whitespace' in params:
            form_params.append(('ignoreLeadingWhitespace', params['ignore_leading_whitespace']))  # noqa: E501
        if 'header_row' in params:
            form_params.append(('headerRow', params['header_row']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/csv-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_excel_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts full synchronization from the Excel file in job (asynchronously).  # noqa: E501

        Starts full synchronization from the Excel file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains Excel input which should be used for import or the file itself. The input file is treated as a full input of synchronization process.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_excel_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :param str sheet_name:
        :param int sheet_index:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_excel_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_excel_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_excel_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts full synchronization from the Excel file in job (asynchronously).  # noqa: E501

        Starts full synchronization from the Excel file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains Excel input which should be used for import or the file itself. The input file is treated as a full input of synchronization process.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_excel_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :param str sheet_name:
        :param int sheet_index:
        :param bool header_row:
        :param str template:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'finalization_strategy', 'missing_asset_status_id', 'sheet_name', 'sheet_index', 'header_row', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_excel_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_excel_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'finalization_strategy' in params:
            form_params.append(('finalizationStrategy', params['finalization_strategy']))  # noqa: E501
        if 'missing_asset_status_id' in params:
            form_params.append(('missingAssetStatusId', params['missing_asset_status_id']))  # noqa: E501
        if 'sheet_name' in params:
            form_params.append(('sheetName', params['sheet_name']))  # noqa: E501
        if 'sheet_index' in params:
            form_params.append(('sheetIndex', params['sheet_index']))  # noqa: E501
        if 'header_row' in params:
            form_params.append(('headerRow', params['header_row']))  # noqa: E501
        if 'template' in params:
            form_params.append(('template', params['template']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/excel-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_finalize_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts synchronization finalization in job (asynchronously).  # noqa: E501

        Starts synchronization finalization in job (asynchronously).<p>Note that while the only mandatory parameter is <code>synchronizationId</code>, requests that omit all optional parameters fail because the multipart-based setup requires at least one part to be present in the body. To meet this requirement and still use all the default values, you can pass a dummy part, for example <code>-F 'foo=bar'</code> if using <code>curl</code>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_finalize_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization ID used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :param dict(str, str) finalization_parameters:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_finalize_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_finalize_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_finalize_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts synchronization finalization in job (asynchronously).  # noqa: E501

        Starts synchronization finalization in job (asynchronously).<p>Note that while the only mandatory parameter is <code>synchronizationId</code>, requests that omit all optional parameters fail because the multipart-based setup requires at least one part to be present in the body. To meet this requirement and still use all the default values, you can pass a dummy part, for example <code>-F 'foo=bar'</code> if using <code>curl</code>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_finalize_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization ID used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :param dict(str, str) finalization_parameters:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'finalization_strategy', 'missing_asset_status_id', 'finalization_parameters']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_finalize_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_finalize_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'finalization_strategy' in params:
            form_params.append(('finalizationStrategy', params['finalization_strategy']))  # noqa: E501
        if 'missing_asset_status_id' in params:
            form_params.append(('missingAssetStatusId', params['missing_asset_status_id']))  # noqa: E501
        if 'finalization_parameters' in params:
            form_params.append(('finalizationParameters', params['finalization_parameters']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/finalize/job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def synchronize_json_in_job(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts full synchronization from the JSON file in job (asynchronously).  # noqa: E501

        Starts full synchronization from the JSON file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains JSON input which should be used for import or the file itself. The input file is treated as a full input of synchronization process.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_json_in_job(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.synchronize_json_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
        else:
            (data) = self.synchronize_json_in_job_with_http_info(synchronization_id, **kwargs)  # noqa: E501
            return data

    def synchronize_json_in_job_with_http_info(self, synchronization_id, **kwargs):  # noqa: E501
        """Starts full synchronization from the JSON file in job (asynchronously).  # noqa: E501

        Starts full synchronization from the JSON file in job (asynchronously).<p>Request can either accept <code>id</code> of the uploaded file that contains JSON input which should be used for import or the file itself. The input file is treated as a full input of synchronization process.</p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.synchronize_json_in_job_with_http_info(synchronization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str synchronization_id: The synchronization id used to distinguish different synchronizations. (required)
        :param bool send_notification:
        :param int batch_size:
        :param bool simulation:
        :param bool save_result:
        :param str file_id:
        :param str file:
        :param str file_name:
        :param bool delete_file:
        :param bool continue_on_error:
        :param str finalization_strategy:
        :param str missing_asset_status_id:
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['synchronization_id', 'send_notification', 'batch_size', 'simulation', 'save_result', 'file_id', 'file', 'file_name', 'delete_file', 'continue_on_error', 'finalization_strategy', 'missing_asset_status_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method synchronize_json_in_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'synchronization_id' is set
        if ('synchronization_id' not in params or
                params['synchronization_id'] is None):
            raise ValueError("Missing the required parameter `synchronization_id` when calling `synchronize_json_in_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'synchronization_id' in params:
            path_params['synchronizationId'] = params['synchronization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'send_notification' in params:
            form_params.append(('sendNotification', params['send_notification']))  # noqa: E501
        if 'batch_size' in params:
            form_params.append(('batchSize', params['batch_size']))  # noqa: E501
        if 'simulation' in params:
            form_params.append(('simulation', params['simulation']))  # noqa: E501
        if 'save_result' in params:
            form_params.append(('saveResult', params['save_result']))  # noqa: E501
        if 'file_id' in params:
            form_params.append(('fileId', params['file_id']))  # noqa: E501
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'file_name' in params:
            form_params.append(('fileName', params['file_name']))  # noqa: E501
        if 'delete_file' in params:
            form_params.append(('deleteFile', params['delete_file']))  # noqa: E501
        if 'continue_on_error' in params:
            form_params.append(('continueOnError', params['continue_on_error']))  # noqa: E501
        if 'finalization_strategy' in params:
            form_params.append(('finalizationStrategy', params['finalization_strategy']))  # noqa: E501
        if 'missing_asset_status_id' in params:
            form_params.append(('missingAssetStatusId', params['missing_asset_status_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/import/synchronize/{synchronizationId}/json-job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
