# TODO this file should eventually be generated by looking at openapi.json

import abc
from typing import List, Optional, Union, Dict, Any
from dataclasses import dataclass
from dataclasses_json import dataclass_json
from seamapi.utils.deep_attr_dict import DeepAttrDict

AccessCodeId = str
ActionAttemptId = str
DeviceId = str
EventId = str
AcceptedProvider = str  # e.g. august or noiseaware
ConnectWebviewId = str
ConnectedAccountId = str
Email = str
DeviceType = str  # e.g. august_lock
WorkspaceId = str
ClimateSettingScheduleId = str
WebhookId = str


class SeamApiException(Exception):
    def __init__(
        self,
        response,
    ):
        self.status_code = response.status_code
        self.request_id = response.headers.get("seam-request-id", None)

        self.metadata = None
        if "application/json" in response.headers["content-type"]:
            parsed_response = response.json()
            self.metadata = parsed_response.get("error", None)

        super().__init__(
            f"SeamApiException: status={self.status_code}, request_id={self.request_id}, metadata={self.metadata}"
        )


class ActionAttemptFailedException(Exception):
    def __init__(
        self,
        action_attempt_id: Optional[str] = None,
        action_type: Optional[str] = None,
        error_type: Optional[str] = None,
        error_message: Optional[str] = None,
    ):
        self.action_attempt_id = action_attempt_id
        self.action_type = action_type
        self.error_type = error_type
        self.error_message = error_message
        super().__init__(
            f'Action Attempt for "{action_type}" Failed. {error_type}: {error_message} (action_attempt_id={action_attempt_id})'
        )


class WaitForAccessCodeFailedException(Exception):
    def __init__(self, message: str, access_code_id: str, errors: Optional[list] = []):
        self.access_code_id = access_code_id
        self.errors = errors
        super().__init__(f"Failed while waiting for access code. ${message}")


@dataclass
class Device:
    device_id: DeviceId
    device_type: str
    location: Optional[Dict[str, Any]]
    properties: Any
    capabilities_supported: List[str]
    errors: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]
    connected_account_id: str
    workspace_id: str
    created_at: str
    is_managed: bool

    @staticmethod
    def from_dict(d: Dict[str, Any]):
        return Device(
            device_id=d["device_id"],
            device_type=d["device_type"],
            location=d.get("location", None),
            properties=DeepAttrDict(d["properties"]),
            capabilities_supported=d["capabilities_supported"],
            errors=d["errors"],
            warnings=d["warnings"],
            connected_account_id=d["connected_account_id"],
            workspace_id=d["workspace_id"],
            created_at=d["created_at"],
            is_managed=d["is_managed"],
        )


@dataclass
class UnmanagedDevice:
    device_id: DeviceId
    device_type: str
    properties: Any
    connected_account_id: str
    workspace_id: str
    created_at: str
    errors: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]
    capabilities_supported: List[str]
    is_managed: bool

    @staticmethod
    def from_dict(d: Dict[str, Any]):
        return UnmanagedDevice(
            device_id=d["device_id"],
            device_type=d["device_type"],
            properties=DeepAttrDict(d["properties"]),
            connected_account_id=d["connected_account_id"],
            workspace_id=d["workspace_id"],
            created_at=d["created_at"],
            errors=d["errors"],
            warnings=d["warnings"],
            capabilities_supported=d["capabilities_supported"],
            is_managed=d["is_managed"],
        )


@dataclass
class Event:
    event_id: str
    event_class: Union[str, None]
    event_type: Union[str, None]
    device_id: Optional[str]
    created_at: Union[str, None]


@dataclass_json
@dataclass
class ActionAttemptError:
    type: str
    message: str


@dataclass_json
@dataclass
class ActionAttempt:
    action_attempt_id: str
    action_type: str
    status: str
    result: Optional[Any] = None
    error: Optional[ActionAttemptError] = None


@dataclass_json
@dataclass
class Workspace:
    workspace_id: str
    name: str
    is_sandbox: bool
    connect_partner_name: str = None


@dataclass_json
@dataclass
class ConnectWebview:
    workspace_id: str
    connect_webview_id: str
    status: str
    url: str
    login_successful: bool
    device_selection_mode: str
    any_provider_allowed: bool
    any_device_allowed: bool
    created_at: str
    custom_metadata: Dict[str, Union[str, int, bool, None]]
    connected_account_id: Optional[str] = None
    authorized_at: Optional[str] = None
    custom_redirect_url: Optional[str] = None
    custom_redirect_failure_url: Optional[str] = None
    accepted_providers: Optional[List[AcceptedProvider]] = None
    accepted_devices: Optional[List[str]] = None
    selected_provider: Optional[str] = None
    wait_for_device_creation: Optional[bool] = None
    automatically_manage_new_devices: Optional[bool] = None


@dataclass_json
@dataclass
class ConnectedAccount:
    connected_account_id: str
    created_at: str
    user_identifier: str
    account_type: str
    errors: List[str]
    custom_metadata: Dict[str, Union[str, int, bool, None]]


@dataclass_json
@dataclass
class AccessCode:
    access_code_id: str
    device_id: str
    type: str
    created_at: str
    errors: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]
    code: Optional[str] = None
    starts_at: Optional[str] = None
    ends_at: Optional[str] = None
    name: Optional[str] = ""
    status: Optional[str] = None
    common_code_key: Optional[str] = None
    is_managed: Optional[bool] = None
    is_waiting_for_code_assignment: Optional[bool] = None
    is_scheduled_on_device: Optional[bool] = None
    pulled_backup_access_code_id: Optional[str] = None
    is_backup_access_code_available: Optional[bool] = None
    is_backup: Optional[bool] = None
    appearance: Optional[Dict[str, Any]] = None
    is_external_modification_allowed: Optional[bool] = None
    is_offline_access_code: Optional[bool] = None
    is_one_time_use: Optional[bool] = None


@dataclass_json
@dataclass
class UnmanagedAccessCode:
    access_code_id: str
    device_id: str
    type: str
    created_at: str
    errors: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]
    name: Optional[str] = ""
    code: Optional[str] = None
    is_managed: Optional[bool] = None
    starts_at: Optional[str] = None
    ends_at: Optional[str] = None
    status: Optional[str] = None


@dataclass
class NoiseThreshold:
    noise_threshold_id: str
    device_id: str
    name: str
    noise_threshold_decibels: float

    starts_daily_at: Optional[str]
    ends_daily_at: Optional[str]

    noise_threshold_nrs: Optional[float]

    @staticmethod
    def from_dict(nt: Dict[str, Any]):
        return NoiseThreshold(
            noise_threshold_id=nt["noise_threshold_id"],
            device_id=nt["device_id"],
            name=nt["name"],
            noise_threshold_decibels=nt["noise_threshold_decibels"],
            starts_daily_at=nt["starts_daily_at"],
            ends_daily_at=nt["ends_daily_at"],
            noise_threshold_nrs=nt.get("noise_threshold_nrs", None),
        )


@dataclass_json
@dataclass
class ClimateSetting:
    automatic_heating_enabled: Optional[bool]
    automatic_cooling_enabled: Optional[bool]
    hvac_mode_setting: Optional[str]
    cooling_set_point_celsius: Optional[float]
    heating_set_point_celsius: Optional[float]
    cooling_set_point_fahrenheit: Optional[float]
    heating_set_point_fahrenheit: Optional[float]
    manual_override_allowed: Optional[bool]


@dataclass_json
@dataclass
class ClimateSettingScheduleBase(ClimateSetting):
    schedule_type: Optional[str]
    name: Optional[str]
    schedule_starts_at: str
    schedule_ends_at: str


@dataclass_json
@dataclass
class ClimateSettingSchedule(ClimateSettingScheduleBase):
    climate_setting_schedule_id: str
    is_set_on_device: bool
    device_id: str
    created_at: str


@dataclass_json
@dataclass
class ClimateSettingScheduleUpdate(ClimateSettingSchedule):
    pass


@dataclass_json
@dataclass
class Webhook:
    webhook_id: str
    url: str
    event_types: List[str] = None
    secret: str = None


class AbstractActionAttempts(abc.ABC):
    @abc.abstractmethod
    def get(
        self, action_attempt: Union[ActionAttemptId, ActionAttempt]
    ) -> ActionAttempt:
        raise NotImplementedError

    @abc.abstractmethod
    def poll_until_ready(
        self,
        action_attempt: Union[ActionAttemptId, ActionAttempt],
        should_raise: bool = True,
    ) -> ActionAttempt:
        raise NotImplementedError


class AbstractLocks(abc.ABC):
    @abc.abstractmethod
    def list(self, connected_account: Optional[str] = None) -> List[Device]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(self, device: Union[DeviceId, Device]) -> Device:
        raise NotImplementedError

    @abc.abstractmethod
    def lock_door(self, device: Union[DeviceId, Device]) -> ActionAttempt:
        raise NotImplementedError

    @abc.abstractmethod
    def unlock_door(self, device: Union[DeviceId, Device]) -> ActionAttempt:
        raise NotImplementedError


class AbstractUnmanagedAccessCodes(abc.ABC):
    @abc.abstractmethod
    def get(
        self,
        device: Optional[Union[DeviceId, Device]] = None,
        access_code: Optional[Union[AccessCodeId, UnmanagedAccessCode]] = None,
        code: Optional[str] = None,
    ) -> UnmanagedAccessCode:
        raise NotImplementedError

    @abc.abstractmethod
    def list(
        self,
        device: Union[DeviceId, Device],
    ) -> List[UnmanagedAccessCode]:
        raise NotImplementedError

    @abc.abstractmethod
    def convert_to_managed(
        self,
        access_code: Union[AccessCodeId, UnmanagedAccessCode],
        allow_external_modification: Optional[bool] = None,
    ) -> ActionAttempt:
        raise NotImplementedError


class AbstractAccessCodes(abc.ABC):
    unmanaged: AbstractUnmanagedAccessCodes

    @abc.abstractmethod
    def list(
        self,
        device: Optional[Union[DeviceId, Device]] = None,
        access_codes: Optional[Union[List[AccessCode], List[AccessCodeId]]] = None,
    ) -> List[AccessCode]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(
        self,
        access_code: Union[AccessCodeId, AccessCode],
    ) -> AccessCode:
        raise NotImplementedError

    @abc.abstractmethod
    def create_multiple(
        self,
        devices: Union[List[DeviceId], List[Device]],
        name: Optional[str] = None,
        code: Optional[str] = None,
        starts_at: Optional[str] = None,
        ends_at: Optional[str] = None,
        common_code_key: Optional[str] = None,
    ) -> List[AccessCode]:
        raise NotImplementedError

    @abc.abstractmethod
    def create(
        self,
        device: Union[DeviceId, Device],
        name: Optional[str] = None,
        code: Optional[str] = None,
        type: Optional[str] = None,
        starts_at: Optional[str] = None,
        ends_at: Optional[str] = None,
        common_code_key: Optional[str] = None,
        attempt_for_offline_device: Optional[bool] = True,
        wait_for_code: Optional[bool] = False,
        timeout: Optional[int] = 300,
        allow_external_modification: Optional[bool] = None,
        prefer_native_scheduling: Optional[bool] = None,
        use_backup_access_code_pool: Optional[bool] = None,
    ) -> AccessCode:
        raise NotImplementedError

    @abc.abstractmethod
    def update(
        self,
        access_code: Union[AccessCodeId, AccessCode],
        device: Optional[Union[DeviceId, Device]] = None,
        name: Optional[str] = None,
        code: Optional[str] = None,
        starts_at: Optional[str] = None,
        ends_at: Optional[str] = None,
        type: Optional[str] = None,
    ) -> AccessCode:
        raise NotImplementedError

    @abc.abstractmethod
    def delete(
        self,
        access_code: Union[AccessCodeId, AccessCode],
    ) -> ActionAttempt:
        raise NotImplementedError

    @abc.abstractmethod
    def pull_backup_access_code(
        self,
        access_code: Union[AccessCode, AccessCodeId],
    ) -> AccessCode:
        raise NotImplementedError


class AbstractNoiseThresholds(abc.ABC):
    @abc.abstractmethod
    def create(
        self,
        device_id: str,
        starts_daily_at: str,
        ends_daily_at: str,
        name: Optional[str],
        noise_threshold_decibels: Optional[float] = None,
        noise_threshold_nrs: Optional[float] = None,
        wait_for_action_attempt: Optional[bool] = True,
    ) -> Union[ActionAttempt, NoiseThreshold]:
        raise NotImplementedError

    @abc.abstractmethod
    def update(
        self,
        device_id: str,
        noise_threshold_id: str,
        name: Optional[str] = None,
        starts_daily_at: Optional[str] = None,
        ends_daily_at: Optional[str] = None,
        noise_threshold_decibels: Optional[str] = None,
        noise_threshold_nrs: Optional[str] = None,
        wait_for_action_attempt: Optional[bool] = True,
    ) -> Union[ActionAttempt, NoiseThreshold]:
        raise NotImplementedError

    @abc.abstractmethod
    def list(
        self,
        device_id: str,
    ) -> List[NoiseThreshold]:
        raise NotImplementedError

    @abc.abstractmethod
    def delete(
        self,
        noise_threshold_id: str,
        device_id: str,
        wait_for_action_attempt: Optional[bool] = True,
    ) -> ActionAttempt:
        raise NotImplementedError


class AbstractNoiseSensors(abc.ABC):
    @property
    @abc.abstractmethod
    def noise_thresholds(self) -> AbstractNoiseThresholds:
        raise NotImplementedError

    @abc.abstractmethod
    def list_noise_levels(self, starting_after=None, ending_before=None) -> None:
        raise NotImplementedError


class AbstractUnmanagedDevices(abc.ABC):
    @abc.abstractmethod
    def get(
        self,
        device: Optional[Union[DeviceId, Device]] = None,
        name: Optional[str] = None,
    ) -> UnmanagedDevice:
        raise NotImplementedError

    @abc.abstractmethod
    def list(
        self,
        connected_account: Union[ConnectedAccountId, ConnectedAccount] = None,
        connected_accounts: List[Union[ConnectedAccountId, ConnectedAccount]] = None,
        connect_webview: Union[ConnectWebviewId, ConnectWebview] = None,
        device_type: Optional[DeviceType] = None,
        device_types: Optional[List[DeviceType]] = None,
        device_ids: Optional[List[Union[DeviceId, Device]]] = None,
        manufacturer: Optional[str] = None,
        limit: Optional[float] = None,
        created_before: Optional[str] = None,
    ) -> List[UnmanagedDevice]:
        raise NotImplementedError

    @abc.abstractmethod
    def update(
        self,
        device: Union[DeviceId, UnmanagedDevice],
        is_managed: bool,
    ) -> bool:
        raise NotImplementedError


class AbstractDevices(abc.ABC):
    unmanaged: AbstractUnmanagedDevices

    @abc.abstractmethod
    def list(
        self,
        connected_account: Union[ConnectedAccountId, ConnectedAccount] = None,
        connected_accounts: List[Union[ConnectedAccountId, ConnectedAccount]] = None,
        connect_webview: Union[ConnectWebviewId, ConnectWebview] = None,
        device_type: Optional[DeviceType] = None,
        device_types: Optional[List[DeviceType]] = None,
        device_ids: Optional[list] = None,
        manufacturer: Optional[str] = None,
    ) -> List[Device]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(
        self,
        device: Optional[Union[DeviceId, Device]] = None,
        name: Optional[str] = None,
    ) -> Device:
        raise NotImplementedError

    @abc.abstractmethod
    def update(
        self,
        device: Union[DeviceId, Device],
        name: Optional[str] = None,
        properties: Optional[dict] = None,
        location: Optional[dict] = None,
        is_managed: Optional[bool] = None,
    ) -> bool:
        raise NotImplementedError

    @abc.abstractmethod
    def delete(self, device: Union[DeviceId, Device]) -> bool:
        raise NotImplementedError

    @abc.abstractmethod
    def list_device_providers(
        self, provider_category: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        raise NotImplementedError


class AbstractEvents(abc.ABC):
    @abc.abstractmethod
    def list(self) -> List[Event]:
        raise NotImplementedError


class AbstractWorkspaces(abc.ABC):
    @abc.abstractmethod
    def list(self) -> List[Workspace]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(self, workspace_id: Optional[str] = None) -> Workspace:
        raise NotImplementedError

    @abc.abstractmethod
    def create(
        self,
        name: str,
        connect_partner_name: str,
        is_sandbox: Optional[bool] = None,
        webview_primary_button_color: Optional[str] = None,
        webview_logo_shape: Optional[str] = None,
    ) -> Workspace:
        raise NotImplementedError

    @abc.abstractmethod
    def reset_sandbox(self) -> None:
        raise NotImplementedError


class AbstractConnectWebviews(abc.ABC):
    @abc.abstractmethod
    def list(self) -> List[ConnectWebview]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(self, connect_webview_id: str) -> ConnectWebview:
        raise NotImplementedError

    @abc.abstractmethod
    def create(
        self,
        accepted_providers: Optional[List[AcceptedProvider]] = None,
        provider_category: Optional[str] = None,
    ) -> ConnectWebview:
        raise NotImplementedError


class AbstractConnectedAccounts(abc.ABC):
    @abc.abstractmethod
    def list(self) -> List[ConnectedAccount]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(
        self, connected_account: Union[ConnectedAccountId, ConnectedAccount]
    ) -> ConnectedAccount:
        raise NotImplementedError


class AbstractClimateSettingSchedules(abc.ABC):
    @abc.abstractmethod
    def get(
        self,
        climate_setting_schedule: Union[
            ClimateSettingScheduleId, ClimateSettingSchedule
        ],
    ) -> ClimateSettingSchedule:
        raise NotImplementedError

    @abc.abstractmethod
    def create(
        self,
        device: Union[DeviceId, Device],
        schedule_starts_at: str,
        schedule_ends_at: str,
        manual_override_allowed: bool,
        name: Optional[str] = None,
        automatic_heating_enabled: Optional[bool] = None,
        automatic_cooling_enabled: Optional[bool] = None,
        hvac_mode_setting: Optional[str] = None,
        cooling_set_point_celsius: Optional[float] = None,
        heating_set_point_celsius: Optional[float] = None,
        cooling_set_point_fahrenheit: Optional[float] = None,
        heating_set_point_fahrenheit: Optional[float] = None,
        schedule_type: Optional[str] = None,
    ) -> ClimateSettingSchedule:
        raise NotImplementedError

    @abc.abstractmethod
    def update(
        self,
        climate_setting_schedule: Union[str, ClimateSettingSchedule],
        schedule_starts_at: Optional[str] = None,
        schedule_ends_at: Optional[str] = None,
        name: Optional[str] = None,
        automatic_heating_enabled: Optional[bool] = None,
        automatic_cooling_enabled: Optional[bool] = None,
        hvac_mode_setting: Optional[str] = None,
        cooling_set_point_celsius: Optional[float] = None,
        heating_set_point_celsius: Optional[float] = None,
        cooling_set_point_fahrenheit: Optional[float] = None,
        heating_set_point_fahrenheit: Optional[float] = None,
        manual_override_allowed: Optional[bool] = None,
        schedule_type: Optional[str] = None,
    ) -> ClimateSettingSchedule:
        raise NotImplementedError

    @abc.abstractmethod
    def list(
        self,
        device: Union[DeviceId, Device],
    ) -> List[ClimateSettingSchedule]:
        raise NotImplementedError

    @abc.abstractmethod
    def delete(
        self,
        climate_setting_schedule: Optional[Union[str, ClimateSettingSchedule]],
    ) -> None:
        raise NotImplementedError


class AbstractThermostats(abc.ABC):
    climate_setting_schedules: AbstractClimateSettingSchedules

    @abc.abstractmethod
    def list(
        self,
        connected_account: Union[ConnectedAccountId, ConnectedAccount] = None,
        connected_accounts: List[Union[ConnectedAccountId, ConnectedAccount]] = None,
        connect_webview: Union[ConnectWebviewId, ConnectWebview] = None,
        device_type: Optional[DeviceType] = None,
        device_types: Optional[List[DeviceType]] = None,
        device_ids: Optional[List[Union[DeviceId, Device]]] = None,
        manufacturer: Optional[str] = None,
        limit: Optional[float] = None,
        created_before: Optional[str] = None,
    ) -> List[Device]:
        raise NotImplementedError

    @abc.abstractmethod
    def get(
        self,
        device: Optional[Union[DeviceId, Device]] = None,
        name: Optional[str] = None,
    ) -> Device:
        raise NotImplementedError

    @abc.abstractmethod
    def update(
        self,
        device: Union[DeviceId, Device],
        default_climate_setting: Optional[dict] = None,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def cool(
        self,
        device: Union[DeviceId, Device],
        cooling_set_point_celsius: Optional[float] = None,
        cooling_set_point_fahrenheit: Optional[float] = None,
        wait_for_action_attempt: Optional[bool] = True,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def heat(
        self,
        device: Union[DeviceId, Device],
        heating_set_point_celsius: Optional[float] = None,
        heating_set_point_fahrenheit: Optional[float] = None,
        wait_for_action_attempt: Optional[bool] = True,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def heat_cool(
        self,
        device: Union[DeviceId, Device],
        cooling_set_point_fahrenheit: Optional[float] = None,
        cooling_set_point_celsius: Optional[float] = None,
        heating_set_point_fahrenheit: Optional[float] = None,
        heating_set_point_celsius: Optional[float] = None,
        wait_for_action_attempt: Optional[bool] = True,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def off(
        self,
        device: Union[DeviceId, Device],
        wait_for_action_attempt: Optional[bool] = True,
    ) -> None:
        raise NotImplementedError

    @abc.abstractmethod
    def set_fan_mode(
        self,
        device: Union[DeviceId, Device],
        wait_for_action_attempt: Optional[bool] = True,
    ) -> None:
        raise NotImplementedError


class AbstractWebhooks(abc.ABC):
    @abc.abstractmethod
    def create(
        self,
        url: str,
        event_types: Optional[list] = None,
    ) -> Webhook:
        raise NotImplementedError

    @abc.abstractmethod
    def delete(
        self,
        webhook: Union[WebhookId, Webhook],
    ) -> bool:
        raise NotImplementedError

    @abc.abstractmethod
    def get(
        self,
        webhook: Union[WebhookId, Webhook],
    ) -> Webhook:
        raise NotImplementedError

    @abc.abstractmethod
    def list(self) -> List[Webhook]:
        raise NotImplementedError


@dataclass
class AbstractRoutes(abc.ABC):
    workspaces: AbstractWorkspaces
    connect_webviews: AbstractConnectWebviews
    locks: AbstractLocks
    devices: AbstractDevices
    access_codes: AbstractAccessCodes
    action_attempts: AbstractActionAttempts
    noise_sensors: AbstractNoiseSensors
    thermostats: AbstractThermostats
    events: AbstractEvents
    connected_accounts: AbstractConnectedAccounts
    webhooks: AbstractWebhooks

    @abc.abstractmethod
    def make_request(self, method: str, path: str, **kwargs) -> Any:
        raise NotImplementedError


@dataclass
class AbstractSeam(AbstractRoutes):
    api_key: str
    workspace_id: str
    api_url: str

    @abc.abstractmethod
    def __init__(
        self,
        api_key: Optional[str] = None,
        workspace_id: Optional[str] = None,
        api_url: Optional[str] = None,
        should_report_exceptions: Optional[bool] = False,
    ):
        raise NotImplementedError


@dataclass_json
@dataclass
class ResetSandBoxResponse:
    message: str
    ok: bool
