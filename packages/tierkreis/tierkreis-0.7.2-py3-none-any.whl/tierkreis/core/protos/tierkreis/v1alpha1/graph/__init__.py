# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: v1alpha1/graph.proto
# plugin: python-betterproto
# This file has been @generated
import builtins
from dataclasses import dataclass
from typing import (
    Dict,
    List,
    Optional,
)

import betterproto


@dataclass(eq=False, repr=False)
class Location(betterproto.Message):
    location: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class StructValue(betterproto.Message):
    map: Dict[str, "Value"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class PairValue(betterproto.Message):
    first: "Value" = betterproto.message_field(1)
    second: "Value" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MapValue(betterproto.Message):
    pairs: List["PairValue"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class VecValue(betterproto.Message):
    vec: List["Value"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class VariantValue(betterproto.Message):
    tag: str = betterproto.string_field(1)
    value: "Value" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Value(betterproto.Message):
    graph: "Graph" = betterproto.message_field(1, group="value")
    integer: int = betterproto.int64_field(2, group="value")
    boolean: bool = betterproto.bool_field(3, group="value")
    str: builtins.str = betterproto.string_field(9, group="value")
    flt: float = betterproto.double_field(10, group="value")
    pair: "PairValue" = betterproto.message_field(4, group="value")
    vec: "VecValue" = betterproto.message_field(5, group="value")
    map: "MapValue" = betterproto.message_field(7, group="value")
    struct: "StructValue" = betterproto.message_field(8, group="value")
    variant: "VariantValue" = betterproto.message_field(12, group="value")


@dataclass(eq=False, repr=False)
class Output(betterproto.Message):
    edge: "Edge" = betterproto.message_field(1)
    value: "Value" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class OutputStream(betterproto.Message):
    stream: List["Output"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Type(betterproto.Message):
    var: str = betterproto.string_field(1, group="type")
    int: "Empty" = betterproto.message_field(2, group="type")
    bool: "Empty" = betterproto.message_field(3, group="type")
    graph: "GraphType" = betterproto.message_field(4, group="type")
    pair: "PairType" = betterproto.message_field(5, group="type")
    vec: "Type" = betterproto.message_field(6, group="type")
    row: "RowType" = betterproto.message_field(7, group="type")
    map: "PairType" = betterproto.message_field(9, group="type")
    struct: "StructType" = betterproto.message_field(10, group="type")
    str: "Empty" = betterproto.message_field(11, group="type")
    flt: "Empty" = betterproto.message_field(12, group="type")
    variant: "RowType" = betterproto.message_field(14, group="type")
    """Type option = 13;  // REMOVED"""


@dataclass(eq=False, repr=False)
class GraphType(betterproto.Message):
    inputs: "RowType" = betterproto.message_field(1)
    outputs: "RowType" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PairType(betterproto.Message):
    first: "Type" = betterproto.message_field(1)
    second: "Type" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RowType(betterproto.Message):
    content: Dict[str, "Type"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    rest: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class StructType(betterproto.Message):
    shape: "RowType" = betterproto.message_field(1)
    name: str = betterproto.string_field(2, group="name_opt")


@dataclass(eq=False, repr=False)
class FunctionName(betterproto.Message):
    namespaces: List[str] = betterproto.string_field(1)
    name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class FunctionNode(betterproto.Message):
    name: "FunctionName" = betterproto.message_field(1)
    retry_secs: Optional[int] = betterproto.uint32_field(
        2, optional=True, group="_retry_secs"
    )


@dataclass(eq=False, repr=False)
class BoxNode(betterproto.Message):
    loc: "Location" = betterproto.message_field(1)
    graph: "Graph" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Node(betterproto.Message):
    input: "Empty" = betterproto.message_field(1, group="node")
    output: "Empty" = betterproto.message_field(2, group="node")
    const: "Value" = betterproto.message_field(3, group="node")
    box: "BoxNode" = betterproto.message_field(4, group="node")
    function: "FunctionNode" = betterproto.message_field(5, group="node")
    match: "Empty" = betterproto.message_field(6, group="node")
    tag: str = betterproto.string_field(7, group="node")


@dataclass(eq=False, repr=False)
class Edge(betterproto.Message):
    port_from: str = betterproto.string_field(1)
    port_to: str = betterproto.string_field(2)
    node_from: int = betterproto.uint32_field(3)
    node_to: int = betterproto.uint32_field(4)
    edge_type: "Type" = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class Graph(betterproto.Message):
    nodes: List["Node"] = betterproto.message_field(1)
    edges: List["Edge"] = betterproto.message_field(2)
    name: str = betterproto.string_field(3)
    input_order: List[str] = betterproto.string_field(4)
    """
    below orderings are optional and used by graph builders if available listed
    ports will be reported and wired up in the listed order and before ports
    that are not listed
    """

    output_order: List[str] = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class Empty(betterproto.Message):
    """
    This is supposed to be `google.protobuf.Empty` but unfortunately there is
    no support for this in `betterproto` yet.
    """

    pass


@dataclass(eq=False, repr=False)
class TypeScheme(betterproto.Message):
    variables: List["TypeSchemeVar"] = betterproto.message_field(1)
    constraints: List["Constraint"] = betterproto.message_field(2)
    body: "Type" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class TypeSchemeVar(betterproto.Message):
    name: str = betterproto.string_field(1)
    kind: "Kind" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Constraint(betterproto.Message):
    lacks: "LacksConstraint" = betterproto.message_field(1, group="constraint")
    partition: "PartitionConstraint" = betterproto.message_field(2, group="constraint")


@dataclass(eq=False, repr=False)
class PartitionConstraint(betterproto.Message):
    left: "Type" = betterproto.message_field(1)
    right: "Type" = betterproto.message_field(2)
    union: "Type" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class LacksConstraint(betterproto.Message):
    row: "Type" = betterproto.message_field(1)
    label: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class Kind(betterproto.Message):
    star: "Empty" = betterproto.message_field(1, group="kind")
    row: "Empty" = betterproto.message_field(2, group="kind")
