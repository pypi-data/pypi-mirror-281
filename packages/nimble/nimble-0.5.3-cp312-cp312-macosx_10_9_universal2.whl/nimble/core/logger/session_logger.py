
##########################################################################
# Copyright 2024 Sparkwave LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##########################################################################

"""
Handle logging of creating and testing learners.

Currently stores data in a SQLite database file and generates
a human readable log by querying the table within the database.
There is a hierarchical structure to the log, this limits the to
entries with only the specified level of detail.

Also included are the wrappers to ensure that logged functions are
logged only when necessary.

Hierarchy
Level 1: Data creation and preprocessing logs
Level 2: Outputs basic information about learner runs, including
         timestamp, session number, learner name, train and test object
         details, parameter, metric and timer data if available
Level 3: Cross validation
"""

import os
from time import strftime
import inspect
import re
import sqlite3
from ast import literal_eval
import textwrap
import datetime
from configparser import NoSectionError
import itertools

import numpy as np

import nimble
from nimble.exceptions import InvalidArgumentType, InvalidArgumentValue
from nimble.exceptions import InvalidArgumentValueCombination

def _BaseNameOrType(obj):
    if obj.name is not None:
        return obj.name
    return obj.getTypeString()

def log(heading, logInfo):
    """
    Enter an entry into the active logger's database file.

    In addition to the provided ``heading`` and ``logInfo``, the session
    number and timestamp will be automatically recorded for this log
    entry.

    Parameters
    ----------
    heading : str
        A short description (maximum of 50 characters) to be placed at
        the head of the log entry. The string "User - " is prepended to
        the heading to differentiate user entries from log entries
        generated by nimble.
    logInfo : str, list, dict
        Contains any information to be logged.

    See Also
    --------
    showLog

    Keywords
    --------
    recorded, record, database, entry, message, history
    """
    if not isinstance(heading, str):
        raise InvalidArgumentType("heading must be a string")
    if not isinstance(logInfo, (str, list, dict)):
        msg = "logInfo must be a python string, list, or dictionary type"
        raise InvalidArgumentType(msg)
    if len(heading) > 50:
        raise InvalidArgumentValue("headings must be 50 characters or less")
    heading = "User - " + heading
    nimble.core.logger.active.log(heading, logInfo)


def showLog(levelOfDetail=2, leastSessionsAgo=0, mostSessionsAgo=1,
            startDate=None, endDate=None, maximumEntries=100,
            searchForText=None, regex=False, saveToFileName=None,
            append=False):
    """
    Output contents of the logger's database file.

    Create a human readable interpretation of the log file based on
    the arguments passed and print or write to a file.

    Parameters
    ----------
    levelOfDetail :  int
        The value for the level of detail from 1, the least detail,
        to 3 (most detail). Default is 2.

        * Level 1 - Data loading, data preparation and
          preprocessing, custom user logs.
        * Level 2 - Output an overview of learner runs in addition to
          logs in Level 1. Includes timestamps, learner names, train and
          test object details, parameters, metrics, tuning results, and
          timer data when applicable.
        * Level 3 - Output all available data. Adds individual
          validation results from hyperparameter tuning.
          Note: The 'enableDeepLogging' option in the 'logger' section
          of nimble.settings, must be set to 'True' during the session
          in order for Level 3 data to be stored in the log.
    leastSessionsAgo : int
        The least number of sessions since the most recent session to
        include in the log. Default is 0.
    mostSessionsAgo : int
        The most number of sessions since the most recent session to
        include in the log. Default is 1.
    startDate :  str, datetime
        A string or datetime object of the date to begin adding sessions
        to the log.
        Acceptable formats:
        * "YYYY-MM-DD"
        * "YYYY-MM-DD HH:MM"
        * "YYYY-MM-DD HH:MM:SS"
    endDate : str, datetime
        A string or datetime object of the date to stop adding sessions
        to the log.
        See ``startDate`` for formatting.
    maximumEntries : int
        Maximum number of entries to allow before stopping the log.
        None will allow all entries provided from the query. Default
        is 100.
    searchForText : str, regex
        Search for in each log entry. Default is None.
    saveToFileName : str
        The name of a file to write the human readable log. It will
        be saved in the same directory as the logger database.
        Default is None, showLog will print to standard out.
    append : bool
        Append logs to the file in saveToFileName instead of
        overwriting file. Default is False.

    See Also
    --------
    log

    Keywords
    --------
    sessions, entry, entries, database, query, record, history, display
    """
    if levelOfDetail < 1 or levelOfDetail > 3 or levelOfDetail is None:
        msg = "levelOfDetail must be 1, 2, or 3"
        raise InvalidArgumentValue(msg)
    if (startDate is not None
            and endDate is not None
            and startDate > endDate):
        startDate = stringToDatetime(startDate)
        endDate = stringToDatetime(endDate)
        msg = "The startDate must be before the endDate"
        raise InvalidArgumentValueCombination(msg)
    if leastSessionsAgo is not None:
        if leastSessionsAgo < 0:
            msg = "leastSessionsAgo must be greater than zero"
            raise InvalidArgumentValue(msg)
        if mostSessionsAgo is not None and mostSessionsAgo < leastSessionsAgo:
            msg = "mostSessionsAgo must be greater than or equal to "
            msg += "leastSessionsAgo"
            raise InvalidArgumentValueCombination(msg)
    nimble.core.logger.active.showLog(levelOfDetail, leastSessionsAgo,
                                      mostSessionsAgo, startDate, endDate,
                                      maximumEntries, searchForText, regex,
                                      saveToFileName, append)

class SessionLogger(object):
    """
    Handle logging of nimble functions and generating the log output.

    Parameters
    ----------
    logLocation : str
        The path to the directory containing the log file
    logName : str
        The name of the log file. The suffix '.db' will be added to the
        name, to indicate this is a sqlite database file of the logged
        information.
    """
    def __init__(self, logLocation, logName):
        fullLogDesignator = os.path.join(logLocation, logName)
        self.logLocation = logLocation
        self.logName = logName
        self.logFileName = fullLogDesignator + ".db"
        self.sessionNumber = None
        self.connection = None
        self.cursor = None
        self.isAvailable = False
        self.logTypes = {
            'load': self.logLoad, 'tl': self.logTrainedLearner,
            'prep': self.logPrep, 'run': self.logRun, 'TLrun': self.logTLRun,
            'report': self.logReport, 'tuning': self.logTuning,
            'deepRun': self.logDeepRun, 'setSeed': self.logRandomSeed
            }


    def setup(self, newFileName=None):
        """
        Open or create the log file.

        Try to open the file that will be used for logging.  If
        ``newFileName`` is present, will reset the log file to use the
        new file name and attempt to open it.  Otherwise, will use the
        file name provided when this was instantiated.  If successfully
        opens the file, set isAvailable to true.

        Parameters
        ----------
        newFileName : str
            The name new logging file.
        """
        if (newFileName is not None
                and isinstance(newFileName, str)):
            self.logFileName = newFileName

        dirPath = os.path.dirname(self.logFileName)
        if not os.path.exists(dirPath):
            os.makedirs(dirPath)
        self.connection = sqlite3.connect(self.logFileName)
        def regexp(y, x, search=re.search):
            return 1 if search(y, x) else 0
        self.connection.create_function('regexp', 2, regexp)
        self.cursor = self.connection.cursor()
        statement = """
        CREATE TABLE IF NOT EXISTS logger (
        entry INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT,
        sessionNumber INTEGER,
        logType TEXT,
        logInfo TEXT);
        """
        self.cursor.execute(statement)
        self.connection.commit()

        statement = "SELECT MAX(sessionNumber) FROM logger;"
        self.cursor.execute(statement)
        lastSession = self.cursor.fetchone()[0] #fetchone returns a tuple
        if lastSession is not None:
            self.sessionNumber = lastSession + 1
        else:
            self.sessionNumber = 0

        self.isAvailable = True


    def cleanup(self):
        """
        Closes the connection to the logger database, if it is open.
        """
        # only need to call if we have previously called setup
        if self.isAvailable:
            self.cursor.close()
            self.connection.close()
            self.isAvailable = False


    def log(self, logType, logInfo):
        """
        Add information into the log file.

        Inserts timestamp, sessionNumber, ``logType`` in their
        respective columns of the sqlite table. A string of ``logInfo``
        will be stored in the final column.

        Parameters
        ----------
        logType : str
            The type of information being added to the log. The values
            'load', 'prep', 'run', 'report', and 'tuning', generate a
            custom output of the ``logInfo`` when printing the log.  Any
            other log type will print a string of ``logInfo`` without
            any additional formatting.
        logInfo : dict, list, str
            All types for this value will be converted and added to the
            log. If provided a dictionary; ``logType`` 'load', 'prep',
            'run', 'report', and 'tuning' generate a custom output when
            printing the log.
        """
        if not self.isAvailable:
            self.setup(self.logFileName)

        timestamp = strftime('%Y-%m-%d %H:%M:%S')
        sessionNum = self.sessionNumber
        logInfo = repr(logInfo)
        statement = "INSERT INTO logger "
        statement += "(timestamp,sessionNumber,logType,logInfo) "
        statement += "VALUES (?,?,?,?);"
        self.cursor.execute(statement, (timestamp, sessionNum, logType,
                                        logInfo))
        self.connection.commit()


    def extractFromLog(self, query, values=None):
        """
        Fetch data from log file.

        Return a list of tuples for values matching a SQLite query
        statement.

        Parameters
        ----------
        query : str
            a SQLite query statement.
        values : tuple
            values to use in place of the "?" placeholders used in the
            query.
        """
        if not self.isAvailable:
            self.setup()
        if values is None:
            self.cursor.execute(query)
        else:
            self.cursor.execute(query, values)
        ret = self.cursor.fetchall()
        return ret

    ###################
    ### LOG ENTRIES ###
    ###################

    def logLoad(self, useLog, obj, **kwargs):
        """
        Log information about the loading of data.

        If this will be logged, store an entry in the database with
        "load" as the logType and a dictionary (stored as a string) of
        attributes for the loaded object as the logInfo.

        Parameters
        ----------
        obj : nimble.core.data.Base
            The data object to extract the logged information from.
        """
        if loggingEnabled(useLog):
            logType = "load"
            logInfo = {}
            logInfo["numPoints"], logInfo["numFeatures"] = obj.shape
            if obj.path is not None:
                logInfo["path"] = obj.path
            logInfo.update(kwargs)
            logInfo.update(identifyObject(obj))

            self.log(logType, logInfo)

    def logTrainedLearner(self, useLog, obj):
        """
        Log information about the loading a trained learner.

        If this will be logged, store an entry in the database with
        "load" as the logType and a dictionary (stored as a string) of
        attributes for the loaded object as the logInfo.

        Parameters
        ----------
        obj : nimble.core.data.Base
            The data object to extract the logged information from.
        """
        if loggingEnabled(useLog):
            logType = 'tl'
            logInfo = identifyObject(obj)
            logInfo['learnerName'] = obj.learnerName
            logInfo['learnerArgs'] = obj.arguments

            self.log(logType, logInfo)

    def logReport(self, useLog, reportType, reportInfo):
        """
        Log an object's information reports.

        If this will be logged, store an entry in the database with
        "report" as the logType and a dictionary (stored as a string) of
        the report report as the logInfo.

        reportType : str
            'feature' or 'summary' based on the type of report.
        reportInfo : str
            The information generated during the call to the report
            function.
        """
        if loggingEnabled(useLog):
            logType = "report"
            logInfo = {}
            logInfo["reportType"] = reportType
            logInfo["reportInfo"] = reportInfo

            self.log(logType, logInfo)

    def logPrep(self, useLog, obj, func, returned, *args, **kwargs):
        """
        Log information about a data preparation step performed.

        If this will be logged, store an entry in the database with
        "prep" as the logType and a dictionary (stored as a string) of
        the preprocessing function called and its arguments as the
        logInfo.

        Parameters
        ----------
        obj : Base, Points, Features
            The calling object.
        func : str
            The name of the method being called.
        """
        if loggingEnabled(useLog):
            logType = "prep"
            logInfo = {}
            if hasattr(obj, '_base'):
                if 'features' in obj.__class__.__name__.lower():
                    function = f'features.{func}'
                else:
                    function = f'points.{func}'
                logInfo.update(identifyObject(obj._base))
            else:
                function = func
                logInfo.update(identifyObject(obj))

            logInfo["function"] = function
            logIDs = []
            arguments = _buildArgDict(getattr(obj, func), logIDs, *args,
                                      **kwargs)
            logInfo["arguments"] = arguments
            if returned is not None:
                logInfo["returned"] = identifyReturnedData(returned, logIDs)
            if logIDs:
                # _logIDs are for searchability and not displayed in the output
                logInfo["_logIDs"] = logIDs

            self.log(logType, logInfo)

    def _logRun(self, logType, useLog, nimbleFunction, trainData, trainLabels,
                testData, testLabels, learnerFunction, arguments, randomSeed,
                metrics, extraInfo, time, returned=None):
        if loggingEnabled(useLog):
            logInfo = {}
            logInfo["function"] = nimbleFunction
            if isinstance(learnerFunction, str):
                functionCall = learnerFunction
            else: # learner object was provided directly
                try:
                    name = learnerFunction.__name__
                    module = learnerFunction.__module__.split('.')[0]
                    package = 'custom'
                    for interface in nimble.core.interfaces.available.values():
                        if interface.isAlias(module):
                            package = interface.getCanonicalName()
                    functionCall = package + '.' + name
                # the above should cover all expected cases, but for safety we
                # will catch any exceptions to prevent a successful operation
                # from failing here due to a logging issue
                except Exception: # pylint: disable=broad-except
                    functionCall = "Unable to determine learner name"
            logInfo["learner"] = functionCall
            # integers or strings passed for Y values, convert if necessary
            if isinstance(trainLabels, (str, int, np.int64)):
                trainData = trainData.copy()
                trainLabels = trainData.features.extract(trainLabels,
                                                         useLog=False)
            if isinstance(testLabels, (str, int, np.int64)):
                testData = testData.copy()
                testLabels = testData.features.extract(testLabels,
                                                       useLog=False)
            if trainData is not None:
                logInfo["trainData"] = trainData.name
                logInfo["trainDataPoints"] = len(trainData.points)
                logInfo["trainDataFeatures"] = len(trainData.features)
            if trainLabels is not None:
                logInfo["trainLabels"] = trainLabels.name
                logInfo["trainLabelsPoints"] = len(trainLabels.points)
                logInfo["trainLabelsFeatures"] = len(trainLabels.features)
            if testData is not None:
                logInfo["testData"] = testData.name
                logInfo["testDataPoints"] = len(testData.points)
                logInfo["testDataFeatures"] = len(testData.features)
            if testLabels is not None:
                logInfo["testLabels"] = testLabels.name
                logInfo["testLabelsPoints"] = len(testLabels.points)
                logInfo["testLabelsFeatures"] = len(testLabels.features)

            if arguments is not None and arguments:
                arguments = arguments.copy() # don't modify original dict
                logInfo['arguments'] = literalOnlyArguments(arguments)

            if randomSeed is not None and randomSeed:
                logInfo['randomSeed'] = randomSeed
            if metrics is not None and metrics:
                logInfo["metrics"] = metrics
            if extraInfo is not None and extraInfo:
                logInfo["extraInfo"] = extraInfo
            if time is not None:
                logInfo["time"] = time
            logIDs = []
            if returned is not None:
                logInfo['returned'] = identifyReturnedData(returned, logIDs)
            if logIDs:
                # _logIDs are for searchability and not displayed in the output
                logInfo['_logIDs'] = logIDs

            self.log(logType, logInfo)

    def logRun(self, useLog, nimbleFunction, trainData, trainLabels, testData,
               testLabels, learnerFunction, arguments, randomSeed=None,
               metrics=None, extraInfo=None, time=None, returned=None):
        """
        Log information about each run.

        If this will be logged, store an entry in the database with
        "run" as the logType and a dictionary (stored as a string) of
        the learner function called and its arguments as the logInfo.

        Parameters
        ----------
        nimbleFunction : str
            The name of the nimble function called.
        trainData : nimble data object
            The object containing the training data.
        trainLabels : nimble data object, int
            The object or feature in ``trainData`` containing the
            training labels.
        testData : nimble data object
            The object containing the testing data.
        testLabels : nimble data object, int
            The object or feature in ``testData`` containing the
            training labels.
        learnerFunction : str
            The name of learner function.
        arguments : dict
            The arguments passed to the learner.
        metrics : dict
            The results of the testing on a run.
        extraInfo : dict
            Any additional information to add to the log. For each pair
            a new line in the format "key: value" is displayed.
        time : float, None
            The time to run the function. None if function is not timed.
        returned
            The return of the function call.
        """
        self._logRun("run", useLog, nimbleFunction, trainData, trainLabels,
                     testData, testLabels, learnerFunction, arguments,
                     randomSeed, metrics, extraInfo, time, returned)

    def logDeepRun(self, useLog, nimbleFunction, trainData, trainLabels,
                   testData, testLabels, learnerFunction, arguments,
                   randomSeed, metrics=None, extraInfo=None, time=None):
        """
        Log information about each run during cross-validation.

        If this will be logged, store an entry in the database with
        "deepRun" as the logType and a dictionary (stored as a string)
        of the learner function called and its arguments as the logInfo.

        Parameters
        ----------
        nimbleFunction : str
            The name of the nimble function called.
        trainData : nimble data object
            The object containing the training data.
        trainLabels : nimble data object, int
            The object or feature in ``trainData`` containing the
            training labels.
        testData : nimble data object
            The object containing the testing data.
        testLabels : nimble data object, int
            The object or feature in ``testData`` containing the
            training labels.
        learnerFunction : str
            The name of learner function.
        arguments : dict
            The arguments passed to the learner.
        metrics : dict
            The results of the testing on a run.
        extraInfo : dict
            Any additional information to add to the log. For each pair
            a new line in the format "key: value" is displayed.
        time : float, None
            The time to run the function. None if function is not timed.
        """
        self._logRun("deepRun", useLog, nimbleFunction, trainData, trainLabels,
                     testData, testLabels, learnerFunction, arguments,
                     randomSeed, metrics, extraInfo, time)

    def logTLRun(self, useLog, tlObject, method, arguments, trainData=None,
                 trainLabels=None, testData=None, testLabels=None,
                 randomSeed=None, metrics=None, extraInfo=None, time=None,
                 returned=None):
        """
        Log information for calls to TrainedLearner methods.

        If this will be logged, store an entry in the database with
        "run" as the logType and a dictionary (stored as a string) of
        the learner function called and its arguments as the logInfo.

        Parameters
        ----------
        tlObject : TrainedLearner
            The TrainedLearner object making the call.
        method : str
            The name of the nimble function called.
        arguments : dict
            The arguments passed to the learner.
        trainData : nimble data object
            The object containing the training data.
        trainLabels : nimble data object, int
            The object or feature in ``trainData`` containing the
            training labels.
        testData : nimble data object
            The object containing the testing data.
        testLabels : nimble data object, int
            The object or feature in ``testData`` containing the
            training labels.
        metrics : dict
            The results of the testing on a run.
        extraInfo : dict
            Any additional information to add to the log. For each pair
            a new line in the format "key: value" is displayed.
        time : float, None
            The time to run the function. None if function is not timed.
        returned
            The return of the function call.
        """
        funcName = f'{tlObject.logID}.{method}'
        interfaceName = tlObject._interface.getCanonicalName()
        learnerFunction = f'{interfaceName}.{tlObject.learnerName}'
        self._logRun("run", useLog, funcName, trainData, trainLabels, testData,
                     testLabels, learnerFunction, arguments, randomSeed,
                     metrics, extraInfo, time, returned)

    def logTuning(self, useLog, selector, validator):
        """
        Log the results of cross validation.

        If this will be logged, store an entry in the database with
        "tuning" as the logType and a dictionary (stored as a string).

        Parameters
        ----------
        selector: nimble.core.tune.ArgumentSelector
        validator: nimble.core.tune.Validator
        """
        if loggingEnabled(useLog):
            logType = "tuning"
            logInfo = {}
            logInfo["selection"] = selector.name
            logInfo["selectionArgs"] = {}
            for name, arg in selector._logInfo.items():
                if isinstance(arg, nimble.core.data.Base):
                    logInfo["selectionArgs"][name] = _BaseNameOrType(arg)
                else:
                    logInfo["selectionArgs"][name] = arg
            logInfo["validation"] = validator.name
            logInfo["validationArgs"] = {}
            for name, arg in validator._logInfo.items():
                if isinstance(arg, nimble.core.data.Base):
                    logInfo["validationArgs"][name] = _BaseNameOrType(arg)
                else:
                    logInfo["validationArgs"][name] = arg
            logInfo["learnerName"] = validator.learnerName
            performanceFunction = validator.performanceFunction
            logInfo["metric"] = (performanceFunction.optimal,
                                 performanceFunction.__name__)
            logInfo["performances"] = list(
                zip(validator._results,
                    literalOnlyArguments(validator._arguments)))

            self.log(logType, logInfo)

    def logRandomSeed(self, useLog, action, seed):
        """
        Log the random seed value.

        If this will be logged, this uses the default log settings .

        action : str
            A description of the action that is changing the state of
            the random seed.
        seed : int
            The random seed value.
        """
        if loggingEnabled(useLog):
            logType = 'setSeed'
            logInfo = {'action': action, 'seed': seed}
            self.log(logType, logInfo)

    ###################
    ### LOG OUTPUT ###
    ##################

    def showLog(self, levelOfDetail=2, leastSessionsAgo=0, mostSessionsAgo=2,
                startDate=None, endDate=None, maximumEntries=100,
                searchForText=None, regex=False, saveToFileName=None,
                append=False):
        """
        Output data from the logger.

        Parse the log based on the arguments passed and print a human
        readable interpretation of the log file.

        Parameters
        ----------
        levelOfDetail:  int
            The value for the level of detail from 1, the least detail,
            to 3 (most detail). Default is 2.
            * Level 1 - Data loading, data preparation and
              preprocessing, custom user logs.
            * Level 2 - Outputs basic information about learner runs.
              Includes timestamp, session number, learner name, train
              and test object details, parameter, metric, and timer data
              if available.
            * Level 3 - Include cross-validation data.
        leastSessionsAgo : int
            The least number of sessions since the most recent session
            to include in the log. Default is 0.
        mostSessionsAgo : int
            The most number of sessions since the most recent session to
            include in the log. Default is 2.
        startDate :  str, datetime
            A string or datetime object of the date to begin adding
            sessions from the log.
            Acceptable formats:
            * "YYYY-MM-DD"
            * "YYYY-MM-DD HH:MM"
            * "YYYY-MM-DD HH:MM:SS"
        endDate : str, datetime
            A string or datetime object of the date to stop adding
            sessions from the log.
            See ``startDate`` for formatting.
        maximumEntries : int
            Maximum number of entries to allow before stopping the log.
            None will allow all entries provided from the query. Default
            is 100.
        searchForText :  str, regex
            Search for in each log entry. Default is None.
        saveToFileName : str
            The name of a file to write the human readable log. It will
            be saved in the same directory as the logger database.
            Default is None, showLog will print to standard out.
        append : bool
            Append logs to the file in saveToFileName instead of
            overwriting file. Default is False.
        """

        if not self.isAvailable:
            self.setup()

        query, values = _showLogQueryAndValues(leastSessionsAgo,
                                               mostSessionsAgo, startDate,
                                               endDate, maximumEntries,
                                               searchForText, regex)
        sessionLogs = self.extractFromLog(query, values)

        logOutput = _showLogOutputString(sessionLogs, levelOfDetail, append)

        if saveToFileName is not None:
            filePath = os.path.join(self.logLocation, saveToFileName)
            if append:
                with open(filePath, mode='a', encoding='utf-8') as f:
                    f.write("\n")
                    f.write(logOutput)
            else:
                with open(filePath, mode='w', encoding='utf-8') as f:
                    f.write(logOutput)
        else:
            print(logOutput)

###################
### LOG HELPERS ###
###################

def loggingEnabled(useLog):
    """
    Access useLog value from configuration, if not explictly defined.
    """
    if useLog is None:
        useLog = nimble.settings.get("logger", "enabledByDefault")
        useLog = useLog.lower() == 'true'
    return useLog

def deepLoggingEnabled():
    """
    Access enableDeepLogging value from configuration.
    """
    deepLog = nimble.settings.get("logger", "enableDeepLogging")

    return deepLog.lower() == 'true'

def handleLogging(useLog, logType, *args, **kwargs):
    """
    Store information to be logged in the logger.
    """
    if loggingEnabled(useLog):
        logFunc = nimble.core.logger.active.logTypes[logType]
        logFunc(useLog, *args, **kwargs)

def stringToDatetime(string):
    """
    Convert a string into a datetime object.

    The format must be YYYY-MM-DD', 'YYYY-MM-DD HH:MM', or
    'YYYY-MM-DD HH:MM:SS'. Therefore, only 3 valid string lengths are
    possible. Any string not that length will fail the first assertion.
    Otherwise, the string will be parsed storing the locations of valid
    values as arguments to pass to datetime.datetime. The remaining
    three assertions will fail if the dividers are invalid. To create
    the object, integer arguments are required. A ValueError is raised
    if any value cannot be converted to an integer. Last, an attempt to
    create the datetime.datetime object is made, if it deems a value to
    be invalid (i.e a date that doesn't exist) this will also raise a
    ValueError.
    """
    string = string.strip()

    datetimeArgs = []
    dateDividers = []
    dateTimeDivider = None
    timeDividers = []

    if len(string) in [10, 16, 19]:
        datetimeArgs.append(string[:4])
        dateDividers.append(string[4])
        datetimeArgs.append(string[5:7])
        dateDividers.append(string[7])
        datetimeArgs.append(string[8:10])
        if len(string) > 10:
            dateTimeDivider = string[10]
            datetimeArgs.append(string[11:13])
            timeDividers.append(string[13])
            datetimeArgs.append(string[14:16])
        if len(string) > 16:
            timeDividers.append(string[16])
            datetimeArgs.append(string[17:])

    try:
        assert datetimeArgs
        assert all(div == "-" for div in dateDividers)
        if dateTimeDivider is not None:
            assert dateTimeDivider == " "
        if timeDividers:
            assert all(div == ":" for div in timeDividers)
        datetimeArgs = list(map(int, datetimeArgs))

        return datetime.datetime(*datetimeArgs)

    except (AssertionError, ValueError) as e:
        msg = "Invalid datetime format. The accepted formats are: "
        msg += "'YYYY-MM-DD', 'YYYY-MM-DD HH:MM', or 'YYYY-MM-DD HH:MM:SS'"
        raise InvalidArgumentValue(msg) from e


def identifyObject(obj):
    """
    The identifier will be name when available otherwise logID.

    The logID is always added to the log as well, this allows for object
    identification even if duplicate names are used.
    """
    identification = {}
    if hasattr(obj, 'name') and obj.name is not None:
        identification["identifier"] = obj.name
        identification["logID"] = obj.logID
    else:
        identification["identifier"] = obj.logID

    return identification

def identifyReturnedData(returned, logIDs):
    """
    Identify any nimble data or trainedlearner objects returned.
    """
    if isinstance(returned, tuple):
        objs = []
        for item in returned:
            if hasattr(item, 'logID'):
                identification = identifyObject(item)
                s = identification["identifier"]
                if "logID" in identification:
                    logIDs.append(identification['logID'])
                objs.append(s)
        return ', '.join(objs)
    if hasattr(returned, 'logID'):
        return identifyObject(returned)['identifier']
    return None

def _showLogQueryAndValues(leastSessionsAgo, mostSessionsAgo, startDate,
                           endDate, maximumEntries, searchForText, regex):
    """
    Constructs the query string and stores the variables based on the
    arguments passed to the showLog function.
    """
    selectQuery = "SELECT timestamp, sessionNumber, logType, logInfo "
    selectQuery += "FROM (SELECT * FROM logger"
    whereQueryList = []
    includedValues = []
    if leastSessionsAgo is not None:
        # final session value
        # difference between the next sessionNumber and leastSessionsAgo
        where = "sessionNumber <= "
        where += "((SELECT MAX(sessionNumber) FROM logger) - ?)"
        whereQueryList.append(where)
        includedValues.append(leastSessionsAgo)
    if mostSessionsAgo is not None:
        # starting session value
        # difference between the next sessionNumber and mostSessionsAgo
        where = "sessionNumber > ((SELECT MAX(sessionNumber) FROM logger) - ?)"
        whereQueryList.append(where)
        includedValues.append(mostSessionsAgo)
    if startDate is not None:
        whereQueryList.append("timestamp >= ?")
        includedValues.append(stringToDatetime(startDate))
    if endDate is not None:
        whereQueryList.append("timestamp <= ?")
        includedValues.append(stringToDatetime(endDate))
    if searchForText is not None:
        # convert to regex and get pattern
        if regex:
            searchForText = re.compile(searchForText).pattern
            whereQueryList.append("(logType REGEXP ? or logInfo REGEXP ?)")
        else:
            searchForText = "%" + searchForText + "%"
            whereQueryList.append("(logType LIKE ? or logInfo LIKE ?)")
        includedValues.append(searchForText)
        includedValues.append(searchForText)

    if whereQueryList:
        whereQuery = " and ".join(whereQueryList)
        fullQuery = selectQuery + " WHERE " + whereQuery
    else:
        fullQuery = selectQuery

    if maximumEntries is not None:
        fullQuery += " ORDER BY entry DESC "
        fullQuery += "LIMIT ?"
        includedValues.append(maximumEntries)
    fullQuery += ") ORDER BY entry ASC;"
    includedValues = tuple(includedValues)

    return fullQuery, includedValues

def _buildLoadLogString(timestamp, entry):
    """
    Constructs the string that will be output for load logTypes.
    """
    fullLog = _logHeader(f"Loaded: {entry['identifier']}", timestamp)
    line = '{:<14} {}\n'
    fullLog += line.format("# of points", entry["numPoints"])
    fullLog += line.format("# of features", entry["numFeatures"])
    for title, val in entry.items():
        if (title not in ['identifier', 'numPoints', 'numFeatures']
                and val is not None):
            fullLog += title + ' ' * (15 - len(title))
            fullLog += textwrap.fill(str(val), 64, subsequent_indent=" "*15)
            fullLog += '\n'
    return fullLog

def _buildTrainedLearnerLogString(timestamp, entry):
    fullLog = _logHeader(f"Loaded: {entry['identifier']}", timestamp)
    fullLog += _formatSessionLine("Learner name", entry["learnerName"])
    if entry.get('learnerArgs', None) is not None:
        argString = "Arguments: "
        argString += _dictToKeywordString(entry["learnerArgs"])
        fullLog += textwrap.fill(argString, 79, subsequent_indent=" "*11)
        fullLog += "\n"
    return fullLog

def _buildPrepLogString(timestamp, entry):
    """
    Constructs the string that will be output for prep logTypes.
    """
    function = f"{entry['identifier']}.{entry['function']}"
    fullLog = _logHeader(function, timestamp)
    if entry['arguments']:
        argString = "Arguments: "
        argString += _dictToKeywordString(entry["arguments"])
        fullLog += textwrap.fill(argString, 79, subsequent_indent=" "*11)
        fullLog += "\n"
    if 'returned' in entry:
        argString = "Returned: " + str(entry["returned"])
        fullLog += textwrap.fill(argString, 79, subsequent_indent=" "*10)
        fullLog += "\n"
    return fullLog

def _buildReportLogString(timestamp, entry):
    """
    Constructs the string that will be output for report logTypes.
    """
    reportName = entry["reportType"].capitalize() + " Report"
    fullLog = _logHeader(reportName, timestamp)
    fullLog += "\n"
    fullLog += entry["reportInfo"]
    return fullLog

def _buildRunLogString(timestamp, entry):
    """
    Constructs the string that will be output for run logTypes.
    """
    # header data
    run = f"""{entry['function']}("{entry['learner']}")"""
    fullLog = _logHeader(run, timestamp)
    time = entry.get("time", None)
    if time is not None:
        fullLog += f"Completed in {time:.3f} seconds\n"
    fullLog += "\n"
    # train and test data
    fullLog += _formatSessionLine("Data", "# points", "# features")
    if "trainData" in entry:
        if entry["trainData"] is None:
            fullLog += _formatSessionLine("trainX", entry["trainDataPoints"],
                                          entry["trainDataFeatures"])
        else:
            fullLog += _formatSessionLine(entry["trainData"],
                                          entry["trainDataPoints"],
                                          entry["trainDataFeatures"])
    if "trainLabels" in entry:
        if entry["trainLabels"] is None:
            fullLog += _formatSessionLine("trainY", entry["trainLabelsPoints"],
                                          entry["trainLabelsFeatures"])
        else:
            fullLog += _formatSessionLine(entry["trainLabels"],
                                          entry["trainLabelsPoints"],
                                          entry["trainLabelsFeatures"])
    if "testData" in entry:
        if entry["testData"] is None:
            fullLog += _formatSessionLine("testX", entry["testDataPoints"],
                                          entry["testDataFeatures"])
        else:
            fullLog += _formatSessionLine(entry["testData"],
                                          entry["testDataPoints"],
                                          entry["testDataFeatures"])
    if "testLabels" in entry:
        if entry["testLabels"] is None:
            fullLog += _formatSessionLine("testY", entry["testLabelsPoints"],
                                          entry["testLabelsFeatures"])
        else:
            fullLog += _formatSessionLine(entry["testLabels"],
                                          entry["testLabelsPoints"],
                                          entry["testLabelsFeatures"])
    fullLog += "\n"

    # parameter data
    if entry.get("arguments", False):
        argString = "Arguments: "
        argString += _dictToKeywordString(entry["arguments"])
        fullLog += textwrap.fill(argString, 79, subsequent_indent=" "*11)
        fullLog += "\n"
    # randomSeed
    if entry.get("randomSeed", False):
        fullLog += "Random Seed: " + str(entry["randomSeed"])
        fullLog += "\n"
    # extraInfo
    if entry.get("extraInfo", False):
        for key, value in entry["extraInfo"].items():
            fullLog += f'{key}: {value}'
            fullLog += "\n"
    # metric data
    if entry.get("metrics", False):
        fullLog += "Metrics: "
        fullLog += _dictToKeywordString(entry["metrics"])
        fullLog += "\n"
    # returned objects (apply)
    if entry.get("returned", False):
        fullLog += "Returned: " + entry["returned"]
        fullLog += "\n"

    return fullLog

def _buildTuneLogString(timestamp, entry):
    """
    Constructs the string that will be output for tuning logTypes.
    """
    if len(entry["performances"]) > 1:
        heading =  f'''"{entry['learnerName']}" Hyperparameter Tuning'''
        fullLog = _logHeader(heading, timestamp)
        fullLog += "\n"
        description = f'''Tuned using the "{entry['selection']}" method'''
        if entry["selectionArgs"]:
            selectionArgs = _dictToKeywordString(entry["selectionArgs"])
            description += f' ({selectionArgs})'
        description += ' and v' # continue to validation with lowercase v
    else: # no tuning only validation occurred
        fullLog = _logHeader(entry["learnerName"] + " Validation", timestamp)
        description = 'V' # start validation with capital letter
    description += f'''alidated using the "{entry['validation']}" method'''
    if entry["validationArgs"]:
        validationArgs = _dictToKeywordString(entry["validationArgs"])
        description += f' ({validationArgs})'
    optimal, funcName = entry["metric"]
    description += f'. The {funcName} function was used to calculate '
    description += f'each result, with {optimal} values being optimal.'
    fullLog += textwrap.fill(description, 79)
    fullLog += "\n"
    fullLog += f"{'Result':<16s}Arguments\n"
    for perf, args in entry["performances"]:
        argString = _dictToKeywordString(args) if args else "{}"
        if len(argString) > 63:
            argString = textwrap.fill(argString, 63, subsequent_indent=' '*16)
        fullLog += f"{perf:<16.3f}{argString}"
        fullLog += "\n"
    return fullLog

def _buildSetSeedLogString(timestamp, entry):
    """
    Constructs the string that will be output for setSeed logTypes.
    """
    asHeader = f'{entry["action"]}(seed={entry["seed"]})'
    fullLog = _logHeader(asHeader, timestamp)
    return fullLog

def _buildDefaultLogString(timestamp, logType, entry):
    """
    Constructs the string that will be output for any unrecognized
    logTypes. Formatting varies based on string, list and dictionary
    types passed as the log.
    """
    fullLog = _logHeader(logType, timestamp)
    if isinstance(entry, str):
        fullLog += textwrap.fill(entry, 79)
        fullLog += "\n"
    elif isinstance(entry, list):
        listString = _formatSessionLine(entry)
        fullLog += textwrap.fill(listString, 79)
        fullLog += "\n"
    else:
        dictString = _dictToKeywordString(entry)
        fullLog += textwrap.fill(dictString, 79)
        fullLog += "\n"
    return fullLog

def _dictToKeywordString(dictionary):
    """
    Formats dictionaries to be more human-readable.
    """
    kvStrings = []
    for key, value in dictionary.items():
        string = f"{key}={value}"
        kvStrings.append(string)
    return ", ".join(kvStrings)

def _formatSessionLine(*args):
    """
    Formats equally spaced values for each column.
    """
    args = list(map(str, args))
    lineLog = ""
    equalSpace = int(79 / len(args))
    for arg in args:
        whitespace = equalSpace - len(arg)
        if len(arg) < equalSpace:
            lineLog += arg + " " * whitespace
        else:
            lineLog += arg[:equalSpace - 4] + "... "
    lineLog += "\n"

    return lineLog

def _logHeader(left, right):
    """
    Formats the first line of each log entry.
    """
    lineLog = "\n"
    lineLog += f"{left:60}{right:>19}\n"
    return lineLog

def _buildArgDict(func, logIDs, *args, **kwargs):
    """
    Creates the dictionary of arguments for the prep logType. Adds all
    required arguments and any keyword arguments that are not the
    default values.

    Parameters
    ----------
    argNames : tuple
        The names of all arguments in the function.
    defaults : tuple
        The default values of the arguments.
    """
    argNames, _, _, defaults = nimble._utility.inspectArguments(func)
    argNames = argNames[1:] # ignore self arg
    nameArgMap = {}
    for name, arg in zip(argNames, args):
        nameArgMap[name] = arg
    nameArgMap.update(kwargs)

    defaultDict = {}
    if defaults:
        startDefaults = len(argNames) - len(defaults)
        defaultArgs = argNames[startDefaults:]
        for name, value in zip(defaultArgs, defaults):
            defaultDict[name] = value

    argDict = {}
    for name, arg in nameArgMap.items():
        if name in defaultDict:
            try:
                if arg == defaultDict[name]:
                    continue
            except TypeError:
                pass
        if callable(arg):
            string = _extractFunctionString(arg)
        elif isinstance(arg, nimble.core.data.Base):
            if arg.name is not None:
                string = arg.name
                logIDs.append(arg.logID)
            else:
                string = arg.logID
        else:
            string = str(arg)

        argDict[name] = string

    return argDict

def _extractFunctionString(function):
    """
    Extracts function name or lambda function if passed a function,
    Otherwise returns a string.
    """
    try:
        functionName = function.__name__
        if functionName == "<lambda>":
            return _lambdaFunctionString(function)
        return functionName
    except AttributeError:
        return str(function)

def _lambdaFunctionString(function):
    """
    Returns a string of a lambda function.

    The lambda function would appear after a call to a nimble function,
    such as calculate(). Because of this, some items on the source line
    may be unrelated to lambda function. For example,
    calculate(lambda x: x + 1, features=0). The end of the lambda
    function occurs either when the open parenthesis from calculate is
    closed or a comma occurs that is not nested within a data structure.
    """
    try:
        sourceLine = inspect.getsourcelines(function)[0][0]
        line = re.findall(r'lambda.*', sourceLine)[0]
        lambdaString = ""
        afterColon = False
        # lambda always starts after open parenthesis
        isOpen = 1
        openers = ['(', '[', '{']
        closers = [')', ']', '}']
        for letter in line:
            if letter in openers:
                isOpen += 1
            elif letter in closers:
                isOpen -= 1
            elif letter == ":":
                afterColon = True
            elif letter == "," and afterColon and isOpen == 1:
                # everything else is not part of lambda
                return lambdaString
            if isOpen == 0:
                return lambdaString
            lambdaString += letter
    except OSError:
        lambdaString = "<lambda>"
    return lambdaString

logBuilders = {'load': (_buildLoadLogString, 1),
               'tl': (_buildTrainedLearnerLogString, 1),
               'report': (_buildReportLogString, 1),
               'prep': (_buildPrepLogString, 2),
               'run': (_buildRunLogString, 2),
               'deepRun': (_buildRunLogString, 3),
               'tuning': (_buildTuneLogString, 2),
               'setSeed': (_buildSetSeedLogString, 1)}

def _showLogOutputString(listOfLogs, levelOfDetail, append):
    """
    Formats the string that will be output for calls to the showLog
    function.
    """
    fullLog = ""
    if not append:
        fullLog = f"{'NIMBLE LOGS':^79}\n"
        fullLog += "." * 79
    previousLogSessionNumber = None
    for entry in listOfLogs:
        timestamp = entry[0]
        sessionNumber = entry[1]
        logType = entry[2]
        logString = entry[3]
        try:
            logInfo = literal_eval(logString)
        except (ValueError, SyntaxError):
            # logString is a string (cannot eval)
            logInfo = logString
        if sessionNumber != previousLogSessionNumber:
            # skip first new line if appending because append inserts newline
            if not (previousLogSessionNumber is None and append):
                fullLog += "\n"
            logString = f"SESSION {sessionNumber}"
            fullLog += f".{logString:^77}.\n"
            fullLog += "." * 79
            previousLogSessionNumber = sessionNumber
        try:
            if logType in logBuilders:
                stringBuilder, level = logBuilders[logType]
                if levelOfDetail >= level:
                    fullLog += stringBuilder(timestamp, logInfo)
                    fullLog += '.' * 79
            else:
                fullLog += _buildDefaultLogString(timestamp, logType, logInfo)
                fullLog += '.' * 79
        except (TypeError, KeyError):
            fullLog += _buildDefaultLogString(timestamp, logType, logInfo)
            fullLog += '.' * 79

    return fullLog

def literalOnlyArguments(arguments):
    """
    Store logged argument values in the most readable way.
    """
    arguments = arguments.copy() # don't modify original
    if isinstance(arguments, dict):
        for name, value in arguments.items():
            if isinstance(value, (dict, list)):
                value = literalOnlyArguments(value)
            try:
                literal_eval(repr(value))
                arguments[name] = value
            except (ValueError, SyntaxError):
                # use repr for objects which cannot eval
                arguments[name] = repr(value)
    else:
        for i, value in enumerate(arguments):
            if isinstance(value, (dict, list)):
                value = literalOnlyArguments(value)
            try:
                literal_eval(repr(value))
                arguments[i] = value
            except (ValueError, SyntaxError):
                # use repr for objects which cannot eval
                arguments[i] = repr(value)
    return arguments

#######################
### Initialization  ###
#######################

def initLoggerAndLogConfig():
    """
    Sets up or reads configuration options associated with logging, and
    initializes the currently active logger object using those options.
    """
    try:
        logSettings = nimble.settings.get('logger')
    except NoSectionError:
        logSettings = {}

    location = logSettings.get('location', "")
    if not location:
        location = './logs-nimble'
        nimble.settings.setDefault("logger", "location", location)
    nimble.settings.hook("logger", "location", cleanThenReInitLoc)

    name = logSettings.get('name', "")
    if not name:
        name = "log-nimble"
        nimble.settings.setDefault("logger", "name", name)
    nimble.settings.hook("logger", "name", cleanThenReInitName)

    if not logSettings.get('enabledByDefault', ""):
        nimble.settings.setDefault("logger", "enabledByDefault", 'True')

    if not logSettings.get('enableDeepLogging', ""):
        nimble.settings.setDefault("logger", 'enableDeepLogging', 'False')

    nimble.core.logger.active = SessionLogger(location, name)


def cleanThenReInitLoc(newLocation):
    """
    Hook for setting a new location of the active logger.
    """
    nimble.core.logger.active.cleanup()
    currName = nimble.settings.get("logger", 'name')
    nimble.core.logger.active = SessionLogger(newLocation, currName)


def cleanThenReInitName(newName):
    """
    Hook for setting a new name of the active logger.
    """
    nimble.core.logger.active.cleanup()
    currLoc = nimble.settings.get("logger", 'location')
    nimble.core.logger.active = SessionLogger(currLoc, newName)

class LogID:
    """
    Descriptor to generate an id for user objects.

    Best practice is to only call the object attribute associated with
    this descriptor when the logging is occurring. Calling it within the
    object methods can generate unused IDs and sequential ID ordering in
    the log will be lost.
    """
    def __init__(self, idString):
        self.idString = idString
        self.idNumbers = itertools.count()

    def __get__(self, obj, objtype=None):
        if obj is None: # if getting from class not instance
            return None
        if not hasattr(obj, '_logID'):
            obj._logID = next(self.idNumbers)
        return f'_{self.idString}_{obj._logID}_'
