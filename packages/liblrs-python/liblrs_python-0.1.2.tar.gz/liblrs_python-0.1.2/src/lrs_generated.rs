// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENDPOINT: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENDPOINT: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENDPOINT: [Endpoint; 2] = [
  Endpoint::Begin,
  Endpoint::End,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Endpoint(pub i8);
#[allow(non_upper_case_globals)]
impl Endpoint {
  pub const Begin: Self = Self(1);
  pub const End: Self = Self(2);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Begin,
    Self::End,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Begin => Some("Begin"),
      Self::End => Some("End"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Endpoint {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Endpoint {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Endpoint {
    type Output = Endpoint;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Endpoint {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Endpoint {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Endpoint {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIRECTION: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIRECTION: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTION: [Direction; 2] = [
  Direction::Increasing,
  Direction::Decreasing,
];

/// A traversal is a path in a network.
/// Traversals may be used to model roads, railway tracks, railway lines or trips.
/// Traversals are defined as a sequence of segment and direction pairs.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Direction(pub i8);
#[allow(non_upper_case_globals)]
impl Direction {
  pub const Increasing: Self = Self(1);
  pub const Decreasing: Self = Self(2);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Increasing,
    Self::Decreasing,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Increasing => Some("Increasing"),
      Self::Decreasing => Some("Decreasing"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Direction {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Direction {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Direction {
    type Output = Direction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Direction {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Direction {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Direction {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DISTANCE_UNIT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DISTANCE_UNIT: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DISTANCE_UNIT: [DistanceUnit; 2] = [
  DistanceUnit::Meters,
  DistanceUnit::MilliMeters,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DistanceUnit(pub i8);
#[allow(non_upper_case_globals)]
impl DistanceUnit {
  pub const Meters: Self = Self(0);
  pub const MilliMeters: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Meters,
    Self::MilliMeters,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Meters => Some("Meters"),
      Self::MilliMeters => Some("MilliMeters"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DistanceUnit {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DistanceUnit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DistanceUnit {
    type Output = DistanceUnit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DistanceUnit {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DistanceUnit {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DistanceUnit {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GEOMETRY_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GEOMETRY_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOMETRY_TYPE: [GeometryType; 2] = [
  GeometryType::Geographic,
  GeometryType::Schematic,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeometryType(pub i8);
#[allow(non_upper_case_globals)]
impl GeometryType {
  pub const Geographic: Self = Self(1);
  pub const Schematic: Self = Self(2);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Geographic,
    Self::Schematic,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Geographic => Some("Geographic"),
      Self::Schematic => Some("Schematic"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GeometryType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GeometryType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GeometryType {
    type Output = GeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeometryType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GeometryType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometryType {}
// struct NodeRef, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct NodeRef(pub [u8; 16]);
impl Default for NodeRef { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for NodeRef {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("NodeRef")
      .field("network_index", &self.network_index())
      .field("node_index", &self.node_index())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for NodeRef {}
impl<'a> flatbuffers::Follow<'a> for NodeRef {
  type Inner = &'a NodeRef;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a NodeRef>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a NodeRef {
  type Inner = &'a NodeRef;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<NodeRef>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for NodeRef {
    type Output = NodeRef;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const NodeRef as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for NodeRef {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> NodeRef {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    network_index: u32,
    node_index: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_network_index(network_index);
    s.set_node_index(node_index);
    s
  }

  pub fn network_index(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_network_index(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn node_index(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_node_index(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct TraversalRef, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct TraversalRef(pub [u8; 16]);
impl Default for TraversalRef { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for TraversalRef {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("TraversalRef")
      .field("network_index", &self.network_index())
      .field("traversal_index", &self.traversal_index())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TraversalRef {}
impl<'a> flatbuffers::Follow<'a> for TraversalRef {
  type Inner = &'a TraversalRef;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a TraversalRef>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a TraversalRef {
  type Inner = &'a TraversalRef;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<TraversalRef>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for TraversalRef {
    type Output = TraversalRef;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const TraversalRef as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for TraversalRef {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> TraversalRef {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    network_index: u32,
    traversal_index: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_network_index(network_index);
    s.set_traversal_index(traversal_index);
    s
  }

  pub fn network_index(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_network_index(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn traversal_index(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_traversal_index(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Point, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Point(pub [u8; 24]);
impl Default for Point { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl core::fmt::Debug for Point {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Point")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Point {}
impl<'a> flatbuffers::Follow<'a> for Point {
  type Inner = &'a Point;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Point>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Point {
  type Inner = &'a Point;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Point>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Point {
    type Output = Point;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Point as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Point {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Point {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
    z: f64,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum PropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Property<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Property<'a> {
  type Inner = Property<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Property<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Property { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PropertyArgs<'args>
  ) -> flatbuffers::WIPOffset<Property<'bldr>> {
    let mut builder = PropertyBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Property) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_VALUE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Property<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, true)?
     .finish();
    Ok(())
  }
}
pub struct PropertyArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PropertyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PropertyArgs {
      key: None, // required field
      value: None, // required field
    }
  }
}

pub struct PropertyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PropertyBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PropertyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Property::VT_KEY,"key");
    self.fbb_.required(o, Property::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Property<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Property");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum LrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Lrs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Lrs<'a> {
  type Inner = Lrs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Lrs<'a> {
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 4;
  pub const VT_NETWORKS: flatbuffers::VOffsetT = 6;
  pub const VT_ANCHORS: flatbuffers::VOffsetT = 8;
  pub const VT_LINEAR_REFERENCING_METHODS: flatbuffers::VOffsetT = 10;
  pub const VT_VIEWS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Lrs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LrsArgs<'args>
  ) -> flatbuffers::WIPOffset<Lrs<'bldr>> {
    let mut builder = LrsBuilder::new(_fbb);
    if let Some(x) = args.views { builder.add_views(x); }
    if let Some(x) = args.linear_referencing_methods { builder.add_linear_referencing_methods(x); }
    if let Some(x) = args.anchors { builder.add_anchors(x); }
    if let Some(x) = args.networks { builder.add_networks(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    builder.finish()
  }


  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Lrs::VT_PROPERTIES, None)}
  }
  /// Networks are segments connected by nodes.
  /// There can be multiple networks, such as railway tracks and lines, sewer pipe and power lines.
  #[inline]
  pub fn networks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Network<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Network>>>>(Lrs::VT_NETWORKS, None)}
  }
  #[inline]
  pub fn anchors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Anchor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Anchor>>>>(Lrs::VT_ANCHORS, None)}
  }
  #[inline]
  pub fn linear_referencing_methods(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LinearReferencingMethod<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LinearReferencingMethod>>>>(Lrs::VT_LINEAR_REFERENCING_METHODS, None)}
  }
  /// There can be multiple geometries
  /// For instance a geographic and and schematic representation of the same network
  #[inline]
  pub fn views(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GeometryView<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GeometryView>>>>(Lrs::VT_VIEWS, None)}
  }
}

impl flatbuffers::Verifiable for Lrs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Network>>>>("networks", Self::VT_NETWORKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Anchor>>>>("anchors", Self::VT_ANCHORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LinearReferencingMethod>>>>("linear_referencing_methods", Self::VT_LINEAR_REFERENCING_METHODS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GeometryView>>>>("views", Self::VT_VIEWS, false)?
     .finish();
    Ok(())
  }
}
pub struct LrsArgs<'a> {
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub networks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Network<'a>>>>>,
    pub anchors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Anchor<'a>>>>>,
    pub linear_referencing_methods: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LinearReferencingMethod<'a>>>>>,
    pub views: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GeometryView<'a>>>>>,
}
impl<'a> Default for LrsArgs<'a> {
  #[inline]
  fn default() -> Self {
    LrsArgs {
      properties: None,
      networks: None,
      anchors: None,
      linear_referencing_methods: None,
      views: None,
    }
  }
}

pub struct LrsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LrsBuilder<'a, 'b> {
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_networks(&mut self, networks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Network<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_NETWORKS, networks);
  }
  #[inline]
  pub fn add_anchors(&mut self, anchors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Anchor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_ANCHORS, anchors);
  }
  #[inline]
  pub fn add_linear_referencing_methods(&mut self, linear_referencing_methods: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LinearReferencingMethod<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_LINEAR_REFERENCING_METHODS, linear_referencing_methods);
  }
  #[inline]
  pub fn add_views(&mut self, views: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GeometryView<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_VIEWS, views);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LrsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LrsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Lrs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Lrs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Lrs");
      ds.field("properties", &self.properties());
      ds.field("networks", &self.networks());
      ds.field("anchors", &self.anchors());
      ds.field("linear_referencing_methods", &self.linear_referencing_methods());
      ds.field("views", &self.views());
      ds.finish()
  }
}
pub enum NetworkOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A collection of nodes, linked by segments.
/// It could be a network of roads, sewer pipes, railway tracks, or something abstract, such as railway lines.
pub struct Network<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Network<'a> {
  type Inner = Network<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Network<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 6;
  pub const VT_NODES: flatbuffers::VOffsetT = 8;
  pub const VT_TRAVERSALS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Network { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NetworkArgs<'args>
  ) -> flatbuffers::WIPOffset<Network<'bldr>> {
    let mut builder = NetworkBuilder::new(_fbb);
    if let Some(x) = args.traversals { builder.add_traversals(x); }
    if let Some(x) = args.nodes { builder.add_nodes(x); }
    if let Some(x) = args.segments { builder.add_segments(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Network::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn segments(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Segment<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Segment>>>>(Network::VT_SEGMENTS, None).unwrap()}
  }
  #[inline]
  pub fn nodes(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>>>(Network::VT_NODES, None).unwrap()}
  }
  /// Each network has traversals, which can be thought of as roads, railway lines, tracks, paths or trips.
  #[inline]
  pub fn traversals(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Traversal<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Traversal>>>>(Network::VT_TRAVERSALS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Network<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Segment>>>>("segments", Self::VT_SEGMENTS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>>>("nodes", Self::VT_NODES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Traversal>>>>("traversals", Self::VT_TRAVERSALS, true)?
     .finish();
    Ok(())
  }
}
pub struct NetworkArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Segment<'a>>>>>,
    pub nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>>,
    pub traversals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Traversal<'a>>>>>,
}
impl<'a> Default for NetworkArgs<'a> {
  #[inline]
  fn default() -> Self {
    NetworkArgs {
      id: None, // required field
      segments: None, // required field
      nodes: None, // required field
      traversals: None, // required field
    }
  }
}

pub struct NetworkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NetworkBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Network::VT_ID, id);
  }
  #[inline]
  pub fn add_segments(&mut self, segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Segment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Network::VT_SEGMENTS, segments);
  }
  #[inline]
  pub fn add_nodes(&mut self, nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Node<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Network::VT_NODES, nodes);
  }
  #[inline]
  pub fn add_traversals(&mut self, traversals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Traversal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Network::VT_TRAVERSALS, traversals);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NetworkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NetworkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Network<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Network::VT_ID,"id");
    self.fbb_.required(o, Network::VT_SEGMENTS,"segments");
    self.fbb_.required(o, Network::VT_NODES,"nodes");
    self.fbb_.required(o, Network::VT_TRAVERSALS,"traversals");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Network<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Network");
      ds.field("id", &self.id());
      ds.field("segments", &self.segments());
      ds.field("nodes", &self.nodes());
      ds.field("traversals", &self.traversals());
      ds.finish()
  }
}
pub enum SegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A continuous link between two network nodes. Segments can be located in space.
/// It could be a section of roads between intersections, a piece of railway tracks without switches, a continuous piece of sewer pipe.
/// Segments are directed: one of its ends of the segments is its begining, and the other its ends.
pub struct Segment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Segment<'a> {
  type Inner = Segment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Segment<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Segment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SegmentArgs<'args>
  ) -> flatbuffers::WIPOffset<Segment<'bldr>> {
    let mut builder = SegmentBuilder::new(_fbb);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Segment::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Segment::VT_PROPERTIES, None)}
  }
}

impl flatbuffers::Verifiable for Segment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .finish();
    Ok(())
  }
}
pub struct SegmentArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
}
impl<'a> Default for SegmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    SegmentArgs {
      id: None, // required field
      properties: None,
    }
  }
}

pub struct SegmentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SegmentBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Segment::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Segment::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SegmentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Segment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Segment::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Segment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Segment");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.finish()
  }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Nodes are connections between segment endpoints.
/// A node can have a single connection (at the end of a dead end), or multiple segment connections (at an intersection).
/// Nodes can be used to model point of interest in a network, such as road intersections, railway switches, the end of a dead ends.
pub struct Node<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
  type Inner = Node<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Node<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_CONNECTIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Node { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NodeArgs<'args>
  ) -> flatbuffers::WIPOffset<Node<'bldr>> {
    let mut builder = NodeBuilder::new(_fbb);
    if let Some(x) = args.connections { builder.add_connections(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Node::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn connections(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Connection<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Connection>>>>(Node::VT_CONNECTIONS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Node<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Connection>>>>("connections", Self::VT_CONNECTIONS, true)?
     .finish();
    Ok(())
  }
}
pub struct NodeArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub connections: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Connection<'a>>>>>,
}
impl<'a> Default for NodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeArgs {
      id: None, // required field
      properties: None,
      connections: None, // required field
    }
  }
}

pub struct NodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_connections(&mut self, connections: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Connection<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_CONNECTIONS, connections);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Node::VT_ID,"id");
    self.fbb_.required(o, Node::VT_CONNECTIONS,"connections");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Node<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Node");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("connections", &self.connections());
      ds.finish()
  }
}
pub enum ConnectionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A connection links a node to a segment
pub struct Connection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Connection<'a> {
  type Inner = Connection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Connection<'a> {
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 4;
  pub const VT_SEGMENT_INDEX: flatbuffers::VOffsetT = 6;
  pub const VT_ENDPOINT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Connection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConnectionArgs<'args>
  ) -> flatbuffers::WIPOffset<Connection<'bldr>> {
    let mut builder = ConnectionBuilder::new(_fbb);
    builder.add_segment_index(args.segment_index);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.endpoint { builder.add_endpoint(x); }
    builder.finish()
  }


  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Connection::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn segment_index(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Connection::VT_SEGMENT_INDEX, Some(0)).unwrap()}
  }
  /// A segment is oriented. The endpoint indicates what end of the segment is connected to the node
  #[inline]
  pub fn endpoint(&self) -> Option<Endpoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Endpoint>(Connection::VT_ENDPOINT, None)}
  }
}

impl flatbuffers::Verifiable for Connection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<u64>("segment_index", Self::VT_SEGMENT_INDEX, false)?
     .visit_field::<Endpoint>("endpoint", Self::VT_ENDPOINT, false)?
     .finish();
    Ok(())
  }
}
pub struct ConnectionArgs<'a> {
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub segment_index: u64,
    pub endpoint: Option<Endpoint>,
}
impl<'a> Default for ConnectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConnectionArgs {
      properties: None,
      segment_index: 0,
      endpoint: None,
    }
  }
}

pub struct ConnectionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConnectionBuilder<'a, 'b> {
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Connection::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_segment_index(&mut self, segment_index: u64) {
    self.fbb_.push_slot::<u64>(Connection::VT_SEGMENT_INDEX, segment_index, 0);
  }
  #[inline]
  pub fn add_endpoint(&mut self, endpoint: Endpoint) {
    self.fbb_.push_slot_always::<Endpoint>(Connection::VT_ENDPOINT, endpoint);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConnectionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Connection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Connection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Connection");
      ds.field("properties", &self.properties());
      ds.field("segment_index", &self.segment_index());
      ds.field("endpoint", &self.endpoint());
      ds.finish()
  }
}
pub enum TraversalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Traversal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Traversal<'a> {
  type Inner = Traversal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Traversal<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 8;
  pub const VT_DIRECTIONS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Traversal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TraversalArgs<'args>
  ) -> flatbuffers::WIPOffset<Traversal<'bldr>> {
    let mut builder = TraversalBuilder::new(_fbb);
    if let Some(x) = args.directions { builder.add_directions(x); }
    if let Some(x) = args.segments { builder.add_segments(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Traversal::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Traversal::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn segments(&self) -> flatbuffers::Vector<'a, u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Traversal::VT_SEGMENTS, None).unwrap()}
  }
  #[inline]
  pub fn directions(&self) -> flatbuffers::Vector<'a, Direction> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Direction>>>(Traversal::VT_DIRECTIONS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Traversal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("segments", Self::VT_SEGMENTS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Direction>>>("directions", Self::VT_DIRECTIONS, true)?
     .finish();
    Ok(())
  }
}
pub struct TraversalArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub directions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Direction>>>,
}
impl<'a> Default for TraversalArgs<'a> {
  #[inline]
  fn default() -> Self {
    TraversalArgs {
      id: None, // required field
      properties: None,
      segments: None, // required field
      directions: None, // required field
    }
  }
}

pub struct TraversalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TraversalBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_segments(&mut self, segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_SEGMENTS, segments);
  }
  #[inline]
  pub fn add_directions(&mut self, directions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Direction>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_DIRECTIONS, directions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TraversalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TraversalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Traversal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Traversal::VT_ID,"id");
    self.fbb_.required(o, Traversal::VT_SEGMENTS,"segments");
    self.fbb_.required(o, Traversal::VT_DIRECTIONS,"directions");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Traversal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Traversal");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("segments", &self.segments());
      ds.field("directions", &self.directions());
      ds.finish()
  }
}
pub enum AnchorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Anchors are reference locations, used for positioning within a linear referencing method.
/// There are two types of anchors:
///   * most anchors are standalone reference locations, such as milestones or kilometer markers
///   * some anchors are associated with a network node. The location of the anchor is deduced from the location of the node.
pub struct Anchor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anchor<'a> {
  type Inner = Anchor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Anchor<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_NODE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Anchor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AnchorArgs<'args>
  ) -> flatbuffers::WIPOffset<Anchor<'bldr>> {
    let mut builder = AnchorBuilder::new(_fbb);
    if let Some(x) = args.node { builder.add_node(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Anchor::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Anchor::VT_PROPERTIES, None)}
  }
  /// Most anchors have a name, which is used to reference the location.
  /// More often than not a kilometer or mile number, but it can also be a letter or word.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Anchor::VT_NAME, None)}
  }
  /// Anchors can be bound to a node, or defined independently.
  /// If the anchor is bound to a node, it's location is deduced from location of the node.
  #[inline]
  pub fn node(&self) -> Option<&'a NodeRef> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<NodeRef>(Anchor::VT_NODE, None)}
  }
}

impl flatbuffers::Verifiable for Anchor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<NodeRef>("node", Self::VT_NODE, false)?
     .finish();
    Ok(())
  }
}
pub struct AnchorArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub node: Option<&'a NodeRef>,
}
impl<'a> Default for AnchorArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnchorArgs {
      id: None, // required field
      properties: None,
      name: None,
      node: None,
    }
  }
}

pub struct AnchorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AnchorBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anchor::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anchor::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anchor::VT_NAME, name);
  }
  #[inline]
  pub fn add_node(&mut self, node: &NodeRef) {
    self.fbb_.push_slot_always::<&NodeRef>(Anchor::VT_NODE, node);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AnchorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AnchorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anchor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Anchor::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Anchor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Anchor");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("name", &self.name());
      ds.field("node", &self.node());
      ds.finish()
  }
}
pub enum LinearReferencingMethodOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Linear referencing methods (LRMs) are curves in space, along which distances can be measured.
/// Each linear referencing method has:
///   * a network traversal, which defines the path of the curve
///   * a sequence of anchors, which are projected on the curve, and used as positioning reference points
///   * distances between anchors have to be defined: even though distances can be measured on the curve,
pub struct LinearReferencingMethod<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinearReferencingMethod<'a> {
  type Inner = LinearReferencingMethod<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinearReferencingMethod<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_TRAVERSAL_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_USED_ON: flatbuffers::VOffsetT = 10;
  pub const VT_ANCHOR_INDICES: flatbuffers::VOffsetT = 12;
  pub const VT_DISTANCES: flatbuffers::VOffsetT = 14;
  pub const VT_DISTANCE_UNIT: flatbuffers::VOffsetT = 16;
  pub const VT_MEASURE_UNIT: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinearReferencingMethod { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LinearReferencingMethodArgs<'args>
  ) -> flatbuffers::WIPOffset<LinearReferencingMethod<'bldr>> {
    let mut builder = LinearReferencingMethodBuilder::new(_fbb);
    if let Some(x) = args.distances { builder.add_distances(x); }
    if let Some(x) = args.anchor_indices { builder.add_anchor_indices(x); }
    if let Some(x) = args.used_on { builder.add_used_on(x); }
    if let Some(x) = args.traversal_index { builder.add_traversal_index(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_measure_unit(args.measure_unit);
    builder.add_distance_unit(args.distance_unit);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearReferencingMethod::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(LinearReferencingMethod::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn traversal_index(&self) -> Option<&'a TraversalRef> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TraversalRef>(LinearReferencingMethod::VT_TRAVERSAL_INDEX, None)}
  }
  /// An LRM can apply to multiple traversal
  /// For instance a LRM can be the central line of a highway
  /// And that LRM is the reference for the two other traversals corresponding to each direction
  #[inline]
  pub fn used_on(&self) -> Option<flatbuffers::Vector<'a, TraversalRef>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, TraversalRef>>>(LinearReferencingMethod::VT_USED_ON, None)}
  }
  #[inline]
  pub fn anchor_indices(&self) -> flatbuffers::Vector<'a, u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(LinearReferencingMethod::VT_ANCHOR_INDICES, None).unwrap()}
  }
  #[inline]
  pub fn distances(&self) -> flatbuffers::Vector<'a, f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(LinearReferencingMethod::VT_DISTANCES, None).unwrap()}
  }
  /// The unit used to measure the distance between anchors
  #[inline]
  pub fn distance_unit(&self) -> DistanceUnit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DistanceUnit>(LinearReferencingMethod::VT_DISTANCE_UNIT, Some(DistanceUnit::Meters)).unwrap()}
  }
  /// The unit used to express measures relative to anchors (12+230)
  #[inline]
  pub fn measure_unit(&self) -> DistanceUnit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DistanceUnit>(LinearReferencingMethod::VT_MEASURE_UNIT, Some(DistanceUnit::Meters)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LinearReferencingMethod<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<TraversalRef>("traversal_index", Self::VT_TRAVERSAL_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, TraversalRef>>>("used_on", Self::VT_USED_ON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("anchor_indices", Self::VT_ANCHOR_INDICES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("distances", Self::VT_DISTANCES, true)?
     .visit_field::<DistanceUnit>("distance_unit", Self::VT_DISTANCE_UNIT, false)?
     .visit_field::<DistanceUnit>("measure_unit", Self::VT_MEASURE_UNIT, false)?
     .finish();
    Ok(())
  }
}
pub struct LinearReferencingMethodArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub traversal_index: Option<&'a TraversalRef>,
    pub used_on: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, TraversalRef>>>,
    pub anchor_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub distances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub distance_unit: DistanceUnit,
    pub measure_unit: DistanceUnit,
}
impl<'a> Default for LinearReferencingMethodArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinearReferencingMethodArgs {
      id: None, // required field
      properties: None,
      traversal_index: None,
      used_on: None,
      anchor_indices: None, // required field
      distances: None, // required field
      distance_unit: DistanceUnit::Meters,
      measure_unit: DistanceUnit::Meters,
    }
  }
}

pub struct LinearReferencingMethodBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LinearReferencingMethodBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_traversal_index(&mut self, traversal_index: &TraversalRef) {
    self.fbb_.push_slot_always::<&TraversalRef>(LinearReferencingMethod::VT_TRAVERSAL_INDEX, traversal_index);
  }
  #[inline]
  pub fn add_used_on(&mut self, used_on: flatbuffers::WIPOffset<flatbuffers::Vector<'b , TraversalRef>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_USED_ON, used_on);
  }
  #[inline]
  pub fn add_anchor_indices(&mut self, anchor_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_ANCHOR_INDICES, anchor_indices);
  }
  #[inline]
  pub fn add_distances(&mut self, distances: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_DISTANCES, distances);
  }
  #[inline]
  pub fn add_distance_unit(&mut self, distance_unit: DistanceUnit) {
    self.fbb_.push_slot::<DistanceUnit>(LinearReferencingMethod::VT_DISTANCE_UNIT, distance_unit, DistanceUnit::Meters);
  }
  #[inline]
  pub fn add_measure_unit(&mut self, measure_unit: DistanceUnit) {
    self.fbb_.push_slot::<DistanceUnit>(LinearReferencingMethod::VT_MEASURE_UNIT, measure_unit, DistanceUnit::Meters);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LinearReferencingMethodBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LinearReferencingMethodBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinearReferencingMethod<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LinearReferencingMethod::VT_ID,"id");
    self.fbb_.required(o, LinearReferencingMethod::VT_ANCHOR_INDICES,"anchor_indices");
    self.fbb_.required(o, LinearReferencingMethod::VT_DISTANCES,"distances");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinearReferencingMethod<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinearReferencingMethod");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("traversal_index", &self.traversal_index());
      ds.field("used_on", &self.used_on());
      ds.field("anchor_indices", &self.anchor_indices());
      ds.field("distances", &self.distances());
      ds.field("distance_unit", &self.distance_unit());
      ds.field("measure_unit", &self.measure_unit());
      ds.finish()
  }
}
pub enum GeometryViewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GeometryView<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GeometryView<'a> {
  type Inner = GeometryView<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GeometryView<'a> {
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 4;
  pub const VT_GEOMETRY_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_ANCHORS: flatbuffers::VOffsetT = 8;
  pub const VT_NETWORKS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GeometryView { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GeometryViewArgs<'args>
  ) -> flatbuffers::WIPOffset<GeometryView<'bldr>> {
    let mut builder = GeometryViewBuilder::new(_fbb);
    if let Some(x) = args.networks { builder.add_networks(x); }
    if let Some(x) = args.anchors { builder.add_anchors(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.geometry_type { builder.add_geometry_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(GeometryView::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn geometry_type(&self) -> Option<GeometryType> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometryType>(GeometryView::VT_GEOMETRY_TYPE, None)}
  }
  #[inline]
  pub fn anchors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnchorGeometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnchorGeometry>>>>(GeometryView::VT_ANCHORS, None)}
  }
  /// Must be the same size as the top level network array
  #[inline]
  pub fn networks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NetworkGeometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NetworkGeometry>>>>(GeometryView::VT_NETWORKS, None)}
  }
}

impl flatbuffers::Verifiable for GeometryView<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<GeometryType>("geometry_type", Self::VT_GEOMETRY_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnchorGeometry>>>>("anchors", Self::VT_ANCHORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NetworkGeometry>>>>("networks", Self::VT_NETWORKS, false)?
     .finish();
    Ok(())
  }
}
pub struct GeometryViewArgs<'a> {
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub geometry_type: Option<GeometryType>,
    pub anchors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnchorGeometry<'a>>>>>,
    pub networks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NetworkGeometry<'a>>>>>,
}
impl<'a> Default for GeometryViewArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeometryViewArgs {
      properties: None,
      geometry_type: None,
      anchors: None,
      networks: None,
    }
  }
}

pub struct GeometryViewBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GeometryViewBuilder<'a, 'b> {
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GeometryView::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_geometry_type(&mut self, geometry_type: GeometryType) {
    self.fbb_.push_slot_always::<GeometryType>(GeometryView::VT_GEOMETRY_TYPE, geometry_type);
  }
  #[inline]
  pub fn add_anchors(&mut self, anchors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AnchorGeometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GeometryView::VT_ANCHORS, anchors);
  }
  #[inline]
  pub fn add_networks(&mut self, networks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NetworkGeometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GeometryView::VT_NETWORKS, networks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GeometryViewBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GeometryViewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GeometryView<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GeometryView<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GeometryView");
      ds.field("properties", &self.properties());
      ds.field("geometry_type", &self.geometry_type());
      ds.field("anchors", &self.anchors());
      ds.field("networks", &self.networks());
      ds.finish()
  }
}
pub enum AnchorGeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnchorGeometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnchorGeometry<'a> {
  type Inner = AnchorGeometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AnchorGeometry<'a> {
  pub const VT_GEOM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AnchorGeometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AnchorGeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<AnchorGeometry<'bldr>> {
    let mut builder = AnchorGeometryBuilder::new(_fbb);
    if let Some(x) = args.geom { builder.add_geom(x); }
    builder.finish()
  }


  /// Anchors only have a geometry when not linked to a network node
  /// The value is null if it is linked to a network node
  #[inline]
  pub fn geom(&self) -> Option<&'a Point> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Point>(AnchorGeometry::VT_GEOM, None)}
  }
}

impl flatbuffers::Verifiable for AnchorGeometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Point>("geom", Self::VT_GEOM, false)?
     .finish();
    Ok(())
  }
}
pub struct AnchorGeometryArgs<'a> {
    pub geom: Option<&'a Point>,
}
impl<'a> Default for AnchorGeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnchorGeometryArgs {
      geom: None,
    }
  }
}

pub struct AnchorGeometryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AnchorGeometryBuilder<'a, 'b> {
  #[inline]
  pub fn add_geom(&mut self, geom: &Point) {
    self.fbb_.push_slot_always::<&Point>(AnchorGeometry::VT_GEOM, geom);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AnchorGeometryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AnchorGeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AnchorGeometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AnchorGeometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AnchorGeometry");
      ds.field("geom", &self.geom());
      ds.finish()
  }
}
pub enum NetworkGeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The geometry for a given network
pub struct NetworkGeometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NetworkGeometry<'a> {
  type Inner = NetworkGeometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NetworkGeometry<'a> {
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NetworkGeometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NetworkGeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<NetworkGeometry<'bldr>> {
    let mut builder = NetworkGeometryBuilder::new(_fbb);
    if let Some(x) = args.segments { builder.add_segments(x); }
    builder.finish()
  }


  /// Must have as many linestrings as the network has segments
  #[inline]
  pub fn segments(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SegmentGeometry<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SegmentGeometry>>>>(NetworkGeometry::VT_SEGMENTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for NetworkGeometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SegmentGeometry>>>>("segments", Self::VT_SEGMENTS, true)?
     .finish();
    Ok(())
  }
}
pub struct NetworkGeometryArgs<'a> {
    pub segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SegmentGeometry<'a>>>>>,
}
impl<'a> Default for NetworkGeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    NetworkGeometryArgs {
      segments: None, // required field
    }
  }
}

pub struct NetworkGeometryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NetworkGeometryBuilder<'a, 'b> {
  #[inline]
  pub fn add_segments(&mut self, segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SegmentGeometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NetworkGeometry::VT_SEGMENTS, segments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NetworkGeometryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NetworkGeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NetworkGeometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, NetworkGeometry::VT_SEGMENTS,"segments");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NetworkGeometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NetworkGeometry");
      ds.field("segments", &self.segments());
      ds.finish()
  }
}
pub enum SegmentGeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SegmentGeometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SegmentGeometry<'a> {
  type Inner = SegmentGeometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SegmentGeometry<'a> {
  pub const VT_POINTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SegmentGeometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SegmentGeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<SegmentGeometry<'bldr>> {
    let mut builder = SegmentGeometryBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    builder.finish()
  }


  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Point> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Point>>>(SegmentGeometry::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SegmentGeometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Point>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct SegmentGeometryArgs<'a> {
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Point>>>,
}
impl<'a> Default for SegmentGeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    SegmentGeometryArgs {
      points: None, // required field
    }
  }
}

pub struct SegmentGeometryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SegmentGeometryBuilder<'a, 'b> {
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Point>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SegmentGeometry::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SegmentGeometryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SegmentGeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SegmentGeometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SegmentGeometry::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SegmentGeometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SegmentGeometry");
      ds.field("points", &self.points());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Lrs`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_lrs_unchecked`.
pub fn root_as_lrs(buf: &[u8]) -> Result<Lrs, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Lrs>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Lrs` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_lrs_unchecked`.
pub fn size_prefixed_root_as_lrs(buf: &[u8]) -> Result<Lrs, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Lrs>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Lrs` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_lrs_unchecked`.
pub fn root_as_lrs_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Lrs<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Lrs<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Lrs` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_lrs_unchecked`.
pub fn size_prefixed_root_as_lrs_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Lrs<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Lrs<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Lrs and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Lrs`.
pub unsafe fn root_as_lrs_unchecked(buf: &[u8]) -> Lrs {
  flatbuffers::root_unchecked::<Lrs>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Lrs and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Lrs`.
pub unsafe fn size_prefixed_root_as_lrs_unchecked(buf: &[u8]) -> Lrs {
  flatbuffers::size_prefixed_root_unchecked::<Lrs>(buf)
}
pub const LRS_IDENTIFIER: &str = "LRSD";

#[inline]
pub fn lrs_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LRS_IDENTIFIER, false)
}

#[inline]
pub fn lrs_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LRS_IDENTIFIER, true)
}

#[inline]
pub fn finish_lrs_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Lrs<'a>>) {
  fbb.finish(root, Some(LRS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_lrs_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Lrs<'a>>) {
  fbb.finish_size_prefixed(root, Some(LRS_IDENTIFIER));
}
