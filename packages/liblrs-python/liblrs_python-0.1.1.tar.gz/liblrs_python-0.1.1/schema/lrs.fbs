file_identifier "LRSD";

table Property {
    key:string (required, key);
    value:string (required);
}

table Lrs {
    properties:[Property];

    /// Networks are segments connected by nodes.
    /// There can be multiple networks, such as railway tracks and lines, sewer pipe and power lines.
    networks:[Network];

    anchors:[Anchor];
    linear_referencing_methods:[LinearReferencingMethod];

    /// There can be multiple geometries
    /// For instance a geographic and and schematic representation of the same network
    views:[GeometryView];
}


// NETWORK DEFINITION

/// A collection of nodes, linked by segments.
/// It could be a network of roads, sewer pipes, railway tracks, or something abstract, such as railway lines.
table Network {
    id:string (required);

    segments:[Segment] (required);
    nodes:[Node] (required);
    /// Each network has traversals, which can be thought of as roads, railway lines, tracks, paths or trips.
    traversals:[Traversal] (required);
}

/// A continuous link between two network nodes. Segments can be located in space.
/// It could be a section of roads between intersections, a piece of railway tracks without switches, a continuous piece of sewer pipe.
/// Segments are directed: one of its ends of the segments is its begining, and the other its ends.
table Segment {
    id:string (required);
    properties:[Property];
}

/// Nodes are connections between segment endpoints.
/// A node can have a single connection (at the end of a dead end), or multiple segment connections (at an intersection).
/// Nodes can be used to model point of interest in a network, such as road intersections, railway switches, the end of a dead ends.
table Node {
    id:string (required);
    properties:[Property];

    connections:[Connection] (required);
}

enum Endpoint : byte { Begin = 1, End = 2 }
/// A connection links a node to a segment
table Connection {
    properties:[Property];

    segment_index:uint64;
    /// A segment is oriented. The endpoint indicates what end of the segment is connected to the node
    endpoint:Endpoint = null;
}

/// A traversal is a path in a network.
/// Traversals may be used to model roads, railway tracks, railway lines or trips.
/// Traversals are defined as a sequence of segment and direction pairs.
enum Direction : byte { Increasing = 1, Decreasing = 2 }

table Traversal {
    id:string (required);
    properties:[Property];

    // Segments and directions are meant to be iterated over simultaneously.
    // segments.size() == directions.size()
    segments:[uint64] (required);
    directions:[Direction] (required);
}

struct NodeRef {
    network_index:uint32;
    node_index:uint64;
}

struct TraversalRef {
    network_index:uint32;
    traversal_index:uint64;
}


// LRM DEFINITION

/// Anchors are reference locations, used for positioning within a linear referencing method.
/// There are two types of anchors:
///   * most anchors are standalone reference locations, such as milestones or kilometer markers
///   * some anchors are associated with a network node. The location of the anchor is deduced from the location of the node.
table Anchor {
    id:string (required);
    properties:[Property];

    /// Most anchors have a name, which is used to reference the location.
    /// More often than not a kilometer or mile number, but it can also be a letter or word.
    name:string;
    /// Anchors can be bound to a node, or defined independently.
    /// If the anchor is bound to a node, it's location is deduced from location of the node.
    node:NodeRef;
}

enum DistanceUnit : byte { Meters, MilliMeters }

/// Linear referencing methods (LRMs) are curves in space, along which distances can be measured.
/// Each linear referencing method has:
///   * a network traversal, which defines the path of the curve
///   * a sequence of anchors, which are projected on the curve, and used as positioning reference points
///   * distances between anchors have to be defined: even though distances can be measured on the curve,
//      it can be imprecise enough to joepardize correct ordering of object positionned relative to different reference points
table LinearReferencingMethod {
    id:string (required);
    properties:[Property];

    traversal_index:TraversalRef;
    /// An LRM can apply to multiple traversal
    /// For instance a LRM can be the central line of a highway
    /// And that LRM is the reference for the two other traversals corresponding to each direction
    used_on:[TraversalRef];
    anchor_indices:[uint64] (required);
    distances:[double] (required);
    /// The unit used to measure the distance between anchors
    distance_unit:DistanceUnit = Meters;
    /// The unit used to express measures relative to anchors (12+230)
    measure_unit:DistanceUnit = Meters;
}


// GEOMETRY DEFINITION

struct Point {
    x:float64;
    y:float64;
    z:float64;
}

enum GeometryType : byte { Geographic = 1, Schematic = 2 }

table GeometryView {
    properties:[Property];

    geometry_type:GeometryType = null;
    anchors:[AnchorGeometry];
    /// Must be the same size as the top level network array
    networks:[NetworkGeometry];
}

table AnchorGeometry {
    /// Anchors only have a geometry when not linked to a network node
    /// The value is null if it is linked to a network node
    geom:Point;
}

/// The geometry for a given network
table NetworkGeometry {
    /// Must have as many linestrings as the network has segments
    segments:[SegmentGeometry] (required);
}

table SegmentGeometry {
    points:[Point] (required);
}

root_type Lrs;
