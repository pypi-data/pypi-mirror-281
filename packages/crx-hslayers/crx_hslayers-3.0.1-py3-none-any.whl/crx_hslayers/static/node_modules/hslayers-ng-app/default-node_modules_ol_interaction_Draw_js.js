"use strict";(self.webpackChunkhslayers_app=self.webpackChunkhslayers_app||[]).push([["default-node_modules_ol_interaction_Draw_js"],{63513:(tt,K,_)=>{_.d(K,{A:()=>H});var N=_(79179),R=_(14378),V=_(87910),M=_(27133);class O extends N.Ay{constructor(l,c,d){super(),void 0!==d&&void 0===c?this.setFlatCoordinates(d,l):this.setCenterAndRadius(l,c=c||0,d)}clone(){const l=new O(this.flatCoordinates.slice(),void 0,this.layout);return l.applyProperties(this),l}closestPointXY(l,c,d,C){const P=this.flatCoordinates,T=l-P[0],k=c-P[1],x=T*T+k*k;if(x<C){if(0===x)for(let p=0;p<this.stride;++p)d[p]=P[p];else{const p=this.getRadius()/Math.sqrt(x);d[0]=P[0]+p*T,d[1]=P[1]+p*k;for(let w=2;w<this.stride;++w)d[w]=P[w]}return d.length=this.stride,x}return C}containsXY(l,c){const d=this.flatCoordinates,C=l-d[0],P=c-d[1];return C*C+P*P<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(l){const c=this.flatCoordinates,d=c[this.stride]-c[0];return(0,R.createOrUpdate)(c[0]-d,c[1]-d,c[0]+d,c[1]+d,l)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const l=this.flatCoordinates[this.stride]-this.flatCoordinates[0],c=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return l*l+c*c}getType(){return"Circle"}intersectsExtent(l){const c=this.getExtent();if((0,R.intersects)(l,c)){const d=this.getCenter();return l[0]<=d[0]&&l[2]>=d[0]||l[1]<=d[1]&&l[3]>=d[1]||(0,R.forEachCorner)(l,this.intersectsCoordinate.bind(this))}return!1}setCenter(l){const c=this.stride,d=this.flatCoordinates[c]-this.flatCoordinates[0],C=l.slice();C[c]=C[0]+d;for(let P=1;P<c;++P)C[c+P]=l[P];this.setFlatCoordinates(this.layout,C),this.changed()}setCenterAndRadius(l,c,d){this.setLayout(d,l,0),this.flatCoordinates||(this.flatCoordinates=[]);const C=this.flatCoordinates;let P=(0,V._n)(C,0,l,this.stride);C[P++]=C[0]+c;for(let T=1,k=this.stride;T<k;++T)C[P++]=C[T];C.length=P,this.changed()}getCoordinates(){return null}setCoordinates(l,c){}setRadius(l){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+l,this.changed()}rotate(l,c){const d=this.getCenter(),C=this.getStride();this.setCenter((0,M.e$)(d,0,d.length,C,l,c,d)),this.changed()}}const H=O},28929:(tt,K,_)=>{_.d(K,{Ay:()=>ht});var N=_(63513),R=_(14888),V=_(78864),M=_(34958),O=_(6517),H=_(48222),S=_(16558),l=_(88066),c=_(92234),d=_(39559),C=_(5340),P=_(8932),T=_(48791),k=_(3382),x=_(98695),p=_(47616),w=_(35901),J=_(6401),F=_(73301),et=_(14378),v=_(98092),st=_(21043),X=_(31504),Y=_(87549),Q=_(79179);class j extends R.Ay{constructor(t,e){super(t),this.feature=e}}function W(a,t){return(0,v.hG)(a[0],a[1],t[0],t[1])}function A(a,t){const e=a.length;return t<0?a[t+e]:t>=e?a[t-e]:a[t]}function B(a,t,e){let s,i;t<e?(s=t,i=e):(s=e,i=t);const o=Math.ceil(s),n=Math.floor(i);if(o>n)return W(I(a,s),I(a,i));let r=0;s<o&&(r+=W(I(a,s),A(a,o))),n<i&&(r+=W(A(a,n),I(a,i)));for(let h=o;h<n-1;++h)r+=W(A(a,h),A(a,h+1));return r}function q(a,t,e){if(t instanceof S.default)G(a,t.getCoordinates(),!1,e);else if(t instanceof d.A){const s=t.getCoordinates();for(let i=0,o=s.length;i<o;++i)G(a,s[i],!1,e)}else if(t instanceof x.default){const s=t.getCoordinates();for(let i=0,o=s.length;i<o;++i)G(a,s[i],!0,e)}else if(t instanceof P.A){const s=t.getCoordinates();for(let i=0,o=s.length;i<o;++i){const n=s[i];for(let r=0,h=n.length;r<h;++r)G(a,n[r],!0,e)}}else if(t instanceof O.A){const s=t.getGeometries();for(let i=0;i<s.length;++i)q(a,s[i],e)}}const Z={index:-1,endIndex:NaN};function G(a,t,e,s){const i=a[0],o=a[1];for(let n=0,r=t.length-1;n<r;++n){const g=b(i,o,t[n],t[n+1]);if(0===g.squaredDistance){const u=n+g.along;return void s.push({coordinates:t,ring:e,startIndex:u,endIndex:u})}}}const $={along:0,squaredDistance:0};function b(a,t,e,s){const i=e[0],o=e[1],h=s[0]-i,f=s[1]-o;let g=0,u=i,m=o;return(0!==h||0!==f)&&(g=(0,v.qE)(((a-i)*h+(t-o)*f)/(h*h+f*f),0,1),u+=h*g,m+=f*g),$.along=g,$.squaredDistance=(0,v.Mg)((0,v.hG)(a,t,u,m),10),$}function I(a,t){const e=a.length;let s=Math.floor(t);const i=t-s;s>=e?s-=e:s<0&&(s+=e);let o=s+1;o>=e&&(o-=e);const n=a[s],r=n[0],h=n[1],f=a[o];return[r+(f[0]-r)*i,h+(f[1]-h)*i]}function rt(){const a=(0,st.createEditingStyle)();return function(t,e){return a[t.getGeometry().getType()]}}const ht=class ot extends k.A{constructor(t){const e=t;e.stopDown||(e.stopDown=J.W8),super(e),this.shouldHandle_=!1,this.downPx_=null,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=function at(a){switch(a){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+a)}}(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:"Polygon"===this.mode_?3:2,this.maxPoints_="Circle"===this.mode_?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:J.rT,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let s=t.geometryFunction;if(!s){const i=this.mode_;if("Circle"===i)s=function(o,n,r){const h=n||new N.A([NaN,NaN]),f=(0,Y.fromUserCoordinate)(o[0],r),g=(0,X.hG)(f,(0,Y.fromUserCoordinate)(o[o.length-1],r));h.setCenterAndRadius(f,Math.sqrt(g),this.geometryLayout_);const u=(0,Y.getUserProjection)();return u&&h.transform(r,u),h};else{let o;"Point"===i?o=T.default:"LineString"===i?o=S.default:"Polygon"===i&&(o=x.default),s=function(n,r,h){return r?r.setCoordinates("Polygon"===i?n[0].length?[n[0].concat([n[0][0]])]:[]:n,this.geometryLayout_):r=new o(n,this.geometryLayout_),r}}}this.geometryFunction_=s,this.dragVertexDelay_=void 0!==t.dragVertexDelay?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new p.A({source:new w.A({useSpatialIndex:!1,wrapX:!!t.wrapX&&t.wrapX}),style:t.style?t.style:rt(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:F.TS,this.freehandCondition_=t.freehand?F.Gk:t.freehandCondition?t.freehandCondition:F.Kg,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(H.A.ACTIVE,this.updateState_)}setTrace(t){let e;e=t?!0===t?F.Gk:t:F.Zm,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(t){t.originalEvent.type===V.A.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_="Point"!==this.mode_&&this.freehandCondition_(t);let e=t.type===c.A.POINTERMOVE,s=!0;return!this.freehand_&&this.lastDragTime_&&t.type===c.A.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&t.type===c.A.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(t.coordinate),s=!1):this.freehand_&&t.type===c.A.POINTERDOWN?s=!1:e&&this.getPointerCount()<2?(s=t.type===c.A.POINTERMOVE,s&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):("mouse"===t.originalEvent.pointerType||t.type===c.A.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(t)):t.type===c.A.DBLCLICK&&(s=!1),super.handleEvent(t)&&s}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new l.A(c.A.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active)return void this.deactivateTrace_();const e=this.getMap(),s=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),i=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),o=(0,et.boundingExtent)([s,i]),n=this.traceSource_.getFeaturesInExtent(o);if(0===n.length)return;const r=function it(a,t){const e=[];for(let s=0;s<t.length;++s)q(a,t[s].getGeometry(),e);return e}(t.coordinate,n);r.length&&(this.traceState_={active:!0,startPx:t.pixel.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const s=t.startIndex<=t.endIndex;s===t.startIndex<=e?s&&e>t.endIndex||!s&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(s&&e<t.endIndex||!s&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let s=0;if(t<e){const i=Math.ceil(t);let o=Math.floor(e);o===e&&(o-=1),s=o-i+1}else{const i=Math.floor(t);let o=Math.ceil(e);o===e&&(o+=1),s=i-o+1}s>0&&this.removeLastPoints_(s)}addTracedCoordinates_(t,e,s){if(e===s)return;const i=[];if(e<s){const o=Math.ceil(e);let n=Math.floor(s);n===s&&(n-=1);for(let r=o;r<=n;++r)i.push(A(t.coordinates,r))}else{const o=Math.floor(e);let n=Math.ceil(s);n===s&&(n+=1);for(let r=o;r>=n;--r)i.push(A(t.coordinates,r))}i.length&&this.appendCoordinates(i)}updateTrace_(t){const e=this.traceState_;if(!e.active||-1===e.targetIndex&&(0,X.Io)(e.startPx,t.pixel)<this.snapTolerance_)return;const s=function nt(a,t,e,s){const i=a[0],o=a[1];let n=1/0,r=-1,h=NaN;for(let u=0;u<t.targets.length;++u){const m=t.targets[u],y=m.coordinates;let E,D=1/0;for(let L=0;L<y.length-1;++L){const z=b(i,o,y[L],y[L+1]);z.squaredDistance<D&&(D=z.squaredDistance,E=L+z.along)}D<n&&(n=D,m.ring&&t.targetIndex===u&&(m.endIndex>m.startIndex?E<m.startIndex&&(E+=y.length):m.endIndex<m.startIndex&&E>m.startIndex&&(E-=y.length)),h=E,r=u)}const f=t.targets[r];let g=f.ring;if(t.targetIndex===r&&g){const u=I(f.coordinates,h),m=e.getPixelFromCoordinate(u);(0,X.Io)(m,t.startPx)>s&&(g=!1)}if(g){const u=f.coordinates,m=u.length,y=f.startIndex,D=h;if(y<D){const E=B(u,y,D);B(u,y,D-m)<E&&(h-=m)}else{const E=B(u,y,D);B(u,y,D+m)<E&&(h+=m)}}return Z.index=r,Z.endIndex=h,Z}(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==s.index){if(-1!==e.targetIndex){const h=e.targets[e.targetIndex];this.removeTracedCoordinates_(h.startIndex,h.endIndex)}const r=e.targets[s.index];this.addTracedCoordinates_(r,r.startIndex,s.endIndex)}else this.addOrRemoveTracedCoordinates_(e.targets[e.targetIndex],s.endIndex);e.targetIndex=s.index;const i=e.targets[e.targetIndex];i.endIndex=s.endIndex;const o=I(i.coordinates,i.endIndex),n=this.getMap().getPixelFromCoordinate(o);t.coordinate=o,t.pixel=[Math.round(n[0]),Math.round(n[1])]}handleUpEvent(t){let e=!0;if(0===this.getPointerCount()){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const s=this.traceState_.active;if(this.toggleTraceState_(t),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(t.coordinate),!i&&this.freehand_?this.finishDrawing():!this.freehand_&&(!i||"Point"===this.mode_)&&(this.atFinish_(t.pixel,s)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,s=t.pixel,i=e[0]-s[0],o=e[1]-s[1],n=i*i+o*o;if(this.shouldHandle_=this.freehand_?n>this.squaredClickTolerance_:n<=this.squaredClickTolerance_,!this.shouldHandle_)return}this.finishCoordinate_?(this.updateTrace_(t),this.modifyDrawing_(t.coordinate)):this.createOrUpdateSketchPoint_(t.coordinate.slice())}atFinish_(t,e){let s=!1;if(this.sketchFeature_){let i=!1,o=[this.finishCoordinate_];const n=this.mode_;if("Point"===n)s=!0;else if("Circle"===n)s=2===this.sketchCoords_.length;else if("LineString"===n)i=!e&&this.sketchCoords_.length>this.minPoints_;else if("Polygon"===n){const r=this.sketchCoords_;i=r[0].length>this.minPoints_,o=[r[0][0],r[0][r[0].length-2]],o=e?[r[0][0]]:[r[0][0],r[0][r[0].length-2]]}if(i){const r=this.getMap();for(let h=0,f=o.length;h<f;h++){const g=o[h],u=r.getPixelFromCoordinate(g),m=t[0]-u[0],y=t[1]-u[1],D=this.freehand_?1:this.snapTolerance_;if(s=Math.sqrt(m*m+y*y)<=D,s){this.finishCoordinate_=g;break}}}}return s}createOrUpdateSketchPoint_(t){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(t):(this.sketchPoint_=new M.default(new T.default(t)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new M.default);const e=t.getLinearRing(0);let s=this.sketchLine_.getGeometry();s?(s.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),s.changed()):(s=new S.default(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(s))}startDrawing_(t){const e=this.getMap().getView().getProjection(),s=(0,Q.dn)(this.geometryLayout_);for(;t.length<s;)t.push(0);this.finishCoordinate_=t,"Point"===this.mode_?this.sketchCoords_=t.slice():"Polygon"===this.mode_?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new M.default(new S.default(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new M.default,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new j("drawstart",this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),s=this.sketchFeature_.getGeometry(),i=e.getView().getProjection(),o=(0,Q.dn)(this.geometryLayout_);let n,r;for(;t.length<o;)t.push(0);"Point"===this.mode_?r=this.sketchCoords_:"Polygon"===this.mode_?(n=this.sketchCoords_[0],r=n[n.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(n=this.sketchCoords_,r=n[n.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,s,i),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(t),"Polygon"===s.getType()&&"Polygon"!==this.mode_?this.createOrUpdateCustomSketchLine_(s):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection();let i,o;const n=this.mode_;return"LineString"===n||"Circle"===n?(this.finishCoordinate_=t.slice(),o=this.sketchCoords_,o.length>=this.maxPoints_&&(this.freehand_?o.pop():i=!0),o.push(t.slice()),this.geometryFunction_(o,e,s)):"Polygon"===n&&(o=this.sketchCoords_[0],o.length>=this.maxPoints_&&(this.freehand_?o.pop():i=!0),o.push(t.slice()),i&&(this.finishCoordinate_=o[0]),this.geometryFunction_(this.sketchCoords_,e,s)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),i?this.finishDrawing():this.sketchFeature_}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection(),i=this.mode_;for(let o=0;o<t;++o){let n;if("LineString"===i||"Circle"===i){if(n=this.sketchCoords_,n.splice(-2,1),n.length>=2){this.finishCoordinate_=n[n.length-2].slice();const r=this.finishCoordinate_.slice();n[n.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(n,e,s),"Polygon"===e.getType()&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if("Polygon"===i){n=this.sketchCoords_[0],n.splice(-2,1);const r=this.sketchLine_.getGeometry();if(n.length>=2){const h=n[n.length-2].slice();n[n.length-1]=h,this.createOrUpdateSketchPoint_(h)}r.setCoordinates(n),this.geometryFunction_(this.sketchCoords_,e,s)}if(1===n.length){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return null;let e=this.sketchCoords_;const s=t.getGeometry(),i=this.getMap().getView().getProjection();return"LineString"===this.mode_?(e.pop(),this.geometryFunction_(e,s,i)):"Polygon"===this.mode_&&(e[0].pop(),this.geometryFunction_(e,s,i),e=s.getCoordinates()),"MultiPoint"===this.type_?t.setGeometry(new C.A([e])):"MultiLineString"===this.type_?t.setGeometry(new d.A([e])):"MultiPolygon"===this.type_&&t.setGeometry(new P.A([e])),this.dispatchEvent(new j("drawend",t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t),t}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new j("drawabort",t))}appendCoordinates(t){const e=this.mode_,s=!this.sketchFeature_;let i;if(s&&this.startDrawing_(t[0]),"LineString"===e||"Circle"===e)i=this.sketchCoords_;else{if("Polygon"!==e)return;i=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[]}s&&i.shift(),i.pop();for(let n=0;n<t.length;n++)this.addToDrawing_(t[n]);const o=t[t.length-1];this.sketchFeature_=this.addToDrawing_(o),this.modifyDrawing_(o)}extend(t){const s=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=s.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new M.default(new T.default(i)),this.updateSketchFeatures_(),this.dispatchEvent(new j("drawstart",this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();(!t||!e)&&this.abortDrawing(),this.overlay_.setMap(e?t:null)}}}}]);
//# sourceMappingURL=default-node_modules_ol_interaction_Draw_js.js.map