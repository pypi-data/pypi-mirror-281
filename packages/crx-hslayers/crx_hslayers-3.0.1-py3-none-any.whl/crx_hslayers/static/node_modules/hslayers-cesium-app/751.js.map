{"version":3,"file":"751.js","mappings":"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","names":["i0","ctx_r1","hsLegendService","legendValid","layer_r3","title","_c0","$event","_r1","titleSearch","refreshList","HsLegendComponent_div_0_span_6_Template","HsLegendComponent_div_0_li_8_Template","rebuildLegends","panelWidthClass","noLayerExists","layerDescriptors","legendFilter","HsLegendComponent","HsPanelBaseComponent","constructor","hsMapService","hsLayerUtilsService","hsUtilsService","hsQueuesService","hsLanguageService","super","this","name","end","Subject","item","RegExp","test","ngOnDestroy","next","complete","ngOnInit","loaded","then","map","getLayers","on","e","layerAdded","removeLayerFromLegends","element","buildLegendsForLayers","addLayerToLegends","layer","_this","_asyncToGenerator","descriptor","getLayerLegendDescriptor","source","getSource","instOf","InterpolatedSource","colorMapChanged","pipe","takeUntil","subscribe","layerSourcePropChanged","target","push","layerVisibilityChanged","isLayerWMS","debounce","getMap","filter","check","visible","length","i","lyr","splice","forEach","_this2","ensureQueue","_ref","cb","_x","apply","arguments","findLayerDescriptor","getVisible","findLayerDescriptorBySource","newDescriptor","subLayerLegends","isLayerIDW","indexOf","find","ld","found","Array","from","static","t","i1","i2","i3","i4","i5","core","VBU","selectors","features","decls","vars","consts","template","rf","ctx","HsLegendComponent_div_0_Template","isVisible$","HsLegendModule","$C","G2t","provideHttpClient","withInterceptorsFromDi","imports","CommonModule","FormsModule","HsPanelHelpersModule","HsPanelHeaderComponent","ctx_r0","layerLegend","legendImage","svgContent","HsLegendLayerStaticComponent","hsLegendLayerStaticService","getLegends","Object","assign","fillContent","lastLegendImage","_angular_core__WEBPACK_IMPORTED_MODULE_2__","inputs","HsLegendLayerStaticComponent_img_0_Template","HsLegendLayerStaticComponent_div_1_Template","legendType","HsLegendLayerStaticService","sanitizer","isArray","bypassSecurityTrustHtml","bypassSecurityTrustResourceUrl","_angular_core__WEBPACK_IMPORTED_MODULE_1__","jDH","factory","Éµfac","providedIn","HsLegendLayerVectorComponent","_angular_core__WEBPACK_IMPORTED_MODULE_0__","svg","HsLegendLayerComponent_Case_2_For_2_Template","category_r3","color","path","height","defaultIconHeight","HsLegendLayerComponent_Case_3_Conditional_1_For_2_Conditional_1_Template","HsLegendLayerComponent_Case_3_Conditional_1_For_2_Conditional_2_Template","HsLegendLayerComponent_Case_3_Conditional_1_For_2_Template","_forTrack0","legendCategories","HsLegendLayerComponent_Case_3_Conditional_0_Template","HsLegendLayerComponent_Case_3_Conditional_1_Template","autoLegend","hasLegendCategories","HsLegendLayerComponent","hsStylerService","signal","onSet","takeUntilDestroyed","setSvg","get","set","_angular_core__WEBPACK_IMPORTED_MODULE_4__","HsLegendLayerComponent_Case_1_Template","HsLegendLayerComponent_Case_2_Template","HsLegendLayerComponent_Case_3_Template","tmp_0_0","type","HsLegendService","hsLayerSelectorService","hsLog","layerSelected","undefined","getVectorLayerLegendSvg","currentLayer","getStyle","parser","SLDParser","default","sldObject","sld","getSld","readStyle","output","layerStyle","Feature","rules","symbolizers","OlStyleParser","getSymbolizersFromOlStyle","warn","defaultStyle","fixOpacity","legendOpts","styles","size","hideRect","legendRenderer","LegendRenderer","el","document","createElement","render","innerHTML","ex","rule","symbol","kind","fillOpacity","opacity","getLegendUrl","layer_name","version","getLayerParams","VERSION","source_url","getURL","getParamsFromUrl","OWSURL","getEnableProxy","proxify","_this3","generateInterpolatedLayerLegend","getTitle","generateSVGGradientForColorMap","_this4","getBase","LAYERS","split","VectorLayer","getShowInLayerManager","ImageLayer","Static","XYZ","getAutoLegend","_angular_core__WEBPACK_IMPORTED_MODULE_15__"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["webpack:///./projects/hslayers/components/legend/legend.component.html","webpack:///./projects/hslayers/components/legend/legend.component.ts","webpack:///./projects/hslayers/components/legend/legend.module.ts","webpack:///./projects/hslayers/components/legend/legend-layer-static/legend-layer-static.component.html","webpack:///./projects/hslayers/components/legend/legend-layer-static/legend-layer-static.component.ts","webpack:///./projects/hslayers/components/legend/legend-layer-static/legend-layer-static.service.ts","webpack:///./projects/hslayers/components/legend/legend-layer-vector/legend-layer-vector.component.ts","webpack:///./projects/hslayers/components/legend/legend-layer-vector/legend-layer-vector.component.html","webpack:///./projects/hslayers/components/legend/legend-layer/legend-layer.component.html","webpack:///./projects/hslayers/components/legend/legend-layer/legend-layer.component.ts","webpack:///./projects/hslayers/components/legend/legend.service.ts"],"sourcesContent":["<div class=\"card hs-main-panel\" *ngIf=\"isVisible$ | async\" [ngClass]=\"panelWidthClass\">\n    <hs-panel-header name=\"legend\" [panelTabs]=\"'LEGEND'\">\n    </hs-panel-header>\n    <div class=\"card-body\">\n        <p><input type=\"text\" class=\"form-control hs-filter\" [placeholder]=\"'COMMON.filter' | translateHs\"\n                [(ngModel)]=\"titleSearch\" (input)=\"refreshList()\"></p>\n        <span *ngIf=\"noLayerExists()\">\n            <p style=\"text-align: center\">{{'LEGEND.noLegendExists' | translateHs }}</p>\n        </span>\n        <ul class=\"list-group\">\n            <li *ngFor=\"let layer of this.layerDescriptors | filter:legendFilter\" class=\"list-group-item\"\n                [hidden]=\"!hsLegendService.legendValid(layer)\"><!-- TODO: Remove function call from template -->\n                <div>\n                    {{layer.title | translateHs : {module: 'LAYERS'} }}\n                    <hs-legend-layer [layer]=\"layer\"></hs-legend-layer>\n                </div>\n            </li>\n        </ul>\n        <div class=\"row justify-content-center\">\n            <div class=\"col col-md-2 d-flex justify-content-center\">\n                <button type=\"button\" class=\"btn btn-light btn-outline ng-scope\" [title]=\"'COMMON.reload' | translateHs\"\n                    (click)=\"rebuildLegends()\">\n                    <i class=\"icon-refresh\"></i>\n                </button>\n            </div>\n        </div>\n    </div>\n</div>\n","import {Component, OnDestroy, OnInit} from '@angular/core';\nimport {Subject, takeUntil} from 'rxjs';\n\nimport BaseLayer from 'ol/layer/Base';\nimport {Layer} from 'ol/layer';\nimport {Map} from 'ol';\nimport {Source} from 'ol/source';\n\nimport {HsLanguageService} from 'hslayers-ng/services/language';\nimport {HsLayerUtilsService} from 'hslayers-ng/services/utils';\nimport {HsLegendDescriptor} from './legend-descriptor.interface';\nimport {HsLegendService} from './legend.service';\nimport {HsMapService} from 'hslayers-ng/services/map';\nimport {HsPanelBaseComponent} from 'hslayers-ng/common/panels';\nimport {HsQueuesService} from 'hslayers-ng/services/queues';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\nimport {InterpolatedSource} from 'hslayers-ng/common/layers';\n\n@Component({\n  selector: 'hs-legend',\n  templateUrl: './legend.component.html',\n})\nexport class HsLegendComponent\n  extends HsPanelBaseComponent\n  implements OnInit, OnDestroy\n{\n  layerDescriptors = [];\n  titleSearch = '';\n  name = 'legend';\n  private end = new Subject<void>();\n  constructor(\n    public hsLegendService: HsLegendService,\n    public hsMapService: HsMapService,\n    public hsLayerUtilsService: HsLayerUtilsService,\n    public hsUtilsService: HsUtilsService,\n    public hsQueuesService: HsQueuesService,\n    public hsLanguageService: HsLanguageService,\n  ) {\n    super();\n  }\n  ngOnDestroy(): void {\n    this.end.next();\n    this.end.complete();\n  }\n\n  ngOnInit(): void {\n    this.hsMapService.loaded().then((map) => {\n      map.getLayers().on('add', (e) => this.layerAdded(e));\n      map.getLayers().on('remove', (e) => {\n        this.removeLayerFromLegends(e.element);\n      });\n      this.buildLegendsForLayers(map);\n    });\n    super.ngOnInit();\n  }\n\n  /**\n   * Add selected layer to the list of layers in legend (with event listener\n   * to display/hide legend item when layer visibility change)\n   * @param layer - Layer to add legend for\n   */\n  async addLayerToLegends(layer: Layer<Source>): Promise<void> {\n    const descriptor =\n      await this.hsLegendService.getLayerLegendDescriptor(layer);\n    if (descriptor) {\n      const source: any = layer.getSource();\n      if (this.hsUtilsService.instOf(source, InterpolatedSource)) {\n        (source as InterpolatedSource).colorMapChanged\n          .pipe(takeUntil(this.end))\n          .subscribe(() => {\n            this.layerSourcePropChanged({target: source});\n          });\n      }\n      this.layerDescriptors.push(descriptor);\n      this.refreshList();\n      layer.on('change:visible', (e) => this.layerVisibilityChanged(e));\n      if (this.hsLayerUtilsService.isLayerWMS(layer)) {\n        layer.getSource()?.on('change', (e) => {\n          this.hsUtilsService.debounce(\n            this.layerSourcePropChanged(e),\n            100,\n            false,\n            this,\n          );\n        });\n      }\n    }\n  }\n\n  rebuildLegends(): void {\n    this.layerDescriptors = [];\n    this.buildLegendsForLayers(this.hsMapService.getMap());\n  }\n\n  legendFilter = (item): boolean => {\n    const r = new RegExp(this.titleSearch, 'i');\n    return r.test(item.title);\n  };\n\n  /**\n   * Check if there is any visible layer\n   * @returns Returns true if no layers with legend exist\n   */\n  noLayerExists(): boolean {\n    const visibleLayers = this.layerDescriptors.filter(\n      (check) => check.visible,\n    );\n    return visibleLayers.length == 0;\n  }\n\n  /**\n   * Remove selected layer from legend items\n   * @param layer - Layer to remove from legend\n   */\n  removeLayerFromLegends(layer: BaseLayer): void {\n    for (let i = 0; i < this.layerDescriptors.length; i++) {\n      if (this.layerDescriptors[i].lyr == layer) {\n        this.layerDescriptors.splice(i, 1);\n        this.refreshList();\n        break;\n      }\n    }\n  }\n\n  buildLegendsForLayers(map: Map): void {\n    map.getLayers().forEach((lyr) => {\n      this.layerAdded({\n        element: lyr,\n      });\n    });\n  }\n\n  /**\n   * (PRIVATE) Callback function for adding layer to map, add layers legend\n   * @param e - Event object, should have element property\n   */\n  layerAdded(e): void {\n    const que = this.hsQueuesService.ensureQueue('addLayerToLegends', 3, 10000);\n    que.push(async (cb) => {\n      await this.addLayerToLegends(e.element);\n      cb(null);\n    });\n  }\n\n  /**\n   * @param e - event description\n   */\n  layerVisibilityChanged(e): void {\n    const descriptor = this.findLayerDescriptor(e.target);\n    if (descriptor) {\n      descriptor.visible = e.target.getVisible();\n    }\n  }\n\n  /**\n   * @param e - event description\n   */\n  layerSourcePropChanged(e): void {\n    const descriptor = this.findLayerDescriptorBySource(e.target);\n    if (descriptor) {\n      this.hsLegendService\n        .getLayerLegendDescriptor(descriptor.lyr)\n        .then((newDescriptor) => {\n          if (\n            newDescriptor.subLayerLegends != descriptor.subLayerLegends ||\n            newDescriptor.title != descriptor.title ||\n            this.hsLayerUtilsService.isLayerIDW(descriptor.lyr)\n          ) {\n            this.layerDescriptors[this.layerDescriptors.indexOf(descriptor)] =\n              newDescriptor;\n            this.refreshList();\n          }\n        });\n    }\n  }\n  /**\n   * Finds layer descriptor for OpenLayers layer\n   * @param layer - OpenLayers layer\n   * @returns Object describing the legend\n   */\n  findLayerDescriptor(layer: Layer<Source>): HsLegendDescriptor {\n    return this.layerDescriptors.find((ld) => ld.lyr == layer);\n  }\n\n  /**\n   * @param source -\n   */\n  findLayerDescriptorBySource(source: Source): any {\n    const found = this.layerDescriptors.filter(\n      (ld) => ld.lyr.getSource() == source,\n    );\n    if (found.length > 0) {\n      return found[0];\n    }\n  }\n\n  refreshList(): void {\n    this.layerDescriptors = Array.from(this.layerDescriptors);\n  }\n}\n","import {CUSTOM_ELEMENTS_SCHEMA, NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {FormsModule} from '@angular/forms';\nimport {provideHttpClient, withInterceptorsFromDi} from '@angular/common/http';\n\nimport {FilterPipe} from 'hslayers-ng/common/pipes';\nimport {HsLegendComponent} from './legend.component';\nimport {HsLegendLayerComponent} from './legend-layer/legend-layer.component';\nimport {HsLegendLayerStaticComponent} from './legend-layer-static/legend-layer-static.component';\nimport {HsLegendLayerVectorComponent} from './legend-layer-vector/legend-layer-vector.component';\nimport {HsPanelHeaderComponent} from 'hslayers-ng/common/panels';\nimport {HsPanelHelpersModule} from 'hslayers-ng/common/panels';\nimport {TranslateCustomPipe} from 'hslayers-ng/services/language';\n@NgModule({\n  schemas: [CUSTOM_ELEMENTS_SCHEMA],\n  declarations: [\n    HsLegendComponent,\n    HsLegendLayerComponent,\n    HsLegendLayerVectorComponent,\n    HsLegendLayerStaticComponent,\n  ],\n  imports: [\n    CommonModule,\n    FormsModule,\n    HsPanelHelpersModule,\n    FilterPipe,\n    TranslateCustomPipe,\n    HsPanelHeaderComponent,\n  ],\n  exports: [HsLegendComponent, HsLegendLayerComponent],\n  providers: [provideHttpClient(withInterceptorsFromDi())],\n})\nexport class HsLegendModule {}\n","<img *ngIf=\"layerLegend.legendType === 'image'\" [src]=\"layerLegend.legendImage\">\n<div *ngIf=\"layerLegend.legendType === 'svg'\" [innerHtml]=\"layerLegend.svgContent\">\n</div>","import {Component, Input, OnInit} from '@angular/core';\n\nimport {HsLegendDescriptor} from '../legend-descriptor.interface';\nimport {HsLegendLayerStaticService} from './legend-layer-static.service';\nimport {LayerLegend} from './types/layer-legend.type';\nimport {getLegends} from 'hslayers-ng/common/extensions';\n\n@Component({\n  selector: 'hs-legend-layer-static',\n  templateUrl: './legend-layer-static.component.html',\n})\nexport class HsLegendLayerStaticComponent implements OnInit {\n  @Input() layer: HsLegendDescriptor;\n  layerLegend: LayerLegend = {};\n\n  constructor(private hsLegendLayerStaticService: HsLegendLayerStaticService) {}\n\n  ngOnInit(): void {\n    if (getLegends(this.layer.lyr)) {\n      Object.assign(\n        this.layerLegend,\n        this.hsLegendLayerStaticService.fillContent(this.layer.lyr),\n      );\n    }\n    this.layer.lyr.on('change', (e) => {\n      //TODO: Maybe rewrite this to something more fancy like Observable\n      if (getLegends(this.layer.lyr) != this.layerLegend.lastLegendImage) {\n        this.hsLegendLayerStaticService.fillContent(this.layer.lyr);\n      }\n    });\n  }\n}\n","import {DomSanitizer} from '@angular/platform-browser';\nimport {Injectable} from '@angular/core';\n\nimport {Layer} from 'ol/layer';\nimport {Source} from 'ol/source';\n\nimport {LayerLegend} from './types/layer-legend.type';\nimport {getLegends} from 'hslayers-ng/common/extensions';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HsLegendLayerStaticService {\n  constructor(private sanitizer: DomSanitizer) {}\n\n  fillContent(lyr: Layer<Source>): LayerLegend {\n    const layerLegend: LayerLegend = {};\n    let legendImage = getLegends(lyr);\n    if (Array.isArray(legendImage)) {\n      legendImage = legendImage[0];\n    }\n    if (legendImage) {\n      layerLegend.lastLegendImage = legendImage;\n      if (legendImage.indexOf('<svg') > -1) {\n        layerLegend.legendType = 'svg';\n        layerLegend.svgContent =\n          this.sanitizer.bypassSecurityTrustHtml(legendImage);\n      } else {\n        layerLegend.legendType = 'image';\n        layerLegend.legendImage =\n          this.sanitizer.bypassSecurityTrustResourceUrl(legendImage);\n      }\n    }\n    return layerLegend;\n  }\n}\n","import {Component, Input} from '@angular/core';\n\n@Component({\n  selector: 'hs-legend-vector-layer',\n  templateUrl: './legend-layer-vector.component.html',\n})\nexport class HsLegendLayerVectorComponent {\n  @Input() svg: string;\n\n  constructor() {}\n}\n","<div class=\"hs-vector-layer-legend\" [innerHtml]=\"svg\"></div>","<div>\n  @switch (layer.type) {\n    @case (\"static\") {\n      <hs-legend-layer-static [layer]=\"layer\"></hs-legend-layer-static>\n    }\n    @case (\"wms\") {\n      <div>\n        @for (sublayer of layer.subLayerLegends; track $index) {\n          <img\n            [src]=\"sublayer\"\n            onerror=\"this.parentNode.removeChild(this);\"\n            onload=\"if(this.height<6) {this.parentNode.removeChild(this);}\"\n          />\n        }\n      </div>\n    }\n    @case (\"vector\") {\n      @if (layer.autoLegend) {\n        <hs-legend-vector-layer [svg]=\"layer.svg\"> </hs-legend-vector-layer>\n      }\n      @if (hasLegendCategories()) {\n        <div>\n          @for (category of legendCategories; track category.name) {\n            <p>\n              @if (category.color) {\n                <span [ngStyle]=\"{ 'background-color': category.color }\"\n                  >&nbsp;&nbsp;&nbsp;</span>\n              } @else if (category.path) {\n                <img\n                  [src]=\"category.path\"\n                  [height]=\"category.height || defaultIconHeight\"\n                />\n              }\n              &emsp;{{ category.name }}\n            </p>\n          }\n        </div>\n      }\n    }\n  }\n</div>\n","import {Component, Input, OnInit, signal} from '@angular/core';\nimport {takeUntilDestroyed} from '@angular/core/rxjs-interop';\n\nimport {HsCustomLegendCategory} from '../legend-custom-category.type';\nimport {HsLegendDescriptor} from '../legend-descriptor.interface';\nimport {HsLegendService} from '../legend.service';\nimport {HsStylerService} from 'hslayers-ng/services/styler';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\n\n@Component({\n  selector: 'hs-legend-layer',\n  templateUrl: './legend-layer.component.html',\n})\nexport class HsLegendLayerComponent implements OnInit {\n  @Input() layer: HsLegendDescriptor;\n\n  legendCategories: HsCustomLegendCategory[];\n  hasLegendCategories = signal(false);\n  /**\n   * default icon height in pixels\n   * @default 32\n   */\n  defaultIconHeight = 32;\n\n  constructor(\n    public hsUtilsService: HsUtilsService,\n    public hsLegendService: HsLegendService,\n    public hsStylerService: HsStylerService,\n  ) {\n    this.hsStylerService.onSet\n      .pipe(takeUntilDestroyed())\n      .subscribe(async (layer) => {\n        if (this.layer.lyr == layer) {\n          this.layer.svg = await this.hsLegendService.setSvg(layer);\n        }\n      });\n  }\n  ngOnInit(): void {\n    this.legendCategories = this.layer.lyr.getSource()?.get('legendCategories');\n    this.hasLegendCategories.set(this.legendCategories?.length > 0);\n  }\n}\n","import {DomSanitizer, SafeHtml} from '@angular/platform-browser';\nimport {Injectable} from '@angular/core';\n\nimport LegendRenderer from 'geostyler-legend/dist/LegendRenderer/LegendRenderer';\nimport {Feature} from 'ol';\nimport {Style as GeoStylerStyle} from 'geostyler-style';\nimport {Image as ImageLayer, Layer, Vector as VectorLayer} from 'ol/layer';\nimport {OlStyleParser} from 'geostyler-openlayers-parser';\nimport {SldStyleParser as SLDParser} from 'geostyler-sld-parser';\nimport {Source, ImageStatic as Static, XYZ} from 'ol/source';\nimport {Style} from 'ol/style';\n\nimport {HsLayerSelectorService} from 'hslayers-ng/services/layer-manager';\nimport {HsLayerUtilsService} from 'hslayers-ng/services/utils';\nimport {HsLegendDescriptor} from './legend-descriptor.interface';\nimport {HsLogService} from 'hslayers-ng/services/log';\nimport {HsStylerService} from 'hslayers-ng/services/styler';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\nimport {InterpolatedSource} from 'hslayers-ng/common/layers';\nimport {defaultStyle} from 'hslayers-ng/services/styler';\nimport {filter} from 'rxjs';\nimport {\n  getAutoLegend,\n  getBase,\n  getEnableProxy,\n  getLegends,\n  getShowInLayerManager,\n  getSld,\n  getTitle,\n} from 'hslayers-ng/common/extensions';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HsLegendService {\n  constructor(\n    public hsUtilsService: HsUtilsService,\n    public hsStylerService: HsStylerService,\n    private hsLayerUtilsService: HsLayerUtilsService,\n    public hsLayerSelectorService: HsLayerSelectorService,\n    private hsLog: HsLogService,\n    private sanitizer: DomSanitizer,\n  ) {\n    this.hsLayerSelectorService.layerSelected\n      .pipe(filter((layer) => !!layer))\n      .subscribe(async (layer) => {\n        await this.getLayerLegendDescriptor(layer.layer);\n      });\n  }\n\n  /**\n   * Test if layer is visible and has supported type (conditions for displaying legend)\n   * @param layer - Layer to test\n   * @returns Return if legend might exist for layer and layer is visible\n   */\n  legendValid(layer: HsLegendDescriptor): boolean {\n    if (layer === undefined || layer.type == undefined) {\n      return false;\n    }\n    if (\n      ['vector', 'wms', 'static'].indexOf(layer.type) > -1 &&\n      layer.lyr.getVisible()\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get legend graphics for a vector layer based on sld attribute. If no SLD exists, try to generate it from OL style.\n   * @param currentLayer - Layer of interest\n   * @returns Image as SVG string\n   */\n  async getVectorLayerLegendSvg(\n    currentLayer: VectorLayer<Feature>,\n  ): Promise<string> {\n    try {\n      if (currentLayer === undefined) {\n        return;\n      }\n      if (!currentLayer.getStyle()) {\n        return;\n      }\n      const parser = (SLDParser as any).default\n        ? new (SLDParser as any).default()\n        : new SLDParser();\n      let sld = getSld(currentLayer);\n      let sldObject: GeoStylerStyle;\n      if (!sld) {\n        let layerStyle = currentLayer.getStyle();\n        if (typeof layerStyle == 'function') {\n          layerStyle = <Style | Style[]>layerStyle(new Feature(), 1);\n        }\n        try {\n          layerStyle = layerStyle as Style | Style[];\n          const symbolizers = new OlStyleParser().getSymbolizersFromOlStyle(\n            Array.isArray(layerStyle) ? layerStyle : [layerStyle],\n          );\n          sldObject = {\n            name: '',\n            rules: [\n              {\n                name: '',\n                symbolizers,\n              },\n            ],\n          };\n        } catch {\n          this.hsLog.warn(\n            'FlatStyle and FlatStyleLike styles are not yet supported by Geostyler',\n          );\n        }\n      } else {\n        sldObject = (await parser.readStyle(sld)).output;\n      }\n\n      //In case SLD was not valid for parser, create a new one from default style\n      if (!sldObject) {\n        sld = defaultStyle;\n        sldObject = (await parser.readStyle(sld)).output;\n      }\n      this.fixOpacity(sldObject);\n      const legendOpts: any = {\n        styles: [sldObject],\n        size: [300, 200],\n        hideRect: true,\n      };\n      const legendRenderer = (LegendRenderer as any).default\n        ? new (LegendRenderer as any).default(legendOpts)\n        : new LegendRenderer(legendOpts);\n      const el = document.createElement('div');\n      await legendRenderer.render(el);\n      return el.innerHTML;\n    } catch (ex) {\n      throw ex;\n    }\n  }\n\n  private fixOpacity(sldObject: GeoStylerStyle) {\n    for (const rule of sldObject.rules) {\n      for (const symbol of rule.symbolizers) {\n        if (symbol.kind == 'Fill' && symbol.fillOpacity && !symbol.opacity) {\n          symbol.opacity = symbol.fillOpacity;\n        }\n      }\n    }\n  }\n\n  /**\n   * Generate url for GetLegendGraphic request of WMS service for selected layer\n   * @param source - Source of wms layer\n   * @param layer_name - Name of layer for which legend is requested\n   * @param layer - Layer to get legend for\n   * @returns Url of the legend graphics\n   */\n  getLegendUrl(\n    source: Source,\n    layer_name: string,\n    layer: Layer<Source>,\n  ): string {\n    if (!this.hsLayerUtilsService.isLayerWMS(layer)) {\n      return '';\n    }\n    const params = this.hsLayerUtilsService.getLayerParams(layer);\n    const version = params.VERSION || '1.3.0';\n    let source_url = this.hsLayerUtilsService.getURL(layer);\n    if (source_url.indexOf('proxy4ows') > -1) {\n      const params = this.hsUtilsService.getParamsFromUrl(source_url);\n      source_url = params.OWSURL;\n    }\n    const legendImage = getLegends(layer);\n    if (\n      legendImage === undefined ||\n      (Array.isArray(legendImage) && legendImage.length == 0)\n    ) {\n      source_url +=\n        (source_url.indexOf('?') > 0 ? '' : '?') +\n        '&version=' +\n        version +\n        '&service=WMS&request=GetLegendGraphic&sld_version=1.1.0&layer=' +\n        layer_name +\n        '&format=image%2Fpng';\n      if (\n        getEnableProxy(layer) === undefined ||\n        getEnableProxy(layer) == true\n      ) {\n        source_url = this.hsUtilsService.proxify(source_url);\n      }\n      return source_url;\n    } else {\n      if (typeof legendImage == 'string') {\n        return legendImage;\n      }\n      if (Array.isArray(legendImage)) {\n        return legendImage[0];\n      }\n    }\n  }\n\n  async setSvg(layer: Layer<Source>): Promise<SafeHtml> {\n    return this.sanitizer.bypassSecurityTrustHtml(\n      await this.getVectorLayerLegendSvg(layer as VectorLayer<Feature>),\n    );\n  }\n\n  /**\n   * Generate SVG linear gradient for layers colormap\n   */\n  generateInterpolatedLayerLegend(layer: Layer<any>) {\n    return {\n      autoLegend: true,\n      title: getTitle(layer),\n      lyr: layer,\n      type: 'vector',\n      visible: layer.getVisible(),\n      svg: this.hsStylerService.generateSVGGradientForColorMap(layer),\n    };\n  }\n\n  /**\n   * (PRIVATE) Generate url for GetLegendGraphic request of WMS service for selected layer\n   * @param layer - OpenLayers layer\n   * @returns Description of layer to be used for creating the legend. It contains type of layer, sublayer legends, title, visibility etc.\n   */\n  async getLayerLegendDescriptor(\n    layer: Layer<Source>,\n  ): Promise<HsLegendDescriptor | undefined> {\n    if (getBase(layer)) {\n      return;\n    }\n    if (this.hsLayerUtilsService.isLayerWMS(layer)) {\n      const subLayerLegends = this.hsLayerUtilsService\n        .getLayerParams(layer)\n        .LAYERS?.split(',');\n      for (let i = 0; i < subLayerLegends.length; i++) {\n        subLayerLegends[i] = this.getLegendUrl(\n          layer.getSource(),\n          subLayerLegends[i],\n          layer,\n        );\n      }\n      return {\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'wms',\n        subLayerLegends: subLayerLegends,\n        visible: layer.getVisible(),\n      };\n    } else if (\n      this.hsUtilsService.instOf(layer, VectorLayer) &&\n      (getShowInLayerManager(layer) === undefined ||\n        getShowInLayerManager(layer) == true)\n    ) {\n      return {\n        autoLegend: getAutoLegend(layer) ?? true,\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'vector',\n        visible: layer.getVisible(),\n        svg: await this.setSvg(layer),\n      };\n    } else if (\n      this.hsUtilsService.instOf(layer, ImageLayer) &&\n      this.hsUtilsService.instOf(layer.getSource(), Static)\n    ) {\n      return {\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'static',\n        visible: layer.getVisible(),\n      };\n    } else if (this.hsUtilsService.instOf(layer.getSource(), XYZ)) {\n      return {\n        title: getTitle(layer),\n        lyr: layer,\n        type: 'static',\n        visible: layer.getVisible(),\n      };\n    } else if (\n      this.hsUtilsService.instOf(layer.getSource(), InterpolatedSource)\n    ) {\n      return this.generateInterpolatedLayerLegend(layer);\n    } else {\n      return undefined;\n    }\n  }\n}\n"],"x_google_ignoreList":[]}