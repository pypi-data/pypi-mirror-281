{"version":3,"file":"399.js","mappings":"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","names":["GEOMETRY_READERS","Point","readPointGeometry","object","scale","translate","coordinates","transformVertex","LineString","readLineStringGeometry","arcs","concatenateArcs","Polygon","readPolygonGeometry","i","ii","length","MultiPoint","readMultiPointGeometry","MultiLineString","readMultiLineStringGeometry","MultiPolygon","readMultiPolygonGeometry","polyArray","ringCoords","j","jj","indices","index","pop","arc","push","slice","readFeaturesFromGeometryCollection","collection","property","name","options","geometries","features","readFeatureFromGeometry","geometry","type","geometryReader","transformGeometryWithOptions","feature","Feature","undefined","id","setId","properties","setProperties","transformArc","x","y","vertex","__WEBPACK_DEFAULT_EXPORT__","TopoJSON","JSONFeature","constructor","super","this","layerName_","layerName","layers_","layers","dataProjection","getProjection","readFeaturesFromObject","topoJSONTopology","transform","transformArcs","topoJSONFeatures","objects","objectName","includes","apply","readProjectionFromObject"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["webpack:///./node_modules/ol/format/TopoJSON.js"],"sourcesContent":["/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nclass TopoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.layerName_ = options.layerName;\n\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326',\n    );\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    if (object.type == 'Topology') {\n      const topoJSONTopology = /** @type {TopoJSONTopology} */ (object);\n      let transform,\n        scale = null,\n        translate = null;\n      if (topoJSONTopology['transform']) {\n        transform = topoJSONTopology['transform'];\n        scale = transform['scale'];\n        translate = transform['translate'];\n      }\n      const arcs = topoJSONTopology['arcs'];\n      if (transform) {\n        transformArcs(arcs, scale, translate);\n      }\n      /** @type {Array<Feature>} */\n      const features = [];\n      const topoJSONFeatures = topoJSONTopology['objects'];\n      const property = this.layerName_;\n      let feature;\n      for (const objectName in topoJSONFeatures) {\n        if (this.layers_ && !this.layers_.includes(objectName)) {\n          continue;\n        }\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature = /** @type {TopoJSONGeometryCollection} */ (\n            topoJSONFeatures[objectName]\n          );\n          features.push.apply(\n            features,\n            readFeaturesFromGeometryCollection(\n              feature,\n              arcs,\n              scale,\n              translate,\n              property,\n              objectName,\n              options,\n            ),\n          );\n        } else {\n          feature = /** @type {TopoJSONGeometry} */ (\n            topoJSONFeatures[objectName]\n          );\n          features.push(\n            readFeatureFromGeometry(\n              feature,\n              arcs,\n              scale,\n              translate,\n              property,\n              objectName,\n              options,\n            ),\n          );\n        }\n      }\n      return features;\n    }\n    return [];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return this.dataProjection;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nconst GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry,\n};\n\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  const coordinates = [];\n  let index;\n  for (let i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n    if (index >= 0) {\n      // forward arc\n      const arc = arcs[index];\n      for (let j = 0, jj = arc.length; j < jj; ++j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    } else {\n      // reverse arc\n      const arc = arcs[~index];\n      for (let j = arc.length - 1; j >= 0; --j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    }\n  }\n  return coordinates;\n}\n\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n  return new Point(coordinates);\n}\n\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n  return new MultiPoint(coordinates);\n}\n\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n  const coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new MultiLineString(coordinates);\n}\n\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new Polygon(coordinates);\n}\n\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    const polyArray = object['arcs'][i];\n    const ringCoords = [];\n    for (let j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n    coordinates[i] = ringCoords;\n  }\n  return new MultiPolygon(coordinates);\n}\n\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(\n  collection,\n  arcs,\n  scale,\n  translate,\n  property,\n  name,\n  options,\n) {\n  const geometries = collection['geometries'];\n  const features = [];\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(\n      geometries[i],\n      arcs,\n      scale,\n      translate,\n      property,\n      name,\n      options,\n    );\n  }\n  return features;\n}\n\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(\n  object,\n  arcs,\n  scale,\n  translate,\n  property,\n  name,\n  options,\n) {\n  let geometry = null;\n  const type = object.type;\n  if (type) {\n    const geometryReader = GEOMETRY_READERS[type];\n    if (type === 'Point' || type === 'MultiPoint') {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    geometry = transformGeometryWithOptions(geometry, false, options);\n  }\n  const feature = new Feature({geometry: geometry});\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n  let properties = object.properties;\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n    properties[property] = name;\n  }\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n  return feature;\n}\n\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n  for (let i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n  let x = 0;\n  let y = 0;\n  for (let i = 0, ii = arc.length; i < ii; ++i) {\n    const vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\n\nexport default TopoJSON;\n"],"x_google_ignoreList":[0]}