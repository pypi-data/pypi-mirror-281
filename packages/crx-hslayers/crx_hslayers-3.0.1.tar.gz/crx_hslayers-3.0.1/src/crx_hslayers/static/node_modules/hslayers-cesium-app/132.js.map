{"version":3,"file":"132.js","mappings":"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","names":["GeolocationError","BaseEvent","constructor","error","super","this","code","message","ol_Geolocation","Geolocation","BaseObject","options","position_","transform_","identityTransform","watchId_","undefined","addChangeListener","handleProjectionChanged_","handleTrackingChanged_","projection","setProjection","trackingOptions","setTrackingOptions","setTracking","tracking","disposeInternal","getProjection","getTransformFromProjections","set","navigator","getTracking","geolocation","watchPosition","positionChange_","bind","positionError_","getTrackingOptions","clearWatch","position","coords","accuracy","altitude","altitudeAccuracy","heading","toRadians","longitude","latitude","projectedPosition","slice","speed","geometry","circularPolygon","applyTransform","changed","dispatchEvent","getAccuracy","get","getAccuracyGeometry","getAltitude","getAltitudeAccuracy","getHeading","getPosition","getSpeed","PROJECTION","HsGeolocationService","HsMapService","HsLayoutService","hsLog","HsUtilsService","localization","trackOrientation","following","setAccuracyFeature","setPositionFeature","setStyle","loaded","then","map","getCurrentProj","enableHighAccuracy","accuracyFeature","style","positionFeature","position_layer","VectorLayer","source","Vector","setTitle","setShowInLayerManager","setRemovable","src","getSource","addFeature","addControl","Rotate","resetNorth","toggleOrientation","className","autoHide","stopTracking","getRotate","element","classList","add","getMap","getView","setRotation","toggleTracking","_this","_asyncToGenerator","clicked","cancelClick","sidebarPosition$","getValue","contentWrapper","querySelector","Event","setTimeout","isCentered","on","setNewPosition","setCenter","stopLocalization","removeLayer","startLocalization","once","addLayer","setZIndex","JSON","stringify","getCenter","getGeometry","getCoordinates","setCoordinates","setCenterAndRadius","toggle","remove","orientationListener","handleOrientation","window","addEventListener","removeEventListener","event","alpha","Math","PI","control","getControls","getArray","Feature","known","CircleGeom","Point","Style","image","Circle","fill","Fill","color","stroke","Stroke","radius","static","t","i0","i1","i2","i3","i4","core","jDH","factory","ɵfac","providedIn","_r1","ctx_r1","_r3","isFollowing","getLocalization","HsGeolocationComponent","HsGuiOverlayBaseComponent","hsGeolocationService","name","ngOnInit","collapsed","isVisible","hsLayoutService","componentEnabled","VBU","selectors","features","decls","vars","consts","template","rf","ctx","HsGeolocationComponent_button_2_Template","HsGeolocationComponent_button_3_Template","isVisible$","_c0","HsGeolocationModule","$C","G2t","FormsModule","CommonModule","HsPanelHelpersModule","SimpleGeometry","center","layout","setFlatCoordinates","clone","circle","flatCoordinates","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","i","stride","delta","getRadius","sqrt","length","containsXY","getRadiusSquared_","computeExtent","extent","createOrUpdate","getType","intersectsExtent","circleExtent","getExtent","intersects","forEachCorner","intersectsCoordinate","setLayout","offset","deflateCoordinate","ii","coordinates","setRadius","rotate","angle","anchor","getStride","__WEBPACK_DEFAULT_EXPORT__"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["webpack:///./node_modules/ol/Geolocation.js","webpack:///./projects/hslayers/components/geolocation/geolocation.service.ts","webpack:///./projects/hslayers/components/geolocation/geolocation.component.html","webpack:///./projects/hslayers/components/geolocation/geolocation.component.ts","webpack:///./projects/hslayers/components/geolocation/geolocation.module.ts","webpack:///./node_modules/ol/geom/Circle.js"],"sourcesContent":["/**\n * @module ol/Geolocation\n */\nimport BaseEvent from './events/Event.js';\nimport BaseObject from './Object.js';\nimport {circular as circularPolygon} from './geom/Polygon.js';\nimport {\n  get as getProjection,\n  getTransformFromProjections,\n  identityTransform,\n} from './proj.js';\nimport {toRadians} from './math.js';\n\n/**\n * @enum {string}\n */\nconst Property = {\n  ACCURACY: 'accuracy',\n  ACCURACY_GEOMETRY: 'accuracyGeometry',\n  ALTITUDE: 'altitude',\n  ALTITUDE_ACCURACY: 'altitudeAccuracy',\n  HEADING: 'heading',\n  POSITION: 'position',\n  PROJECTION: 'projection',\n  SPEED: 'speed',\n  TRACKING: 'tracking',\n  TRACKING_OPTIONS: 'trackingOptions',\n};\n\n/**\n * @enum string\n */\nconst GeolocationErrorType = {\n  /**\n   * Triggered when a `GeolocationPositionError` occurs.\n   * @event module:ol/Geolocation.GeolocationError#error\n   * @api\n   */\n  ERROR: 'error',\n};\n\n/**\n * @classdesc\n * Events emitted on [GeolocationPositionError](https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError).\n */\nexport class GeolocationError extends BaseEvent {\n  /**\n   * @param {GeolocationPositionError} error error object.\n   */\n  constructor(error) {\n    super(GeolocationErrorType.ERROR);\n\n    /**\n     * Code of the underlying `GeolocationPositionError`.\n     * @type {number}\n     * @api\n     */\n    this.code = error.code;\n\n    /**\n     * Message of the underlying `GeolocationPositionError`.\n     * @type {string}\n     * @api\n     */\n    this.message = error.message;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [tracking=false] Start Tracking right after\n * instantiation.\n * @property {PositionOptions} [trackingOptions] Tracking options.\n * See https://www.w3.org/TR/geolocation-API/#position_options_interface.\n * @property {import(\"./proj.js\").ProjectionLike} [projection] The projection the position\n * is reported in.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|\n *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|\n *    'change:trackingOptions'} GeolocationObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<GeolocationObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").OnSignature<'error', GeolocationError, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|GeolocationObjectEventTypes, Return> &\n *   import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return>} GeolocationOnSignature\n */\n\n/**\n * @classdesc\n * Helper class for providing HTML5 Geolocation capabilities.\n * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)\n * is used to locate a user's position.\n *\n * To get notified of position changes and errors, register listeners for the generic\n * `change` event and the `error` event on your instance of {@link module:ol/Geolocation~Geolocation}.\n *\n * Example:\n *\n *     const geolocation = new Geolocation({\n *       // take the projection to use from the map's view\n *       projection: view.getProjection()\n *     });\n *     // listen to changes in position\n *     geolocation.on('change', function(evt) {\n *       console.log(geolocation.getPosition());\n *     });\n *     // listen to error\n *     geolocation.on('error', function(evt) {\n *       window.console.log(evt.message);\n *     });\n *\n * @fires GeolocationError\n * @api\n */\nclass Geolocation extends BaseObject {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {GeolocationOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {GeolocationOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {GeolocationOnSignature<void>}\n     */\n    this.un;\n\n    options = options || {};\n\n    /**\n     * The unprojected (EPSG:4326) device position.\n     * @private\n     * @type {?import(\"./coordinate.js\").Coordinate}\n     */\n    this.position_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./proj.js\").TransformFunction}\n     */\n    this.transform_ = identityTransform;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.watchId_ = undefined;\n\n    this.addChangeListener(Property.PROJECTION, this.handleProjectionChanged_);\n    this.addChangeListener(Property.TRACKING, this.handleTrackingChanged_);\n\n    if (options.projection !== undefined) {\n      this.setProjection(options.projection);\n    }\n    if (options.trackingOptions !== undefined) {\n      this.setTrackingOptions(options.trackingOptions);\n    }\n\n    this.setTracking(options.tracking !== undefined ? options.tracking : false);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.setTracking(false);\n    super.disposeInternal();\n  }\n\n  /**\n   * @private\n   */\n  handleProjectionChanged_() {\n    const projection = this.getProjection();\n    if (projection) {\n      this.transform_ = getTransformFromProjections(\n        getProjection('EPSG:4326'),\n        projection,\n      );\n      if (this.position_) {\n        this.set(Property.POSITION, this.transform_(this.position_));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleTrackingChanged_() {\n    if ('geolocation' in navigator) {\n      const tracking = this.getTracking();\n      if (tracking && this.watchId_ === undefined) {\n        this.watchId_ = navigator.geolocation.watchPosition(\n          this.positionChange_.bind(this),\n          this.positionError_.bind(this),\n          this.getTrackingOptions(),\n        );\n      } else if (!tracking && this.watchId_ !== undefined) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = undefined;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {GeolocationPosition} position position event.\n   */\n  positionChange_(position) {\n    const coords = position.coords;\n    this.set(Property.ACCURACY, coords.accuracy);\n    this.set(\n      Property.ALTITUDE,\n      coords.altitude === null ? undefined : coords.altitude,\n    );\n    this.set(\n      Property.ALTITUDE_ACCURACY,\n      coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy,\n    );\n    this.set(\n      Property.HEADING,\n      coords.heading === null ? undefined : toRadians(coords.heading),\n    );\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n    const projectedPosition = this.transform_(this.position_);\n    this.set(Property.POSITION, projectedPosition.slice());\n    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);\n    const geometry = circularPolygon(this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(Property.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  }\n\n  /**\n   * @private\n   * @param {GeolocationPositionError} error error object.\n   */\n  positionError_(error) {\n    this.dispatchEvent(new GeolocationError(error));\n  }\n\n  /**\n   * Get the accuracy of the position in meters.\n   * @return {number|undefined} The accuracy of the position measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  getAccuracy() {\n    return /** @type {number|undefined} */ (this.get(Property.ACCURACY));\n  }\n\n  /**\n   * Get a geometry of the position accuracy.\n   * @return {?import(\"./geom/Polygon.js\").default} A geometry of the position accuracy.\n   * @observable\n   * @api\n   */\n  getAccuracyGeometry() {\n    return /** @type {?import(\"./geom/Polygon.js\").default} */ (\n      this.get(Property.ACCURACY_GEOMETRY) || null\n    );\n  }\n\n  /**\n   * Get the altitude associated with the position.\n   * @return {number|undefined} The altitude of the position in meters above mean\n   *     sea level.\n   * @observable\n   * @api\n   */\n  getAltitude() {\n    return /** @type {number|undefined} */ (this.get(Property.ALTITUDE));\n  }\n\n  /**\n   * Get the altitude accuracy of the position.\n   * @return {number|undefined} The accuracy of the altitude measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  getAltitudeAccuracy() {\n    return /** @type {number|undefined} */ (\n      this.get(Property.ALTITUDE_ACCURACY)\n    );\n  }\n\n  /**\n   * Get the heading as radians clockwise from North.\n   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`\n   * is set to `true` in the tracking options.\n   * @return {number|undefined} The heading of the device in radians from north.\n   * @observable\n   * @api\n   */\n  getHeading() {\n    return /** @type {number|undefined} */ (this.get(Property.HEADING));\n  }\n\n  /**\n   * Get the position of the device.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The current position of the device reported\n   *     in the current projection.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the projection associated with the position.\n   * @return {import(\"./proj/Projection.js\").default|undefined} The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  getProjection() {\n    return /** @type {import(\"./proj/Projection.js\").default|undefined} */ (\n      this.get(Property.PROJECTION)\n    );\n  }\n\n  /**\n   * Get the speed in meters per second.\n   * @return {number|undefined} The instantaneous speed of the device in meters\n   *     per second.\n   * @observable\n   * @api\n   */\n  getSpeed() {\n    return /** @type {number|undefined} */ (this.get(Property.SPEED));\n  }\n\n  /**\n   * Determine if the device location is being tracked.\n   * @return {boolean} The device location is being tracked.\n   * @observable\n   * @api\n   */\n  getTracking() {\n    return /** @type {boolean} */ (this.get(Property.TRACKING));\n  }\n\n  /**\n   * Get the tracking options.\n   * See https://www.w3.org/TR/geolocation-API/#position-options.\n   * @return {PositionOptions|undefined} PositionOptions as defined by\n   *     the [HTML5 Geolocation spec\n   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  getTrackingOptions() {\n    return /** @type {PositionOptions|undefined} */ (\n      this.get(Property.TRACKING_OPTIONS)\n    );\n  }\n\n  /**\n   * Set the projection to use for transforming the coordinates.\n   * @param {import(\"./proj.js\").ProjectionLike} projection The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  setProjection(projection) {\n    this.set(Property.PROJECTION, getProjection(projection));\n  }\n\n  /**\n   * Enable or disable tracking.\n   * @param {boolean} tracking Enable tracking.\n   * @observable\n   * @api\n   */\n  setTracking(tracking) {\n    this.set(Property.TRACKING, tracking);\n  }\n\n  /**\n   * Set the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @param {PositionOptions} options PositionOptions as defined by the\n   *     [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  setTrackingOptions(options) {\n    this.set(Property.TRACKING_OPTIONS, options);\n  }\n}\n\nexport default Geolocation;\n","import {Injectable} from '@angular/core';\n\nimport {Circle, Fill, Stroke, Style} from 'ol/style';\nimport {Circle as CircleGeom, Point} from 'ol/geom';\nimport {Feature, Geolocation} from 'ol';\nimport {Rotate} from 'ol/control';\nimport {Vector} from 'ol/source';\nimport {Vector as VectorLayer} from 'ol/layer';\n\nimport {HsLayoutService} from 'hslayers-ng/services/layout';\nimport {HsLogService} from 'hslayers-ng/services/log';\nimport {HsMapService} from 'hslayers-ng/services/map';\nimport {HsUtilsService} from 'hslayers-ng/services/utils';\nimport {\n  setRemovable,\n  setShowInLayerManager,\n  setTitle,\n} from 'hslayers-ng/common/extensions';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HsGeolocationService {\n  /**\n   * Represents geolocation state (on/off)\n   */\n  centering: boolean;\n  accuracyFeature: Feature<CircleGeom>;\n  geolocation: any;\n  clicked: any;\n  cancelClick: boolean;\n  style: any;\n  position_layer: any;\n\n  localization = false;\n\n  trackOrientation = false;\n  orientationListener: EventListenerObject;\n  /**\n   * Represents geolocation tracking option (on/off).\n   * Used to determine state of tracking in directive's html\n   */\n  following = false;\n  gn: any;\n  positionFeature: Feature<Point>;\n  /**\n   * Turns off position centering while 'following'.\n   */\n  constructor(\n    public HsMapService: HsMapService,\n    public HsLayoutService: HsLayoutService,\n    public hsLog: HsLogService,\n    public HsUtilsService: HsUtilsService,\n  ) {\n    this.setAccuracyFeature();\n    this.setPositionFeature();\n    this.setStyle();\n\n    this.HsMapService.loaded().then((map) => {\n      this.geolocation = new Geolocation({\n        projection: this.HsMapService.getCurrentProj(),\n        trackingOptions: {\n          enableHighAccuracy: true,\n        },\n      });\n\n      this.accuracyFeature.setStyle(this.style);\n      this.positionFeature.setStyle(this.style);\n\n      this.position_layer = new VectorLayer({\n        source: new Vector(),\n      });\n      setTitle(this.position_layer, 'Position');\n      setShowInLayerManager(this.position_layer, false);\n      setRemovable(this.position_layer, false);\n      const src = this.position_layer.getSource();\n\n      src.addFeature(this.accuracyFeature);\n      src.addFeature(this.positionFeature);\n\n      map.addControl(\n        new Rotate({\n          resetNorth: this.toggleOrientation.bind(this),\n          className: 'ol-rotate hidden',\n          autoHide: false,\n        }),\n      );\n    });\n  }\n\n  /**\n   * Reset all geolocation parameters concerning position tracking\n   */\n  stopTracking(): void {\n    this.following = false;\n    const rotate = this.getRotate();\n    rotate.element.classList.add('hidden');\n    this.geolocation.setTracking(false);\n    this.HsMapService.getMap().getView().setRotation(0);\n  }\n\n  /**\n   * Toggles tracking/following\n   * Takes care of the distinction between click and double-click on mobile\n   */\n  async toggleTracking(): Promise<void> {\n    if (this.clicked) {\n      this.cancelClick = true;\n      if (this.HsLayoutService.sidebarPosition$.getValue() == 'bottom') {\n        this.HsLayoutService.contentWrapper\n          .querySelector('.hs-locationButton')\n          .dispatchEvent(new Event('dblclick'));\n      }\n      return;\n    }\n    this.clicked = true;\n    setTimeout(() => {\n      if (this.cancelClick) {\n        this.cancelClick = false;\n        this.clicked = false;\n        return;\n      }\n      if (this.isCentered()) {\n        if (!this.following) {\n          //position\n          this.geolocation.on('change:position', () => this.setNewPosition());\n          this.geolocation.setTracking(true);\n          this.following = true;\n\n          //rotation\n          this.toggleOrientation();\n        } else {\n          this.stopTracking();\n          this.toggleOrientation();\n        }\n      } else {\n        const position = this.geolocation.getPosition();\n        if (position) {\n          this.HsMapService.getMap().getView().setCenter(position);\n        }\n      }\n\n      //clean up\n      this.cancelClick = false;\n      this.clicked = false;\n    }, 500);\n  }\n\n  /**\n   * Reset all geolocation parameters\n   */\n  stopLocalization(): void {\n    this.localization = false;\n    this.HsMapService.getMap().removeLayer(this.position_layer);\n    this.stopTracking();\n    if (this.trackOrientation) {\n      this.toggleOrientation();\n    }\n  }\n\n  /**\n   * Display current position by querying geolocation, once\n   */\n  startLocalization(): void {\n    if (!this.localization) {\n      this.geolocation.setTracking(true);\n      this.localization = true;\n      this.geolocation.once('change:position', () => {\n        this.setNewPosition();\n        this.HsMapService.getMap()\n          .getView()\n          .setCenter(this.geolocation.getPosition());\n        this.HsMapService.getMap().addLayer(this.position_layer);\n        this.position_layer.setZIndex(99);\n\n        //stop tracking position\n        this.geolocation.setTracking(false);\n      });\n    }\n  }\n\n  /**\n   * Function which determines whether map is centered on current position or not\n   */\n  isCentered(): any {\n    return (\n      JSON.stringify(this.HsMapService.getMap().getView().getCenter()) ===\n      JSON.stringify(this.positionFeature.getGeometry().getCoordinates())\n    );\n  }\n\n  /**\n   * Callback function handling geolocation change:position event\n   */\n  setNewPosition(): void {\n    const position = this.geolocation.getPosition();\n    this.positionFeature.getGeometry().setCoordinates(position);\n    this.accuracyFeature\n      .getGeometry()\n      .setCenterAndRadius(position, this.geolocation.getAccuracy());\n    this.HsMapService.getMap().getView().setCenter(position);\n  }\n\n  toggleOrientation(): void {\n    this.trackOrientation = !this.trackOrientation;\n    this.HsLayoutService.contentWrapper\n      .querySelector('button.ol-rotate')\n      .classList.toggle('active');\n\n    if (this.trackOrientation) {\n      const rotate = this.getRotate();\n      rotate.element.classList.remove('hidden');\n\n      this.orientationListener = this.handleOrientation.bind(this);\n      window.addEventListener('deviceorientation', this.orientationListener);\n    } else {\n      window.removeEventListener('deviceorientation', this.orientationListener);\n      const view = this.HsMapService.getMap().getView();\n      view.setRotation(0);\n    }\n  }\n\n  /**\n   * Orientation change handler\n   */\n  handleOrientation(event: DeviceOrientationEvent) {\n    const alpha = event.alpha ?? 0;\n    this.HsMapService.getMap()\n      .getView()\n      .setRotation((360 - alpha) * (Math.PI / 180));\n  }\n\n  /**\n   * Get map rotate control\n   */\n  private getRotate(): any {\n    for (const control of this.HsMapService.getMap().getControls().getArray()) {\n      if (control instanceof Rotate) {\n        return control;\n      }\n    }\n  }\n\n  /**\n   * Set accuracy feature\n   */\n  private setAccuracyFeature(): void {\n    this.accuracyFeature = new Feature({\n      known: false,\n      geometry: new CircleGeom([0, 0], 1),\n    }) as Feature<CircleGeom>;\n  }\n\n  /**\n   * Set position feature\n   */\n  private setPositionFeature(): void {\n    this.positionFeature = new Feature({\n      known: false,\n      geometry: new Point([0, 0]),\n    }) as Feature<Point>;\n  }\n\n  /**\n   * Set feature style\n   */\n  private setStyle(): void {\n    this.style = new Style({\n      image: new Circle({\n        fill: new Fill({\n          color: [242, 121, 0, 0.7],\n        }),\n        stroke: new Stroke({\n          color: [0xbb, 0x33, 0x33, 0.7],\n        }),\n        radius: 5,\n      }),\n      fill: new Fill({\n        color: [0xbb, 0xbb, 0xbb, 0.2],\n      }),\n      stroke: new Stroke({\n        color: [0x66, 0x66, 0x00, 0.8],\n      }),\n    });\n  }\n}\n","<div class=\"hs-locate ol-unselectable ol-control hs-locateToggler\" [hidden]=\"(isVisible$ | async) === false\"\n    [ngClass]=\"{'ol-collapsed': collapsed}\">\n    <button class=\"ol-has-tooltip blocate hs-locateToggler\" [title]=\"'GEOLOCATION.locateMe' | translateHs\"\n        *ngIf=\"!getLocalization()\" type=\"button\" (click)=\"startLocalization()\">\n        <i class=\"glyphicon icon-gpsoff-gps hs-locateToggler\"></i>\n    </button>\n    <button *ngIf=\"getLocalization()\" class=\"ol-has-tooltip blocate hs-locateToggler hs-locationButton\" type=\"button\"\n        (click)=\"toggleTracking()\" [title]=\"'GEOLOCATION.locateMe' | translateHs\" (dblclick)=\"stopLocalization()\">\n        <i class=\"glyphicon hs-locateToggler\"\n            [ngClass]=\"(isFollowing() && getLocalization()) ? 'icon-navigation' : 'icon-gpson'\"></i><!-- TODO: Remove function call from template -->\n    </button>\n</div>","import {Component, OnInit} from '@angular/core';\n\nimport {HsGeolocationService} from './geolocation.service';\nimport {HsGuiOverlayBaseComponent} from 'hslayers-ng/common/panels';\n@Component({\n  selector: 'hs-geolocation',\n  templateUrl: './geolocation.component.html',\n})\nexport class HsGeolocationComponent\n  extends HsGuiOverlayBaseComponent\n  implements OnInit\n{\n  collapsed: boolean;\n\n  name = 'geolocationButton';\n\n  constructor(private hsGeolocationService: HsGeolocationService) {\n    super();\n  }\n  ngOnInit(): void {\n    this.collapsed = true;\n    super.ngOnInit();\n  }\n  isVisible(): boolean {\n    return (\n      this.hsLayoutService.componentEnabled('geolocationButton') &&\n      this.hsLayoutService.componentEnabled('guiOverlay')\n    );\n  }\n\n  /**\n   * Start localization\n   */\n  startLocalization(): void {\n    this.hsGeolocationService.startLocalization();\n  }\n\n  /**\n   * Stop localization\n   */\n  stopLocalization(): void {\n    this.hsGeolocationService.stopLocalization();\n  }\n\n  /**\n   * Get localization\n   */\n  getLocalization(): boolean {\n    return this.hsGeolocationService.localization;\n  }\n\n  /**\n   * Toggle tracking\n   */\n  toggleTracking(): void {\n    this.hsGeolocationService.toggleTracking();\n  }\n\n  /**\n   * Determine state of tracking\n   */\n  isFollowing(): boolean {\n    return this.hsGeolocationService.following;\n  }\n}\n","import {CUSTOM_ELEMENTS_SCHEMA, NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {FormsModule} from '@angular/forms';\n\nimport {HsGeolocationComponent} from './geolocation.component';\nimport {HsPanelHelpersModule} from 'hslayers-ng/common/panels';\nimport {TranslateCustomPipe} from 'hslayers-ng/services/language';\n\n@NgModule({\n  schemas: [CUSTOM_ELEMENTS_SCHEMA],\n  declarations: [HsGeolocationComponent],\n  imports: [\n    FormsModule,\n    CommonModule,\n    HsPanelHelpersModule,\n    TranslateCustomPipe,\n  ],\n  exports: [HsGeolocationComponent],\n})\nexport class HsGeolocationModule {}\n","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n"],"x_google_ignoreList":[0,5]}